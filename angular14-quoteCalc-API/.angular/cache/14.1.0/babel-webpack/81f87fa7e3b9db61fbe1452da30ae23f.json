{"ast":null,"code":"import { Subject } from 'rxjs';\nimport { throttleTime, tap, distinctUntilChanged, filter } from 'rxjs/operators';\nimport { supportsPassiveEvents } from 'detect-passive-events';\nimport { Directive, ElementRef, Renderer2, HostBinding, ChangeDetectorRef, Component, ViewChild, HostListener, Input, EventEmitter, Output, ContentChild, forwardRef, NgZone, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @enum {number} */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nconst _c0 = [\"tooltipTemplate\"];\nconst _c1 = [\"leftOuterSelectionBar\"];\nconst _c2 = [\"rightOuterSelectionBar\"];\nconst _c3 = [\"fullBar\"];\nconst _c4 = [\"selectionBar\"];\nconst _c5 = [\"minHandle\"];\nconst _c6 = [\"maxHandle\"];\nconst _c7 = [\"floorLabel\"];\nconst _c8 = [\"ceilLabel\"];\nconst _c9 = [\"minHandleLabel\"];\nconst _c10 = [\"maxHandleLabel\"];\nconst _c11 = [\"combinedLabel\"];\nconst _c12 = [\"ticksElement\"];\n\nfunction SliderComponent_span_28_ngx_slider_tooltip_wrapper_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"ngx-slider-tooltip-wrapper\", 31);\n  }\n\n  if (rf & 2) {\n    const t_r13 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r14 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"template\", ctx_r14.tooltipTemplate)(\"tooltip\", t_r13.valueTooltip)(\"placement\", t_r13.valueTooltipPlacement)(\"content\", t_r13.value);\n  }\n}\n\nfunction SliderComponent_span_28_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 32);\n  }\n\n  if (rf & 2) {\n    const t_r13 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵproperty(\"innerHTML\", t_r13.legend, ɵngcc0.ɵɵsanitizeHtml);\n  }\n}\n\nconst _c13 = function (a0) {\n  return {\n    \"ngx-slider-selected\": a0\n  };\n};\n\nfunction SliderComponent_span_28_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 27);\n    ɵngcc0.ɵɵelement(1, \"ngx-slider-tooltip-wrapper\", 28);\n    ɵngcc0.ɵɵtemplate(2, SliderComponent_span_28_ngx_slider_tooltip_wrapper_2_Template, 1, 4, \"ngx-slider-tooltip-wrapper\", 29);\n    ɵngcc0.ɵɵtemplate(3, SliderComponent_span_28_span_3_Template, 1, 1, \"span\", 30);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const t_r13 = ctx.$implicit;\n    const ctx_r12 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(7, _c13, t_r13.selected))(\"ngStyle\", t_r13.style);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"template\", ctx_r12.tooltipTemplate)(\"tooltip\", t_r13.tooltip)(\"placement\", t_r13.tooltipPlacement);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", t_r13.value != null);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", t_r13.legend != null);\n  }\n}\n\nfunction TooltipWrapperComponent_ng_container_0_1_ng_template_0_Template(rf, ctx) {}\n\nfunction TooltipWrapperComponent_ng_container_0_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, TooltipWrapperComponent_ng_container_0_1_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nconst _c14 = function (a0, a1, a2) {\n  return {\n    tooltip: a0,\n    placement: a1,\n    content: a2\n  };\n};\n\nfunction TooltipWrapperComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TooltipWrapperComponent_ng_container_0_1_Template, 1, 0, null, 1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction3(2, _c14, ctx_r0.tooltip, ctx_r0.placement, ctx_r0.content));\n  }\n}\n\nfunction TooltipWrapperComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"div\", 2);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"title\", ctx_r1.tooltip)(\"data-tooltip-placement\", ctx_r1.placement);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r1.content, \" \");\n  }\n}\n\nconst LabelType = {\n  /** Label above low pointer */\n  Low: 0,\n\n  /** Label above high pointer */\n  High: 1,\n\n  /** Label for minimum slider value */\n  Floor: 2,\n\n  /** Label for maximum slider value */\n  Ceil: 3,\n\n  /** Label below legend tick */\n  TickValue: 4\n};\nLabelType[LabelType.Low] = 'Low';\nLabelType[LabelType.High] = 'High';\nLabelType[LabelType.Floor] = 'Floor';\nLabelType[LabelType.Ceil] = 'Ceil';\nLabelType[LabelType.TickValue] = 'TickValue';\n/**\n * Slider options\n */\n\nclass Options {\n  constructor() {\n    /**\n     * Minimum value for a slider.\n     * Not applicable when using stepsArray.\n     */\n    this.floor = 0;\n    /**\n     * Maximum value for a slider.\n     * Not applicable when using stepsArray.\n     */\n\n    this.ceil = null;\n    /**\n     * Step between each value.\n     * Not applicable when using stepsArray.\n     */\n\n    this.step = 1;\n    /**\n     * The minimum range authorized on the slider.\n     * Applies to range slider only.\n     * When using stepsArray, expressed as index into stepsArray.\n     */\n\n    this.minRange = null;\n    /**\n     * The maximum range authorized on the slider.\n     * Applies to range slider only.\n     * When using stepsArray, expressed as index into stepsArray.\n     */\n\n    this.maxRange = null;\n    /**\n     * Set to true to have a push behavior. When the min handle goes above the max,\n     * the max is moved as well (and vice-versa). The range between min and max is\n     * defined by the step option (defaults to 1) and can also be overriden by\n     * the minRange option. Applies to range slider only.\n     */\n\n    this.pushRange = false;\n    /**\n     * The minimum value authorized on the slider.\n     * When using stepsArray, expressed as index into stepsArray.\n     */\n\n    this.minLimit = null;\n    /**\n     * The maximum value authorized on the slider.\n     * When using stepsArray, expressed as index into stepsArray.\n     */\n\n    this.maxLimit = null;\n    /**\n     * Custom translate function. Use this if you want to translate values displayed\n     * on the slider.\n     */\n\n    this.translate = null;\n    /**\n     * Custom function for combining overlapping labels in range slider.\n     * It takes the min and max values (already translated with translate fuction)\n     * and should return how these two values should be combined.\n     * If not provided, the default function will join the two values with\n     * ' - ' as separator.\n     */\n\n    this.combineLabels = null;\n    /**\n     * Use to display legend under ticks (thus, it needs to be used along with\n     * showTicks or showTicksValues). The function will be called with each tick\n     * value and returned content will be displayed under the tick as a legend.\n     * If the returned value is null, then no legend is displayed under\n     * the corresponding tick.You can also directly provide the legend values\n     * in the stepsArray option.\n     */\n\n    this.getLegend = null;\n    /**\n     * Use to display a custom legend of a stepItem from stepsArray.\n     * It will be the same as getLegend but for stepsArray.\n     */\n\n    this.getStepLegend = null;\n    /**\n     * If you want to display a slider with non linear/number steps.\n     * Just pass an array with each slider value and that's it; the floor, ceil and step settings\n     * of the slider will be computed automatically.\n     * By default, the value model and valueHigh model values will be the value of the selected item\n     * in the stepsArray.\n     * They can also be bound to the index of the selected item by setting the bindIndexForStepsArray\n     * option to true.\n     */\n\n    this.stepsArray = null;\n    /**\n     * Set to true to bind the index of the selected item to value model and valueHigh model.\n     */\n\n    this.bindIndexForStepsArray = false;\n    /**\n     * When set to true and using a range slider, the range can be dragged by the selection bar.\n     * Applies to range slider only.\n     */\n\n    this.draggableRange = false;\n    /**\n     * Same as draggableRange but the slider range can't be changed.\n     * Applies to range slider only.\n     */\n\n    this.draggableRangeOnly = false;\n    /**\n     * Set to true to always show the selection bar before the slider handle.\n     */\n\n    this.showSelectionBar = false;\n    /**\n     * Set to true to always show the selection bar after the slider handle.\n     */\n\n    this.showSelectionBarEnd = false;\n    /**\n     * Set a number to draw the selection bar between this value and the slider handle.\n     * When using stepsArray, expressed as index into stepsArray.\n     */\n\n    this.showSelectionBarFromValue = null;\n    /**\n     * Only for range slider. Set to true to visualize in different colour the areas\n     * on the left/right (top/bottom for vertical range slider) of selection bar between the handles.\n     */\n\n    this.showOuterSelectionBars = false;\n    /**\n     * Set to true to hide pointer labels\n     */\n\n    this.hidePointerLabels = false;\n    /**\n     * Set to true to hide min / max labels\n     */\n\n    this.hideLimitLabels = false;\n    /**\n     * Set to false to disable the auto-hiding behavior of the limit labels.\n     */\n\n    this.autoHideLimitLabels = true;\n    /**\n     * Set to true to make the slider read-only.\n     */\n\n    this.readOnly = false;\n    /**\n     * Set to true to disable the slider.\n     */\n\n    this.disabled = false;\n    /**\n     * Set to true to display a tick for each step of the slider.\n     */\n\n    this.showTicks = false;\n    /**\n     * Set to true to display a tick and the step value for each step of the slider..\n     */\n\n    this.showTicksValues = false;\n    /* The step between each tick to display. If not set, the step value is used.\n        Not used when ticksArray is specified. */\n\n    this.tickStep = null;\n    /* The step between displaying each tick step value.\n        If not set, then tickStep or step is used, depending on which one is set. */\n\n    this.tickValueStep = null;\n    /**\n     * Use to display ticks at specific positions.\n     * The array contains the index of the ticks that should be displayed.\n     * For example, [0, 1, 5] will display a tick for the first, second and sixth values.\n     */\n\n    this.ticksArray = null;\n    /**\n     * Used to display a tooltip when a tick is hovered.\n     * Set to a function that returns the tooltip content for a given value.\n     */\n\n    this.ticksTooltip = null;\n    /**\n     * Same as ticksTooltip but for ticks values.\n     */\n\n    this.ticksValuesTooltip = null;\n    /**\n     * Set to true to display the slider vertically.\n     * The slider will take the full height of its parent.\n     * Changing this value at runtime is not currently supported.\n     */\n\n    this.vertical = false;\n    /**\n     * Function that returns the current color of the selection bar.\n     * If your color won't change, don't use this option but set it through CSS.\n     * If the returned color depends on a model value (either value or valueHigh),\n     * you should use the argument passed to the function.\n     * Indeed, when the function is called, there is no certainty that the model\n     * has already been updated.\n     */\n\n    this.getSelectionBarColor = null;\n    /**\n     * Function that returns the color of a tick. showTicks must be enabled.\n     */\n\n    this.getTickColor = null;\n    /**\n     * Function that returns the current color of a pointer.\n     * If your color won't change, don't use this option but set it through CSS.\n     * If the returned color depends on a model value (either value or valueHigh),\n     * you should use the argument passed to the function.\n     * Indeed, when the function is called, there is no certainty that the model has already been updated.\n     * To handle range slider pointers independently, you should evaluate pointerType within the given\n     * function where \"min\" stands for value model and \"max\" for valueHigh model values.\n     */\n\n    this.getPointerColor = null;\n    /**\n     * Handles are focusable (on click or with tab) and can be modified using the following keyboard controls:\n     * Left/bottom arrows: -1\n     * Right/top arrows: +1\n     * Page-down: -10%\n     * Page-up: +10%\n     * Home: minimum value\n     * End: maximum value\n     */\n\n    this.keyboardSupport = true;\n    /**\n     * If you display the slider in an element that uses transform: scale(0.5), set the scale value to 2\n     * so that the slider is rendered properly and the events are handled correctly.\n     */\n\n    this.scale = 1;\n    /**\n     * If you display the slider in an element that uses transform: rotate(90deg), set the rotate value to 90\n     * so that the slider is rendered properly and the events are handled correctly. Value is in degrees.\n     */\n\n    this.rotate = 0;\n    /**\n     * Set to true to force the value(s) to be rounded to the step, even when modified from the outside.\n     * When set to false, if the model values are modified from outside the slider, they are not rounded\n     * and can be between two steps.\n     */\n\n    this.enforceStep = true;\n    /**\n     * Set to true to force the value(s) to be normalised to allowed range (floor to ceil), even when modified from the outside.\n     * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,\n     * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.\n     */\n\n    this.enforceRange = true;\n    /**\n     * Set to true to force the value(s) to be rounded to the nearest step value, even when modified from the outside.\n     * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,\n     * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.\n     */\n\n    this.enforceStepsArray = true;\n    /**\n     * Set to true to prevent to user from switching the min and max handles. Applies to range slider only.\n     */\n\n    this.noSwitching = false;\n    /**\n     * Set to true to only bind events on slider handles.\n     */\n\n    this.onlyBindHandles = false;\n    /**\n     * Set to true to show graphs right to left.\n     * If vertical is true it will be from top to bottom and left / right arrow functions reversed.\n     */\n\n    this.rightToLeft = false;\n    /**\n     * Set to true to reverse keyboard navigation:\n     * Right/top arrows: -1\n     * Left/bottom arrows: +1\n     * Page-up: -10%\n     * Page-down: +10%\n     * End: minimum value\n     * Home: maximum value\n     */\n\n    this.reversedControls = false;\n    /**\n     * Set to true to keep the slider labels inside the slider bounds.\n     */\n\n    this.boundPointerLabels = true;\n    /**\n     * Set to true to use a logarithmic scale to display the slider.\n     */\n\n    this.logScale = false;\n    /**\n     * Function that returns the position on the slider for a given value.\n     * The position must be a percentage between 0 and 1.\n     * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.\n     */\n\n    this.customValueToPosition = null;\n    /**\n     * Function that returns the value for a given position on the slider.\n     * The position is a percentage between 0 and 1.\n     * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.\n     */\n\n    this.customPositionToValue = null;\n    /**\n     * Precision limit for calculated values.\n     * Values used in calculations will be rounded to this number of significant digits\n     * to prevent accumulating small floating-point errors.\n     */\n\n    this.precisionLimit = 12;\n    /**\n     * Use to display the selection bar as a gradient.\n     * The given object must contain from and to properties which are colors.\n     */\n\n    this.selectionBarGradient = null;\n    /**\n     * Use to add a label directly to the slider for accessibility. Adds the aria-label attribute.\n     */\n\n    this.ariaLabel = 'ngx-slider';\n    /**\n     * Use instead of ariaLabel to reference the id of an element which will be used to label the slider.\n     * Adds the aria-labelledby attribute.\n     */\n\n    this.ariaLabelledBy = null;\n    /**\n     * Use to add a label directly to the slider range for accessibility. Adds the aria-label attribute.\n     */\n\n    this.ariaLabelHigh = 'ngx-slider-max';\n    /**\n     * Use instead of ariaLabelHigh to reference the id of an element which will be used to label the slider range.\n     * Adds the aria-labelledby attribute.\n     */\n\n    this.ariaLabelledByHigh = null;\n    /**\n     * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the handle\n     */\n\n    this.handleDimension = null;\n    /**\n     * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the bar\n     */\n\n    this.barDimension = null;\n    /**\n     * Enable/disable CSS animations\n     */\n\n    this.animate = true;\n    /**\n     * Enable/disable CSS animations while moving the slider\n     */\n\n    this.animateOnMove = false;\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @enum {number} */\n\n\nconst PointerType = {\n  /** Low pointer */\n  Min: 0,\n\n  /** High pointer */\n  Max: 1\n};\nPointerType[PointerType.Min] = 'Min';\nPointerType[PointerType.Max] = 'Max';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nclass ChangeContext {}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n *  Collection of functions to handle conversions/lookups of values\n */\n\n\nclass ValueHelper {\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  static isNullOrUndefined(value) {\n    return value === undefined || value === null;\n  }\n  /**\n   * @param {?} array1\n   * @param {?} array2\n   * @return {?}\n   */\n\n\n  static areArraysEqual(array1, array2) {\n    if (array1.length !== array2.length) {\n      return false;\n    }\n\n    for (let i = 0; i < array1.length; ++i) {\n      if (array1[i] !== array2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * @param {?} val\n   * @param {?} minVal\n   * @param {?} maxVal\n   * @return {?}\n   */\n\n\n  static linearValueToPosition(val, minVal, maxVal) {\n    /** @type {?} */\n    const range = maxVal - minVal;\n    return (val - minVal) / range;\n  }\n  /**\n   * @param {?} val\n   * @param {?} minVal\n   * @param {?} maxVal\n   * @return {?}\n   */\n\n\n  static logValueToPosition(val, minVal, maxVal) {\n    val = Math.log(val);\n    minVal = Math.log(minVal);\n    maxVal = Math.log(maxVal);\n    /** @type {?} */\n\n    const range = maxVal - minVal;\n    return (val - minVal) / range;\n  }\n  /**\n   * @param {?} percent\n   * @param {?} minVal\n   * @param {?} maxVal\n   * @return {?}\n   */\n\n\n  static linearPositionToValue(percent, minVal, maxVal) {\n    return percent * (maxVal - minVal) + minVal;\n  }\n  /**\n   * @param {?} percent\n   * @param {?} minVal\n   * @param {?} maxVal\n   * @return {?}\n   */\n\n\n  static logPositionToValue(percent, minVal, maxVal) {\n    minVal = Math.log(minVal);\n    maxVal = Math.log(maxVal);\n    /** @type {?} */\n\n    const value = percent * (maxVal - minVal) + minVal;\n    return Math.exp(value);\n  }\n  /**\n   * @param {?} modelValue\n   * @param {?} stepsArray\n   * @return {?}\n   */\n\n\n  static findStepIndex(modelValue, stepsArray) {\n    /** @type {?} */\n    const differences = stepsArray.map(step => Math.abs(modelValue - step.value));\n    /** @type {?} */\n\n    let minDifferenceIndex = 0;\n\n    for (let index = 0; index < stepsArray.length; index++) {\n      if (differences[index] !== differences[minDifferenceIndex] && differences[index] < differences[minDifferenceIndex]) {\n        minDifferenceIndex = index;\n      }\n    }\n\n    return minDifferenceIndex;\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Helper with compatibility functions to support different browsers\n */\n\n\nclass CompatibilityHelper {\n  /**\n   * Workaround for TouchEvent constructor sadly not being available on all browsers (e.g. Firefox, Safari)\n   * @param {?} event\n   * @return {?}\n   */\n  static isTouchEvent(event) {\n    if (\n    /** @type {?} */\n    window.TouchEvent !== undefined) {\n      return event instanceof TouchEvent;\n    }\n\n    return event.touches !== undefined;\n  }\n  /**\n   * Detect presence of ResizeObserver API\n   * @return {?}\n   */\n\n\n  static isResizeObserverAvailable() {\n    return (\n      /** @type {?} */\n      window.ResizeObserver !== undefined\n    );\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Helper with mathematical functions\n */\n\n\nclass MathHelper {\n  /**\n   * @param {?} value\n   * @param {?} precisionLimit\n   * @return {?}\n   */\n  static roundToPrecisionLimit(value, precisionLimit) {\n    return +value.toPrecision(precisionLimit);\n  }\n  /**\n   * @param {?} value\n   * @param {?} modulo\n   * @param {?} precisionLimit\n   * @return {?}\n   */\n\n\n  static isModuloWithinPrecisionLimit(value, modulo, precisionLimit) {\n    /** @type {?} */\n    const limit = Math.pow(10, -precisionLimit);\n    return Math.abs(value % modulo) <= limit || Math.abs(Math.abs(value % modulo) - modulo) <= limit;\n  }\n  /**\n   * @param {?} value\n   * @param {?} floor\n   * @param {?} ceil\n   * @return {?}\n   */\n\n\n  static clampToRange(value, floor, ceil) {\n    return Math.min(Math.max(value, floor), ceil);\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nclass EventListener {\n  constructor() {\n    this.eventName = null;\n    this.events = null;\n    this.eventsSubscription = null;\n    this.teardownCallback = null;\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Helper class to attach event listeners to DOM elements with debounce support using rxjs\n */\n\n\nclass EventListenerHelper {\n  /**\n   * @param {?} renderer\n   */\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  /**\n   * @param {?} nativeElement\n   * @param {?} eventName\n   * @param {?} callback\n   * @param {?=} throttleInterval\n   * @return {?}\n   */\n\n\n  attachPassiveEventListener(nativeElement, eventName, callback, throttleInterval) {\n    // Only use passive event listeners if the browser supports it\n    if (supportsPassiveEvents !== true) {\n      return this.attachEventListener(nativeElement, eventName, callback, throttleInterval);\n    }\n    /** @type {?} */\n\n\n    const listener = new EventListener();\n    listener.eventName = eventName;\n    listener.events = new Subject();\n    /** @type {?} */\n\n    const observerCallback = event => {\n      listener.events.next(event);\n    };\n\n    nativeElement.addEventListener(eventName, observerCallback, {\n      passive: true,\n      capture: false\n    });\n\n    listener.teardownCallback = () => {\n      nativeElement.removeEventListener(eventName, observerCallback, {\n        passive: true,\n        capture: false\n      });\n    };\n\n    listener.eventsSubscription = listener.events.pipe(!ValueHelper.isNullOrUndefined(throttleInterval) ? throttleTime(throttleInterval, undefined, {\n      leading: true,\n      trailing: true\n    }) : tap(() => {}) // no-op\n    ).subscribe(event => {\n      callback(event);\n    });\n    return listener;\n  }\n  /**\n   * @param {?} eventListener\n   * @return {?}\n   */\n\n\n  detachEventListener(eventListener) {\n    if (!ValueHelper.isNullOrUndefined(eventListener.eventsSubscription)) {\n      eventListener.eventsSubscription.unsubscribe();\n      eventListener.eventsSubscription = null;\n    }\n\n    if (!ValueHelper.isNullOrUndefined(eventListener.events)) {\n      eventListener.events.complete();\n      eventListener.events = null;\n    }\n\n    if (!ValueHelper.isNullOrUndefined(eventListener.teardownCallback)) {\n      eventListener.teardownCallback();\n      eventListener.teardownCallback = null;\n    }\n  }\n  /**\n   * @param {?} nativeElement\n   * @param {?} eventName\n   * @param {?} callback\n   * @param {?=} throttleInterval\n   * @return {?}\n   */\n\n\n  attachEventListener(nativeElement, eventName, callback, throttleInterval) {\n    /** @type {?} */\n    const listener = new EventListener();\n    listener.eventName = eventName;\n    listener.events = new Subject();\n    /** @type {?} */\n\n    const observerCallback = event => {\n      listener.events.next(event);\n    };\n\n    listener.teardownCallback = this.renderer.listen(nativeElement, eventName, observerCallback);\n    listener.eventsSubscription = listener.events.pipe(!ValueHelper.isNullOrUndefined(throttleInterval) ? throttleTime(throttleInterval, undefined, {\n      leading: true,\n      trailing: true\n    }) : tap(() => {}) // no-op\n    ).subscribe(event => {\n      callback(event);\n    });\n    return listener;\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nclass SliderElementDirective {\n  /**\n   * @param {?} elemRef\n   * @param {?} renderer\n   * @param {?} changeDetectionRef\n   */\n  constructor(elemRef, renderer, changeDetectionRef) {\n    this.elemRef = elemRef;\n    this.renderer = renderer;\n    this.changeDetectionRef = changeDetectionRef;\n    this._position = 0;\n    this._dimension = 0;\n    this._alwaysHide = false;\n    this._vertical = false;\n    this._scale = 1;\n    this._rotate = 0;\n    this.opacity = 1;\n    this.visibility = 'visible';\n    this.left = '';\n    this.bottom = '';\n    this.height = '';\n    this.width = '';\n    this.transform = '';\n    this.eventListeners = [];\n    this.eventListenerHelper = new EventListenerHelper(this.renderer);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get position() {\n    return this._position;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get dimension() {\n    return this._dimension;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get alwaysHide() {\n    return this._alwaysHide;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get vertical() {\n    return this._vertical;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get scale() {\n    return this._scale;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get rotate() {\n    return this._rotate;\n  }\n  /**\n   * @param {?} hide\n   * @return {?}\n   */\n\n\n  setAlwaysHide(hide) {\n    this._alwaysHide = hide;\n\n    if (hide) {\n      this.visibility = 'hidden';\n    } else {\n      this.visibility = 'visible';\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  hide() {\n    this.opacity = 0;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  show() {\n    if (this.alwaysHide) {\n      return;\n    }\n\n    this.opacity = 1;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  isVisible() {\n    if (this.alwaysHide) {\n      return false;\n    }\n\n    return this.opacity !== 0;\n  }\n  /**\n   * @param {?} vertical\n   * @return {?}\n   */\n\n\n  setVertical(vertical) {\n    this._vertical = vertical;\n\n    if (this._vertical) {\n      this.left = '';\n      this.width = '';\n    } else {\n      this.bottom = '';\n      this.height = '';\n    }\n  }\n  /**\n   * @param {?} scale\n   * @return {?}\n   */\n\n\n  setScale(scale) {\n    this._scale = scale;\n  }\n  /**\n   * @param {?} rotate\n   * @return {?}\n   */\n\n\n  setRotate(rotate) {\n    this._rotate = rotate;\n    this.transform = 'rotate(' + rotate + 'deg)';\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getRotate() {\n    return this._rotate;\n  }\n  /**\n   * @param {?} pos\n   * @return {?}\n   */\n\n\n  setPosition(pos) {\n    if (this._position !== pos && !this.isRefDestroyed()) {\n      this.changeDetectionRef.markForCheck();\n    }\n\n    this._position = pos;\n\n    if (this._vertical) {\n      this.bottom = Math.round(pos) + 'px';\n    } else {\n      this.left = Math.round(pos) + 'px';\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  calculateDimension() {\n    /** @type {?} */\n    const val = this.getBoundingClientRect();\n\n    if (this.vertical) {\n      this._dimension = (val.bottom - val.top) * this.scale;\n    } else {\n      this._dimension = (val.right - val.left) * this.scale;\n    }\n  }\n  /**\n   * @param {?} dim\n   * @return {?}\n   */\n\n\n  setDimension(dim) {\n    if (this._dimension !== dim && !this.isRefDestroyed()) {\n      this.changeDetectionRef.markForCheck();\n    }\n\n    this._dimension = dim;\n\n    if (this._vertical) {\n      this.height = Math.round(dim) + 'px';\n    } else {\n      this.width = Math.round(dim) + 'px';\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getBoundingClientRect() {\n    return this.elemRef.nativeElement.getBoundingClientRect();\n  }\n  /**\n   * @param {?} eventName\n   * @param {?} callback\n   * @param {?=} debounceInterval\n   * @return {?}\n   */\n\n\n  on(eventName, callback, debounceInterval) {\n    /** @type {?} */\n    const listener = this.eventListenerHelper.attachEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);\n    this.eventListeners.push(listener);\n  }\n  /**\n   * @param {?} eventName\n   * @param {?} callback\n   * @param {?=} debounceInterval\n   * @return {?}\n   */\n\n\n  onPassive(eventName, callback, debounceInterval) {\n    /** @type {?} */\n    const listener = this.eventListenerHelper.attachPassiveEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);\n    this.eventListeners.push(listener);\n  }\n  /**\n   * @param {?=} eventName\n   * @return {?}\n   */\n\n\n  off(eventName) {\n    /** @type {?} */\n    let listenersToKeep;\n    /** @type {?} */\n\n    let listenersToRemove;\n\n    if (!ValueHelper.isNullOrUndefined(eventName)) {\n      listenersToKeep = this.eventListeners.filter(event => event.eventName !== eventName);\n      listenersToRemove = this.eventListeners.filter(event => event.eventName === eventName);\n    } else {\n      listenersToKeep = [];\n      listenersToRemove = this.eventListeners;\n    }\n\n    for (const listener of listenersToRemove) {\n      this.eventListenerHelper.detachEventListener(listener);\n    }\n\n    this.eventListeners = listenersToKeep;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  isRefDestroyed() {\n    return ValueHelper.isNullOrUndefined(this.changeDetectionRef) || this.changeDetectionRef['destroyed'];\n  }\n\n}\n\nSliderElementDirective.ɵfac = function SliderElementDirective_Factory(t) {\n  return new (t || SliderElementDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n};\n\nSliderElementDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: SliderElementDirective,\n  selectors: [[\"\", \"ngxSliderElement\", \"\"]],\n  hostVars: 14,\n  hostBindings: function SliderElementDirective_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵstyleProp(\"opacity\", ctx.opacity)(\"visibility\", ctx.visibility)(\"left\", ctx.left)(\"bottom\", ctx.bottom)(\"height\", ctx.height)(\"width\", ctx.width)(\"transform\", ctx.transform);\n    }\n  }\n});\n/** @nocollapse */\n\nSliderElementDirective.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: Renderer2\n}, {\n  type: ChangeDetectorRef\n}];\n\nSliderElementDirective.propDecorators = {\n  opacity: [{\n    type: HostBinding,\n    args: ['style.opacity']\n  }],\n  visibility: [{\n    type: HostBinding,\n    args: ['style.visibility']\n  }],\n  left: [{\n    type: HostBinding,\n    args: ['style.left']\n  }],\n  bottom: [{\n    type: HostBinding,\n    args: ['style.bottom']\n  }],\n  height: [{\n    type: HostBinding,\n    args: ['style.height']\n  }],\n  width: [{\n    type: HostBinding,\n    args: ['style.width']\n  }],\n  transform: [{\n    type: HostBinding,\n    args: ['style.transform']\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderElementDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxSliderElement]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: ɵngcc0.ChangeDetectorRef\n    }];\n  }, {\n    opacity: [{\n      type: HostBinding,\n      args: ['style.opacity']\n    }],\n    visibility: [{\n      type: HostBinding,\n      args: ['style.visibility']\n    }],\n    left: [{\n      type: HostBinding,\n      args: ['style.left']\n    }],\n    bottom: [{\n      type: HostBinding,\n      args: ['style.bottom']\n    }],\n    height: [{\n      type: HostBinding,\n      args: ['style.height']\n    }],\n    width: [{\n      type: HostBinding,\n      args: ['style.width']\n    }],\n    transform: [{\n      type: HostBinding,\n      args: ['style.transform']\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nclass SliderHandleDirective extends SliderElementDirective {\n  /**\n   * @param {?} elemRef\n   * @param {?} renderer\n   * @param {?} changeDetectionRef\n   */\n  constructor(elemRef, renderer, changeDetectionRef) {\n    super(elemRef, renderer, changeDetectionRef);\n    this.active = false;\n    this.role = '';\n    this.tabindex = '';\n    this.ariaOrientation = '';\n    this.ariaLabel = '';\n    this.ariaLabelledBy = '';\n    this.ariaValueNow = '';\n    this.ariaValueText = '';\n    this.ariaValueMin = '';\n    this.ariaValueMax = '';\n  }\n  /**\n   * @return {?}\n   */\n\n\n  focus() {\n    this.elemRef.nativeElement.focus();\n  }\n\n}\n\nSliderHandleDirective.ɵfac = function SliderHandleDirective_Factory(t) {\n  return new (t || SliderHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n};\n\nSliderHandleDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: SliderHandleDirective,\n  selectors: [[\"\", \"ngxSliderHandle\", \"\"]],\n  hostVars: 11,\n  hostBindings: function SliderHandleDirective_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"role\", ctx.role)(\"tabindex\", ctx.tabindex)(\"aria-orientation\", ctx.ariaOrientation)(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledBy)(\"aria-valuenow\", ctx.ariaValueNow)(\"aria-valuetext\", ctx.ariaValueText)(\"aria-valuemin\", ctx.ariaValueMin)(\"aria-valuemax\", ctx.ariaValueMax);\n      ɵngcc0.ɵɵclassProp(\"ngx-slider-active\", ctx.active);\n    }\n  },\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n/** @nocollapse */\n\nSliderHandleDirective.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: Renderer2\n}, {\n  type: ChangeDetectorRef\n}];\n\nSliderHandleDirective.propDecorators = {\n  active: [{\n    type: HostBinding,\n    args: ['class.ngx-slider-active']\n  }],\n  role: [{\n    type: HostBinding,\n    args: ['attr.role']\n  }],\n  tabindex: [{\n    type: HostBinding,\n    args: ['attr.tabindex']\n  }],\n  ariaOrientation: [{\n    type: HostBinding,\n    args: ['attr.aria-orientation']\n  }],\n  ariaLabel: [{\n    type: HostBinding,\n    args: ['attr.aria-label']\n  }],\n  ariaLabelledBy: [{\n    type: HostBinding,\n    args: ['attr.aria-labelledby']\n  }],\n  ariaValueNow: [{\n    type: HostBinding,\n    args: ['attr.aria-valuenow']\n  }],\n  ariaValueText: [{\n    type: HostBinding,\n    args: ['attr.aria-valuetext']\n  }],\n  ariaValueMin: [{\n    type: HostBinding,\n    args: ['attr.aria-valuemin']\n  }],\n  ariaValueMax: [{\n    type: HostBinding,\n    args: ['attr.aria-valuemax']\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderHandleDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxSliderHandle]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: ɵngcc0.ChangeDetectorRef\n    }];\n  }, {\n    active: [{\n      type: HostBinding,\n      args: ['class.ngx-slider-active']\n    }],\n    role: [{\n      type: HostBinding,\n      args: ['attr.role']\n    }],\n    tabindex: [{\n      type: HostBinding,\n      args: ['attr.tabindex']\n    }],\n    ariaOrientation: [{\n      type: HostBinding,\n      args: ['attr.aria-orientation']\n    }],\n    ariaLabel: [{\n      type: HostBinding,\n      args: ['attr.aria-label']\n    }],\n    ariaLabelledBy: [{\n      type: HostBinding,\n      args: ['attr.aria-labelledby']\n    }],\n    ariaValueNow: [{\n      type: HostBinding,\n      args: ['attr.aria-valuenow']\n    }],\n    ariaValueText: [{\n      type: HostBinding,\n      args: ['attr.aria-valuetext']\n    }],\n    ariaValueMin: [{\n      type: HostBinding,\n      args: ['attr.aria-valuemin']\n    }],\n    ariaValueMax: [{\n      type: HostBinding,\n      args: ['attr.aria-valuemax']\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nclass SliderLabelDirective extends SliderElementDirective {\n  /**\n   * @param {?} elemRef\n   * @param {?} renderer\n   * @param {?} changeDetectionRef\n   */\n  constructor(elemRef, renderer, changeDetectionRef) {\n    super(elemRef, renderer, changeDetectionRef);\n    this._value = null;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get value() {\n    return this._value;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  setValue(value) {\n    /** @type {?} */\n    let recalculateDimension = false;\n\n    if (!this.alwaysHide && (ValueHelper.isNullOrUndefined(this.value) || this.value.length !== value.length || this.value.length > 0 && this.dimension === 0)) {\n      recalculateDimension = true;\n    }\n\n    this._value = value;\n    this.elemRef.nativeElement.innerHTML = value; // Update dimension only when length of the label have changed\n\n    if (recalculateDimension) {\n      this.calculateDimension();\n    }\n  }\n\n}\n\nSliderLabelDirective.ɵfac = function SliderLabelDirective_Factory(t) {\n  return new (t || SliderLabelDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n};\n\nSliderLabelDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: SliderLabelDirective,\n  selectors: [[\"\", \"ngxSliderLabel\", \"\"]],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n/** @nocollapse */\n\nSliderLabelDirective.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: Renderer2\n}, {\n  type: ChangeDetectorRef\n}];\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderLabelDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxSliderLabel]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: ɵngcc0.ChangeDetectorRef\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nclass Tick {\n  constructor() {\n    this.selected = false;\n    this.style = {};\n    this.tooltip = null;\n    this.tooltipPlacement = null;\n    this.value = null;\n    this.valueTooltip = null;\n    this.valueTooltipPlacement = null;\n    this.legend = null;\n  }\n\n}\n\nclass Dragging {\n  constructor() {\n    this.active = false;\n    this.value = 0;\n    this.difference = 0;\n    this.position = 0;\n    this.lowLimit = 0;\n    this.highLimit = 0;\n  }\n\n}\n\nclass ModelValues {\n  /**\n   * @param {?=} x\n   * @param {?=} y\n   * @return {?}\n   */\n  static compare(x, y) {\n    if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n      return false;\n    }\n\n    if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n      return false;\n    }\n\n    return x.value === y.value && x.highValue === y.highValue;\n  }\n\n}\n\nclass ModelChange extends ModelValues {\n  /**\n   * @param {?=} x\n   * @param {?=} y\n   * @return {?}\n   */\n  static compare(x, y) {\n    if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n      return false;\n    }\n\n    if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n      return false;\n    }\n\n    return x.value === y.value && x.highValue === y.highValue && x.forceChange === y.forceChange;\n  }\n\n}\n/** @type {?} */\n\n\nconst NGX_SLIDER_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n\n  /* tslint:disable-next-line: no-use-before-declare */\n  useExisting: forwardRef(() => SliderComponent),\n  multi: true\n};\n\nclass SliderComponent {\n  /**\n   * @param {?} renderer\n   * @param {?} elementRef\n   * @param {?} changeDetectionRef\n   * @param {?} zone\n   */\n  constructor(renderer, elementRef, changeDetectionRef, zone) {\n    this.renderer = renderer;\n    this.elementRef = elementRef;\n    this.changeDetectionRef = changeDetectionRef;\n    this.zone = zone; // Model for low value of slider. For simple slider, this is the only input. For range slider, this is the low value.\n\n    this.value = null; // Output for low value slider to support two-way bindings\n\n    this.valueChange = new EventEmitter(); // Model for high value of slider. Not used in simple slider. For range slider, this is the high value.\n\n    this.highValue = null; // Output for high value slider to support two-way bindings\n\n    this.highValueChange = new EventEmitter(); // An object with all the other options of the slider.\n    // Each option can be updated at runtime and the slider will automatically be re-rendered.\n\n    this.options = new Options(); // Event emitted when user starts interaction with the slider\n\n    this.userChangeStart = new EventEmitter(); // Event emitted on each change coming from user interaction\n\n    this.userChange = new EventEmitter(); // Event emitted when user finishes interaction with the slider\n\n    this.userChangeEnd = new EventEmitter();\n    this.initHasRun = false;\n    this.inputModelChangeSubject = new Subject();\n    this.inputModelChangeSubscription = null;\n    this.outputModelChangeSubject = new Subject();\n    this.outputModelChangeSubscription = null;\n    this.viewLowValue = null;\n    this.viewHighValue = null;\n    this.viewOptions = new Options();\n    this.handleHalfDimension = 0;\n    this.maxHandlePosition = 0;\n    this.currentTrackingPointer = null;\n    this.currentFocusPointer = null;\n    this.firstKeyDown = false;\n    this.touchId = null;\n    this.dragging = new Dragging(); // Host element class bindings\n\n    this.sliderElementVerticalClass = false;\n    this.sliderElementAnimateClass = false;\n    this.sliderElementWithLegendClass = false;\n    this.sliderElementDisabledAttr = null;\n    this.sliderElementAriaLabel = 'ngx-slider';\n    this.barStyle = {};\n    this.minPointerStyle = {};\n    this.maxPointerStyle = {};\n    this.fullBarTransparentClass = false;\n    this.selectionBarDraggableClass = false;\n    this.ticksUnderValuesClass = false;\n    this.intermediateTicks = false;\n    this.ticks = [];\n    this.eventListenerHelper = null;\n    this.onMoveEventListener = null;\n    this.onEndEventListener = null;\n    this.moving = false;\n    this.resizeObserver = null;\n    this.onTouchedCallback = null;\n    this.onChangeCallback = null;\n    this.eventListenerHelper = new EventListenerHelper(this.renderer);\n  }\n  /**\n   * @param {?} manualRefresh\n   * @return {?}\n   */\n\n\n  set manualRefresh(manualRefresh) {\n    this.unsubscribeManualRefresh();\n    this.manualRefreshSubscription = manualRefresh.subscribe(() => {\n      setTimeout(() => this.calculateViewDimensionsAndDetectChanges());\n    });\n  }\n  /**\n   * @param {?} triggerFocus\n   * @return {?}\n   */\n\n\n  set triggerFocus(triggerFocus) {\n    this.unsubscribeTriggerFocus();\n    this.triggerFocusSubscription = triggerFocus.subscribe(pointerType => {\n      this.focusPointer(pointerType);\n    });\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get range() {\n    return !ValueHelper.isNullOrUndefined(this.value) && !ValueHelper.isNullOrUndefined(this.highValue);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get showTicks() {\n    return this.viewOptions.showTicks;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnInit() {\n    this.viewOptions = new Options();\n    Object.assign(this.viewOptions, this.options); // We need to run these two things first, before the rest of the init in ngAfterViewInit(),\n    // because these two settings are set through @HostBinding and Angular change detection\n    // mechanism doesn't like them changing in ngAfterViewInit()\n\n    this.updateDisabledState();\n    this.updateVerticalState();\n    this.updateAriaLabel();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngAfterViewInit() {\n    this.applyOptions();\n    this.subscribeInputModelChangeSubject();\n    this.subscribeOutputModelChangeSubject(); // Once we apply options, we need to normalise model values for the first time\n\n    this.renormaliseModelValues();\n    this.viewLowValue = this.modelValueToViewValue(this.value);\n\n    if (this.range) {\n      this.viewHighValue = this.modelValueToViewValue(this.highValue);\n    } else {\n      this.viewHighValue = null;\n    }\n\n    this.updateVerticalState(); // need to run this again to cover changes to slider elements\n\n    this.manageElementsStyle();\n    this.updateDisabledState();\n    this.calculateViewDimensions();\n    this.addAccessibility();\n    this.updateCeilLabel();\n    this.updateFloorLabel();\n    this.initHandles();\n    this.manageEventsBindings();\n    this.updateAriaLabel();\n    this.subscribeResizeObserver();\n    this.initHasRun = true; // Run change detection manually to resolve some issues when init procedure changes values used in the view\n\n    if (!this.isRefDestroyed()) {\n      this.changeDetectionRef.detectChanges();\n    }\n  }\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n\n\n  ngOnChanges(changes) {\n    // Always apply options first\n    if (!ValueHelper.isNullOrUndefined(changes[\"options\"]) && JSON.stringify(changes[\"options\"].previousValue) !== JSON.stringify(changes[\"options\"].currentValue)) {\n      this.onChangeOptions();\n    } // Then value changes\n\n\n    if (!ValueHelper.isNullOrUndefined(changes[\"value\"]) || !ValueHelper.isNullOrUndefined(changes[\"highValue\"])) {\n      this.inputModelChangeSubject.next({\n        value: this.value,\n        highValue: this.highValue,\n        forceChange: false,\n        internalChange: false\n      });\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    this.unbindEvents();\n    this.unsubscribeResizeObserver();\n    this.unsubscribeInputModelChangeSubject();\n    this.unsubscribeOutputModelChangeSubject();\n    this.unsubscribeManualRefresh();\n    this.unsubscribeTriggerFocus();\n  }\n  /**\n   * @param {?} obj\n   * @return {?}\n   */\n\n\n  writeValue(obj) {\n    if (obj instanceof Array) {\n      this.value = obj[0];\n      this.highValue = obj[1];\n    } else {\n      this.value = obj;\n    } // ngOnChanges() is not called in this instance, so we need to communicate the change manually\n\n\n    this.inputModelChangeSubject.next({\n      value: this.value,\n      highValue: this.highValue,\n      forceChange: false,\n      internalChange: false\n    });\n  }\n  /**\n   * @param {?} onChangeCallback\n   * @return {?}\n   */\n\n\n  registerOnChange(onChangeCallback) {\n    this.onChangeCallback = onChangeCallback;\n  }\n  /**\n   * @param {?} onTouchedCallback\n   * @return {?}\n   */\n\n\n  registerOnTouched(onTouchedCallback) {\n    this.onTouchedCallback = onTouchedCallback;\n  }\n  /**\n   * @param {?} isDisabled\n   * @return {?}\n   */\n\n\n  setDisabledState(isDisabled) {\n    this.viewOptions.disabled = isDisabled;\n    this.updateDisabledState();\n  }\n  /**\n   * @param {?} ariaLabel\n   * @return {?}\n   */\n\n\n  setAriaLabel(ariaLabel) {\n    this.viewOptions.ariaLabel = ariaLabel;\n    this.updateAriaLabel();\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  onResize(event) {\n    this.calculateViewDimensionsAndDetectChanges();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  subscribeInputModelChangeSubject() {\n    this.inputModelChangeSubscription = this.inputModelChangeSubject.pipe(distinctUntilChanged(ModelChange.compare), // Hack to reset the status of the distinctUntilChanged() - if a \"fake\" event comes through with forceChange=true,\n    // we forcefully by-pass distinctUntilChanged(), but otherwise drop the event\n    filter(modelChange => !modelChange.forceChange && !modelChange.internalChange)).subscribe(modelChange => this.applyInputModelChange(modelChange));\n  }\n  /**\n   * @return {?}\n   */\n\n\n  subscribeOutputModelChangeSubject() {\n    this.outputModelChangeSubscription = this.outputModelChangeSubject.pipe(distinctUntilChanged(ModelChange.compare)).subscribe(modelChange => this.publishOutputModelChange(modelChange));\n  }\n  /**\n   * @return {?}\n   */\n\n\n  subscribeResizeObserver() {\n    if (CompatibilityHelper.isResizeObserverAvailable()) {\n      this.resizeObserver = new ResizeObserver(() => this.calculateViewDimensionsAndDetectChanges());\n      this.resizeObserver.observe(this.elementRef.nativeElement);\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  unsubscribeResizeObserver() {\n    if (CompatibilityHelper.isResizeObserverAvailable() && this.resizeObserver !== null) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  unsubscribeOnMove() {\n    if (!ValueHelper.isNullOrUndefined(this.onMoveEventListener)) {\n      this.eventListenerHelper.detachEventListener(this.onMoveEventListener);\n      this.onMoveEventListener = null;\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  unsubscribeOnEnd() {\n    if (!ValueHelper.isNullOrUndefined(this.onEndEventListener)) {\n      this.eventListenerHelper.detachEventListener(this.onEndEventListener);\n      this.onEndEventListener = null;\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  unsubscribeInputModelChangeSubject() {\n    if (!ValueHelper.isNullOrUndefined(this.inputModelChangeSubscription)) {\n      this.inputModelChangeSubscription.unsubscribe();\n      this.inputModelChangeSubscription = null;\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  unsubscribeOutputModelChangeSubject() {\n    if (!ValueHelper.isNullOrUndefined(this.outputModelChangeSubscription)) {\n      this.outputModelChangeSubscription.unsubscribe();\n      this.outputModelChangeSubscription = null;\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  unsubscribeManualRefresh() {\n    if (!ValueHelper.isNullOrUndefined(this.manualRefreshSubscription)) {\n      this.manualRefreshSubscription.unsubscribe();\n      this.manualRefreshSubscription = null;\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  unsubscribeTriggerFocus() {\n    if (!ValueHelper.isNullOrUndefined(this.triggerFocusSubscription)) {\n      this.triggerFocusSubscription.unsubscribe();\n      this.triggerFocusSubscription = null;\n    }\n  }\n  /**\n   * @param {?} pointerType\n   * @return {?}\n   */\n\n\n  getPointerElement(pointerType) {\n    if (pointerType === PointerType.Min) {\n      return this.minHandleElement;\n    } else if (pointerType === PointerType.Max) {\n      return this.maxHandleElement;\n    }\n\n    return null;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getCurrentTrackingValue() {\n    if (this.currentTrackingPointer === PointerType.Min) {\n      return this.viewLowValue;\n    } else if (this.currentTrackingPointer === PointerType.Max) {\n      return this.viewHighValue;\n    }\n\n    return null;\n  }\n  /**\n   * @param {?} modelValue\n   * @return {?}\n   */\n\n\n  modelValueToViewValue(modelValue) {\n    if (ValueHelper.isNullOrUndefined(modelValue)) {\n      return NaN;\n    }\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n      return ValueHelper.findStepIndex(+modelValue, this.viewOptions.stepsArray);\n    }\n\n    return +modelValue;\n  }\n  /**\n   * @param {?} viewValue\n   * @return {?}\n   */\n\n\n  viewValueToModelValue(viewValue) {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n      return this.getStepValue(viewValue);\n    }\n\n    return viewValue;\n  }\n  /**\n   * @param {?} sliderValue\n   * @return {?}\n   */\n\n\n  getStepValue(sliderValue) {\n    /** @type {?} */\n    const step = this.viewOptions.stepsArray[sliderValue];\n    return !ValueHelper.isNullOrUndefined(step) ? step.value : NaN;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  applyViewChange() {\n    this.value = this.viewValueToModelValue(this.viewLowValue);\n\n    if (this.range) {\n      this.highValue = this.viewValueToModelValue(this.viewHighValue);\n    }\n\n    this.outputModelChangeSubject.next({\n      value: this.value,\n      highValue: this.highValue,\n      userEventInitiated: true,\n      forceChange: false\n    }); // At this point all changes are applied and outputs are emitted, so we should be done.\n    // However, input changes are communicated in different stream and we need to be ready to\n    // act on the next input change even if it is exactly the same as last input change.\n    // Therefore, we send a special event to reset the stream.\n\n    this.inputModelChangeSubject.next({\n      value: this.value,\n      highValue: this.highValue,\n      forceChange: false,\n      internalChange: true\n    });\n  }\n  /**\n   * @param {?} modelChange\n   * @return {?}\n   */\n\n\n  applyInputModelChange(modelChange) {\n    /** @type {?} */\n    const normalisedModelChange = this.normaliseModelValues(modelChange);\n    /** @type {?} */\n\n    const normalisationChange = !ModelValues.compare(modelChange, normalisedModelChange);\n\n    if (normalisationChange) {\n      this.value = normalisedModelChange.value;\n      this.highValue = normalisedModelChange.highValue;\n    }\n\n    this.viewLowValue = this.modelValueToViewValue(normalisedModelChange.value);\n\n    if (this.range) {\n      this.viewHighValue = this.modelValueToViewValue(normalisedModelChange.highValue);\n    } else {\n      this.viewHighValue = null;\n    }\n\n    this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n\n    if (this.range) {\n      this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n    }\n\n    this.updateSelectionBar();\n    this.updateTicksScale();\n    this.updateAriaAttributes();\n\n    if (this.range) {\n      this.updateCombinedLabel();\n    } // At the end, we need to communicate the model change to the outputs as well\n    // Normalisation changes are also always forced out to ensure that subscribers always end up in correct state\n\n\n    this.outputModelChangeSubject.next({\n      value: normalisedModelChange.value,\n      highValue: normalisedModelChange.highValue,\n      forceChange: normalisationChange,\n      userEventInitiated: false\n    });\n  }\n  /**\n   * @param {?} modelChange\n   * @return {?}\n   */\n\n\n  publishOutputModelChange(modelChange) {\n    /** @type {?} */\n    const emitOutputs = () => {\n      this.valueChange.emit(modelChange.value);\n\n      if (this.range) {\n        this.highValueChange.emit(modelChange.highValue);\n      }\n\n      if (!ValueHelper.isNullOrUndefined(this.onChangeCallback)) {\n        if (this.range) {\n          this.onChangeCallback([modelChange.value, modelChange.highValue]);\n        } else {\n          this.onChangeCallback(modelChange.value);\n        }\n      }\n\n      if (!ValueHelper.isNullOrUndefined(this.onTouchedCallback)) {\n        if (this.range) {\n          this.onTouchedCallback([modelChange.value, modelChange.highValue]);\n        } else {\n          this.onTouchedCallback(modelChange.value);\n        }\n      }\n    };\n\n    if (modelChange.userEventInitiated) {\n      // If this change was initiated by a user event, we can emit outputs in the same tick\n      emitOutputs();\n      this.userChange.emit(this.getChangeContext());\n    } else {\n      // But, if the change was initated by something else like a change in input bindings,\n      // we need to wait until next tick to emit the outputs to keep Angular change detection happy\n      setTimeout(() => {\n        emitOutputs();\n      });\n    }\n  }\n  /**\n   * @param {?} input\n   * @return {?}\n   */\n\n\n  normaliseModelValues(input) {\n    /** @type {?} */\n    const normalisedInput = new ModelValues();\n    normalisedInput.value = input.value;\n    normalisedInput.highValue = input.highValue;\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {\n      // When using steps array, only round to nearest step in the array\n      // No other enforcement can be done, as the step array may be out of order, and that is perfectly fine\n      if (this.viewOptions.enforceStepsArray) {\n        /** @type {?} */\n        const valueIndex = ValueHelper.findStepIndex(normalisedInput.value, this.viewOptions.stepsArray);\n        normalisedInput.value = this.viewOptions.stepsArray[valueIndex].value;\n\n        if (this.range) {\n          /** @type {?} */\n          const highValueIndex = ValueHelper.findStepIndex(normalisedInput.highValue, this.viewOptions.stepsArray);\n          normalisedInput.highValue = this.viewOptions.stepsArray[highValueIndex].value;\n        }\n      }\n\n      return normalisedInput;\n    }\n\n    if (this.viewOptions.enforceStep) {\n      normalisedInput.value = this.roundStep(normalisedInput.value);\n\n      if (this.range) {\n        normalisedInput.highValue = this.roundStep(normalisedInput.highValue);\n      }\n    }\n\n    if (this.viewOptions.enforceRange) {\n      normalisedInput.value = MathHelper.clampToRange(normalisedInput.value, this.viewOptions.floor, this.viewOptions.ceil);\n\n      if (this.range) {\n        normalisedInput.highValue = MathHelper.clampToRange(normalisedInput.highValue, this.viewOptions.floor, this.viewOptions.ceil);\n      } // Make sure that range slider invariant (value <= highValue) is always satisfied\n\n\n      if (this.range && input.value > input.highValue) {\n        // We know that both values are now clamped correctly, they may just be in the wrong order\n        // So the easy solution is to swap them... except swapping is sometimes disabled in options, so we make the two values the same\n        if (this.viewOptions.noSwitching) {\n          normalisedInput.value = normalisedInput.highValue;\n        } else {\n          /** @type {?} */\n          const tempValue = input.value;\n          normalisedInput.value = input.highValue;\n          normalisedInput.highValue = tempValue;\n        }\n      }\n    }\n\n    return normalisedInput;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  renormaliseModelValues() {\n    /** @type {?} */\n    const previousModelValues = {\n      value: this.value,\n      highValue: this.highValue\n    };\n    /** @type {?} */\n\n    const normalisedModelValues = this.normaliseModelValues(previousModelValues);\n\n    if (!ModelValues.compare(normalisedModelValues, previousModelValues)) {\n      this.value = normalisedModelValues.value;\n      this.highValue = normalisedModelValues.highValue;\n      this.outputModelChangeSubject.next({\n        value: this.value,\n        highValue: this.highValue,\n        forceChange: true,\n        userEventInitiated: false\n      });\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  onChangeOptions() {\n    if (!this.initHasRun) {\n      return;\n    }\n    /** @type {?} */\n\n\n    const previousOptionsInfluencingEventBindings = this.getOptionsInfluencingEventBindings(this.viewOptions);\n    this.applyOptions();\n    /** @type {?} */\n\n    const newOptionsInfluencingEventBindings = this.getOptionsInfluencingEventBindings(this.viewOptions);\n    /** @type {?} */\n\n    const rebindEvents = !ValueHelper.areArraysEqual(previousOptionsInfluencingEventBindings, newOptionsInfluencingEventBindings); // With new options, we need to re-normalise model values if necessary\n\n    this.renormaliseModelValues();\n    this.viewLowValue = this.modelValueToViewValue(this.value);\n\n    if (this.range) {\n      this.viewHighValue = this.modelValueToViewValue(this.highValue);\n    } else {\n      this.viewHighValue = null;\n    }\n\n    this.resetSlider(rebindEvents);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  applyOptions() {\n    this.viewOptions = new Options();\n    Object.assign(this.viewOptions, this.options);\n    this.viewOptions.draggableRange = this.range && this.viewOptions.draggableRange;\n    this.viewOptions.draggableRangeOnly = this.range && this.viewOptions.draggableRangeOnly;\n\n    if (this.viewOptions.draggableRangeOnly) {\n      this.viewOptions.draggableRange = true;\n    }\n\n    this.viewOptions.showTicks = this.viewOptions.showTicks || this.viewOptions.showTicksValues || !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray);\n\n    if (this.viewOptions.showTicks && (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) || !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray))) {\n      this.intermediateTicks = true;\n    }\n\n    this.viewOptions.showSelectionBar = this.viewOptions.showSelectionBar || this.viewOptions.showSelectionBarEnd || !ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue);\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {\n      this.applyStepsArrayOptions();\n    } else {\n      this.applyFloorCeilOptions();\n    }\n\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.combineLabels)) {\n      this.viewOptions.combineLabels = (minValue, maxValue) => {\n        return minValue + ' - ' + maxValue;\n      };\n    }\n\n    if (this.viewOptions.logScale && this.viewOptions.floor === 0) {\n      throw Error('Can\\'t use floor=0 with logarithmic scale');\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  applyStepsArrayOptions() {\n    this.viewOptions.floor = 0;\n    this.viewOptions.ceil = this.viewOptions.stepsArray.length - 1;\n    this.viewOptions.step = 1;\n\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n      this.viewOptions.translate = modelValue => {\n        if (this.viewOptions.bindIndexForStepsArray) {\n          return String(this.getStepValue(modelValue));\n        }\n\n        return String(modelValue);\n      };\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  applyFloorCeilOptions() {\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.step)) {\n      this.viewOptions.step = 1;\n    } else {\n      this.viewOptions.step = +this.viewOptions.step;\n\n      if (this.viewOptions.step <= 0) {\n        this.viewOptions.step = 1;\n      }\n    }\n\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.ceil) || ValueHelper.isNullOrUndefined(this.viewOptions.floor)) {\n      throw Error('floor and ceil options must be supplied');\n    }\n\n    this.viewOptions.ceil = +this.viewOptions.ceil;\n    this.viewOptions.floor = +this.viewOptions.floor;\n\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n      this.viewOptions.translate = value => String(value);\n    }\n  }\n  /**\n   * @param {?=} rebindEvents\n   * @return {?}\n   */\n\n\n  resetSlider(rebindEvents = true) {\n    this.manageElementsStyle();\n    this.addAccessibility();\n    this.updateCeilLabel();\n    this.updateFloorLabel();\n\n    if (rebindEvents) {\n      this.unbindEvents();\n      this.manageEventsBindings();\n    }\n\n    this.updateDisabledState();\n    this.updateAriaLabel();\n    this.calculateViewDimensions();\n    this.refocusPointerIfNeeded();\n  }\n  /**\n   * @param {?} pointerType\n   * @return {?}\n   */\n\n\n  focusPointer(pointerType) {\n    // If not supplied, use min pointer as default\n    if (pointerType !== PointerType.Min && pointerType !== PointerType.Max) {\n      pointerType = PointerType.Min;\n    }\n\n    if (pointerType === PointerType.Min) {\n      this.minHandleElement.focus();\n    } else if (this.range && pointerType === PointerType.Max) {\n      this.maxHandleElement.focus();\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  refocusPointerIfNeeded() {\n    if (!ValueHelper.isNullOrUndefined(this.currentFocusPointer)) {\n      this.onPointerFocus(this.currentFocusPointer);\n      /** @type {?} */\n\n      const element = this.getPointerElement(this.currentFocusPointer);\n      element.focus();\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  manageElementsStyle() {\n    this.updateScale();\n    this.floorLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n    this.ceilLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n    /** @type {?} */\n\n    const hideLabelsForTicks = this.viewOptions.showTicksValues && !this.intermediateTicks;\n    this.minHandleLabelElement.setAlwaysHide(hideLabelsForTicks || this.viewOptions.hidePointerLabels);\n    this.maxHandleLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n    this.combinedLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n    this.selectionBarElement.setAlwaysHide(!this.range && !this.viewOptions.showSelectionBar);\n    this.leftOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n    this.rightOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n    this.fullBarTransparentClass = this.range && this.viewOptions.showOuterSelectionBars;\n    this.selectionBarDraggableClass = this.viewOptions.draggableRange && !this.viewOptions.onlyBindHandles;\n    this.ticksUnderValuesClass = this.intermediateTicks && this.options.showTicksValues;\n\n    if (this.sliderElementVerticalClass !== this.viewOptions.vertical) {\n      this.updateVerticalState(); // The above change in host component class will not be applied until the end of this cycle\n      // However, functions calculating the slider position expect the slider to be already styled as vertical\n      // So as a workaround, we need to reset the slider once again to compute the correct values\n\n      setTimeout(() => {\n        this.resetSlider();\n      });\n    } // Changing animate class may interfere with slider reset/initialisation, so we should set it separately,\n    // after all is properly set up\n\n\n    if (this.sliderElementAnimateClass !== this.viewOptions.animate) {\n      setTimeout(() => {\n        this.sliderElementAnimateClass = this.viewOptions.animate;\n      });\n    }\n\n    this.updateRotate();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  manageEventsBindings() {\n    if (this.viewOptions.disabled || this.viewOptions.readOnly) {\n      this.unbindEvents();\n    } else {\n      this.bindEvents();\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  updateDisabledState() {\n    this.sliderElementDisabledAttr = this.viewOptions.disabled ? 'disabled' : null;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  updateAriaLabel() {\n    this.sliderElementAriaLabel = this.viewOptions.ariaLabel || 'nxg-slider';\n  }\n  /**\n   * @return {?}\n   */\n\n\n  updateVerticalState() {\n    this.sliderElementVerticalClass = this.viewOptions.vertical;\n\n    for (const element of this.getAllSliderElements()) {\n      // This is also called before ngAfterInit, so need to check that view child bindings work\n      if (!ValueHelper.isNullOrUndefined(element)) {\n        element.setVertical(this.viewOptions.vertical);\n      }\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  updateScale() {\n    for (const element of this.getAllSliderElements()) {\n      element.setScale(this.viewOptions.scale);\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  updateRotate() {\n    for (const element of this.getAllSliderElements()) {\n      element.setRotate(this.viewOptions.rotate);\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getAllSliderElements() {\n    return [this.leftOuterSelectionBarElement, this.rightOuterSelectionBarElement, this.fullBarElement, this.selectionBarElement, this.minHandleElement, this.maxHandleElement, this.floorLabelElement, this.ceilLabelElement, this.minHandleLabelElement, this.maxHandleLabelElement, this.combinedLabelElement, this.ticksElement];\n  }\n  /**\n   * @return {?}\n   */\n\n\n  initHandles() {\n    this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n    /*\n       the order here is important since the selection bar should be\n       updated after the high handle but before the combined label\n       */\n\n    if (this.range) {\n      this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n    }\n\n    this.updateSelectionBar();\n\n    if (this.range) {\n      this.updateCombinedLabel();\n    }\n\n    this.updateTicksScale();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  addAccessibility() {\n    this.updateAriaAttributes();\n    this.minHandleElement.role = 'slider';\n\n    if (this.viewOptions.keyboardSupport && !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n      this.minHandleElement.tabindex = '0';\n    } else {\n      this.minHandleElement.tabindex = '';\n    }\n\n    this.minHandleElement.ariaOrientation = this.viewOptions.vertical || this.viewOptions.rotate !== 0 ? 'vertical' : 'horizontal';\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabel)) {\n      this.minHandleElement.ariaLabel = this.viewOptions.ariaLabel;\n    } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledBy)) {\n      this.minHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledBy;\n    }\n\n    if (this.range) {\n      this.maxHandleElement.role = 'slider';\n\n      if (this.viewOptions.keyboardSupport && !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n        this.maxHandleElement.tabindex = '0';\n      } else {\n        this.maxHandleElement.tabindex = '';\n      }\n\n      this.maxHandleElement.ariaOrientation = this.viewOptions.vertical || this.viewOptions.rotate !== 0 ? 'vertical' : 'horizontal';\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelHigh)) {\n        this.maxHandleElement.ariaLabel = this.viewOptions.ariaLabelHigh;\n      } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledByHigh)) {\n        this.maxHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledByHigh;\n      }\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  updateAriaAttributes() {\n    this.minHandleElement.ariaValueNow = (+this.value).toString();\n    this.minHandleElement.ariaValueText = this.viewOptions.translate(+this.value, LabelType.Low);\n    this.minHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n    this.minHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n\n    if (this.range) {\n      this.maxHandleElement.ariaValueNow = (+this.highValue).toString();\n      this.maxHandleElement.ariaValueText = this.viewOptions.translate(+this.highValue, LabelType.High);\n      this.maxHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n      this.maxHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  calculateViewDimensions() {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.handleDimension)) {\n      this.minHandleElement.setDimension(this.viewOptions.handleDimension);\n    } else {\n      this.minHandleElement.calculateDimension();\n    }\n    /** @type {?} */\n\n\n    const handleWidth = this.minHandleElement.dimension;\n    this.handleHalfDimension = handleWidth / 2;\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.barDimension)) {\n      this.fullBarElement.setDimension(this.viewOptions.barDimension);\n    } else {\n      this.fullBarElement.calculateDimension();\n    }\n\n    this.maxHandlePosition = this.fullBarElement.dimension - handleWidth;\n\n    if (this.initHasRun) {\n      this.updateFloorLabel();\n      this.updateCeilLabel();\n      this.initHandles();\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  calculateViewDimensionsAndDetectChanges() {\n    this.calculateViewDimensions();\n\n    if (!this.isRefDestroyed()) {\n      this.changeDetectionRef.detectChanges();\n    }\n  }\n  /**\n   * If the slider reference is already destroyed\n   * @return {?} boolean - true if ref is destroyed\n   */\n\n\n  isRefDestroyed() {\n    return this.changeDetectionRef['destroyed'];\n  }\n  /**\n   * @return {?}\n   */\n\n\n  updateTicksScale() {\n    if (!this.viewOptions.showTicks) {\n      setTimeout(() => {\n        this.sliderElementWithLegendClass = false;\n      });\n      return;\n    }\n    /** @type {?} */\n\n\n    const ticksArray = !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray) ? this.viewOptions.ticksArray : this.getTicksArray();\n    /** @type {?} */\n\n    const translate = this.viewOptions.vertical ? 'translateY' : 'translateX';\n\n    if (this.viewOptions.rightToLeft) {\n      ticksArray.reverse();\n    }\n    /** @type {?} */\n\n\n    const tickValueStep = !ValueHelper.isNullOrUndefined(this.viewOptions.tickValueStep) ? this.viewOptions.tickValueStep : !ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) ? this.viewOptions.tickStep : this.viewOptions.step;\n    /** @type {?} */\n\n    let hasAtLeastOneLegend = false;\n    /** @type {?} */\n\n    const newTicks = ticksArray.map(value => {\n      /** @type {?} */\n      let position = this.valueToPosition(value);\n\n      if (this.viewOptions.vertical) {\n        position = this.maxHandlePosition - position;\n      }\n      /** @type {?} */\n\n\n      const translation = translate + '(' + Math.round(position) + 'px)';\n      /** @type {?} */\n\n      const tick = new Tick();\n      tick.selected = this.isTickSelected(value);\n      tick.style = {\n        '-webkit-transform': translation,\n        '-moz-transform': translation,\n        '-o-transform': translation,\n        '-ms-transform': translation,\n        transform: translation\n      };\n\n      if (tick.selected && !ValueHelper.isNullOrUndefined(this.viewOptions.getSelectionBarColor)) {\n        tick.style['background-color'] = this.getSelectionBarColor();\n      }\n\n      if (!tick.selected && !ValueHelper.isNullOrUndefined(this.viewOptions.getTickColor)) {\n        tick.style['background-color'] = this.getTickColor(value);\n      }\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.ticksTooltip)) {\n        tick.tooltip = this.viewOptions.ticksTooltip(value);\n        tick.tooltipPlacement = this.viewOptions.vertical ? 'right' : 'top';\n      }\n\n      if (this.viewOptions.showTicksValues && !ValueHelper.isNullOrUndefined(tickValueStep) && MathHelper.isModuloWithinPrecisionLimit(value, tickValueStep, this.viewOptions.precisionLimit)) {\n        tick.value = this.getDisplayValue(value, LabelType.TickValue);\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.ticksValuesTooltip)) {\n          tick.valueTooltip = this.viewOptions.ticksValuesTooltip(value);\n          tick.valueTooltipPlacement = this.viewOptions.vertical ? 'right' : 'top';\n        }\n      }\n      /** @type {?} */\n\n\n      let legend = null;\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {\n        /** @type {?} */\n        const step = this.viewOptions.stepsArray[value];\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.getStepLegend)) {\n          legend = this.viewOptions.getStepLegend(step);\n        } else if (!ValueHelper.isNullOrUndefined(step)) {\n          legend = step.legend;\n        }\n      } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.getLegend)) {\n        legend = this.viewOptions.getLegend(value);\n      }\n\n      if (!ValueHelper.isNullOrUndefined(legend)) {\n        tick.legend = legend;\n        hasAtLeastOneLegend = true;\n      }\n\n      return tick;\n    });\n    setTimeout(() => {\n      this.sliderElementWithLegendClass = hasAtLeastOneLegend;\n    }); // We should avoid re-creating the ticks array if possible\n    // This both improves performance and makes CSS animations work correctly\n\n    if (!ValueHelper.isNullOrUndefined(this.ticks) && this.ticks.length === newTicks.length) {\n      for (let i = 0; i < newTicks.length; ++i) {\n        Object.assign(this.ticks[i], newTicks[i]);\n      }\n    } else {\n      this.ticks = newTicks;\n    }\n\n    if (!this.isRefDestroyed()) {\n      this.changeDetectionRef.detectChanges();\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getTicksArray() {\n    /** @type {?} */\n    const step = !ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) ? this.viewOptions.tickStep : this.viewOptions.step;\n    /** @type {?} */\n\n    const ticksArray = [];\n    /** @type {?} */\n\n    const numberOfValues = 1 + Math.floor(MathHelper.roundToPrecisionLimit(Math.abs(this.viewOptions.ceil - this.viewOptions.floor) / step, this.viewOptions.precisionLimit));\n\n    for (let index = 0; index < numberOfValues; ++index) {\n      ticksArray.push(MathHelper.roundToPrecisionLimit(this.viewOptions.floor + step * index, this.viewOptions.precisionLimit));\n    }\n\n    return ticksArray;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  isTickSelected(value) {\n    if (!this.range) {\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n        /** @type {?} */\n        const center = this.viewOptions.showSelectionBarFromValue;\n\n        if (this.viewLowValue > center && value >= center && value <= this.viewLowValue) {\n          return true;\n        } else if (this.viewLowValue < center && value <= center && value >= this.viewLowValue) {\n          return true;\n        }\n      } else if (this.viewOptions.showSelectionBarEnd) {\n        if (value >= this.viewLowValue) {\n          return true;\n        }\n      } else if (this.viewOptions.showSelectionBar && value <= this.viewLowValue) {\n        return true;\n      }\n    }\n\n    if (this.range && value >= this.viewLowValue && value <= this.viewHighValue) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  updateFloorLabel() {\n    if (!this.floorLabelElement.alwaysHide) {\n      this.floorLabelElement.setValue(this.getDisplayValue(this.viewOptions.floor, LabelType.Floor));\n      this.floorLabelElement.calculateDimension();\n      /** @type {?} */\n\n      const position = this.viewOptions.rightToLeft ? this.fullBarElement.dimension - this.floorLabelElement.dimension : 0;\n      this.floorLabelElement.setPosition(position);\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  updateCeilLabel() {\n    if (!this.ceilLabelElement.alwaysHide) {\n      this.ceilLabelElement.setValue(this.getDisplayValue(this.viewOptions.ceil, LabelType.Ceil));\n      this.ceilLabelElement.calculateDimension();\n      /** @type {?} */\n\n      const position = this.viewOptions.rightToLeft ? 0 : this.fullBarElement.dimension - this.ceilLabelElement.dimension;\n      this.ceilLabelElement.setPosition(position);\n    }\n  }\n  /**\n   * @param {?} which\n   * @param {?} newPos\n   * @return {?}\n   */\n\n\n  updateHandles(which, newPos) {\n    if (which === PointerType.Min) {\n      this.updateLowHandle(newPos);\n    } else if (which === PointerType.Max) {\n      this.updateHighHandle(newPos);\n    }\n\n    this.updateSelectionBar();\n    this.updateTicksScale();\n\n    if (this.range) {\n      this.updateCombinedLabel();\n    }\n  }\n  /**\n   * @param {?} labelType\n   * @param {?} newPos\n   * @return {?}\n   */\n\n\n  getHandleLabelPos(labelType, newPos) {\n    /** @type {?} */\n    const labelDimension = labelType === PointerType.Min ? this.minHandleLabelElement.dimension : this.maxHandleLabelElement.dimension;\n    /** @type {?} */\n\n    const nearHandlePos = newPos - labelDimension / 2 + this.handleHalfDimension;\n    /** @type {?} */\n\n    const endOfBarPos = this.fullBarElement.dimension - labelDimension;\n\n    if (!this.viewOptions.boundPointerLabels) {\n      return nearHandlePos;\n    }\n\n    if (this.viewOptions.rightToLeft && labelType === PointerType.Min || !this.viewOptions.rightToLeft && labelType === PointerType.Max) {\n      return Math.min(nearHandlePos, endOfBarPos);\n    } else {\n      return Math.min(Math.max(nearHandlePos, 0), endOfBarPos);\n    }\n  }\n  /**\n   * @param {?} newPos\n   * @return {?}\n   */\n\n\n  updateLowHandle(newPos) {\n    this.minHandleElement.setPosition(newPos);\n    this.minHandleLabelElement.setValue(this.getDisplayValue(this.viewLowValue, LabelType.Low));\n    this.minHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Min, newPos));\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n      this.minPointerStyle = {\n        backgroundColor: this.getPointerColor(PointerType.Min)\n      };\n    }\n\n    if (this.viewOptions.autoHideLimitLabels) {\n      this.updateFloorAndCeilLabelsVisibility();\n    }\n  }\n  /**\n   * @param {?} newPos\n   * @return {?}\n   */\n\n\n  updateHighHandle(newPos) {\n    this.maxHandleElement.setPosition(newPos);\n    this.maxHandleLabelElement.setValue(this.getDisplayValue(this.viewHighValue, LabelType.High));\n    this.maxHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Max, newPos));\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n      this.maxPointerStyle = {\n        backgroundColor: this.getPointerColor(PointerType.Max)\n      };\n    }\n\n    if (this.viewOptions.autoHideLimitLabels) {\n      this.updateFloorAndCeilLabelsVisibility();\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  updateFloorAndCeilLabelsVisibility() {\n    // Show based only on hideLimitLabels if pointer labels are hidden\n    if (this.viewOptions.hidePointerLabels) {\n      return;\n    }\n    /** @type {?} */\n\n\n    let floorLabelHidden = false;\n    /** @type {?} */\n\n    let ceilLabelHidden = false;\n    /** @type {?} */\n\n    const isMinLabelAtFloor = this.isLabelBelowFloorLabel(this.minHandleLabelElement);\n    /** @type {?} */\n\n    const isMinLabelAtCeil = this.isLabelAboveCeilLabel(this.minHandleLabelElement);\n    /** @type {?} */\n\n    const isMaxLabelAtCeil = this.isLabelAboveCeilLabel(this.maxHandleLabelElement);\n    /** @type {?} */\n\n    const isCombinedLabelAtFloor = this.isLabelBelowFloorLabel(this.combinedLabelElement);\n    /** @type {?} */\n\n    const isCombinedLabelAtCeil = this.isLabelAboveCeilLabel(this.combinedLabelElement);\n\n    if (isMinLabelAtFloor) {\n      floorLabelHidden = true;\n      this.floorLabelElement.hide();\n    } else {\n      floorLabelHidden = false;\n      this.floorLabelElement.show();\n    }\n\n    if (isMinLabelAtCeil) {\n      ceilLabelHidden = true;\n      this.ceilLabelElement.hide();\n    } else {\n      ceilLabelHidden = false;\n      this.ceilLabelElement.show();\n    }\n\n    if (this.range) {\n      /** @type {?} */\n      const hideCeil = this.combinedLabelElement.isVisible() ? isCombinedLabelAtCeil : isMaxLabelAtCeil;\n      /** @type {?} */\n\n      const hideFloor = this.combinedLabelElement.isVisible() ? isCombinedLabelAtFloor : isMinLabelAtFloor;\n\n      if (hideCeil) {\n        this.ceilLabelElement.hide();\n      } else if (!ceilLabelHidden) {\n        this.ceilLabelElement.show();\n      } // Hide or show floor label\n\n\n      if (hideFloor) {\n        this.floorLabelElement.hide();\n      } else if (!floorLabelHidden) {\n        this.floorLabelElement.show();\n      }\n    }\n  }\n  /**\n   * @param {?} label\n   * @return {?}\n   */\n\n\n  isLabelBelowFloorLabel(label) {\n    /** @type {?} */\n    const pos = label.position;\n    /** @type {?} */\n\n    const dim = label.dimension;\n    /** @type {?} */\n\n    const floorPos = this.floorLabelElement.position;\n    /** @type {?} */\n\n    const floorDim = this.floorLabelElement.dimension;\n    return this.viewOptions.rightToLeft ? pos + dim >= floorPos - 2 : pos <= floorPos + floorDim + 2;\n  }\n  /**\n   * @param {?} label\n   * @return {?}\n   */\n\n\n  isLabelAboveCeilLabel(label) {\n    /** @type {?} */\n    const pos = label.position;\n    /** @type {?} */\n\n    const dim = label.dimension;\n    /** @type {?} */\n\n    const ceilPos = this.ceilLabelElement.position;\n    /** @type {?} */\n\n    const ceilDim = this.ceilLabelElement.dimension;\n    return this.viewOptions.rightToLeft ? pos <= ceilPos + ceilDim + 2 : pos + dim >= ceilPos - 2;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  updateSelectionBar() {\n    /** @type {?} */\n    let position = 0;\n    /** @type {?} */\n\n    let dimension = 0;\n    /** @type {?} */\n\n    const isSelectionBarFromRight = this.viewOptions.rightToLeft ? !this.viewOptions.showSelectionBarEnd : this.viewOptions.showSelectionBarEnd;\n    /** @type {?} */\n\n    const positionForRange = this.viewOptions.rightToLeft ? this.maxHandleElement.position + this.handleHalfDimension : this.minHandleElement.position + this.handleHalfDimension;\n\n    if (this.range) {\n      dimension = Math.abs(this.maxHandleElement.position - this.minHandleElement.position);\n      position = positionForRange;\n    } else {\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n        /** @type {?} */\n        const center = this.viewOptions.showSelectionBarFromValue;\n        /** @type {?} */\n\n        const centerPosition = this.valueToPosition(center);\n        /** @type {?} */\n\n        const isModelGreaterThanCenter = this.viewOptions.rightToLeft ? this.viewLowValue <= center : this.viewLowValue > center;\n\n        if (isModelGreaterThanCenter) {\n          dimension = this.minHandleElement.position - centerPosition;\n          position = centerPosition + this.handleHalfDimension;\n        } else {\n          dimension = centerPosition - this.minHandleElement.position;\n          position = this.minHandleElement.position + this.handleHalfDimension;\n        }\n      } else if (isSelectionBarFromRight) {\n        dimension = Math.ceil(Math.abs(this.maxHandlePosition - this.minHandleElement.position) + this.handleHalfDimension);\n        position = Math.floor(this.minHandleElement.position + this.handleHalfDimension);\n      } else {\n        dimension = this.minHandleElement.position + this.handleHalfDimension;\n        position = 0;\n      }\n    }\n\n    this.selectionBarElement.setDimension(dimension);\n    this.selectionBarElement.setPosition(position);\n\n    if (this.range && this.viewOptions.showOuterSelectionBars) {\n      if (this.viewOptions.rightToLeft) {\n        this.rightOuterSelectionBarElement.setDimension(position);\n        this.rightOuterSelectionBarElement.setPosition(0);\n        this.fullBarElement.calculateDimension();\n        this.leftOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n        this.leftOuterSelectionBarElement.setPosition(position + dimension);\n      } else {\n        this.leftOuterSelectionBarElement.setDimension(position);\n        this.leftOuterSelectionBarElement.setPosition(0);\n        this.fullBarElement.calculateDimension();\n        this.rightOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n        this.rightOuterSelectionBarElement.setPosition(position + dimension);\n      }\n    }\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.getSelectionBarColor)) {\n      /** @type {?} */\n      const color = this.getSelectionBarColor();\n      this.barStyle = {\n        backgroundColor: color\n      };\n    } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.selectionBarGradient)) {\n      /** @type {?} */\n      const offset = !ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue) ? this.valueToPosition(this.viewOptions.showSelectionBarFromValue) : 0;\n      /** @type {?} */\n\n      const reversed = offset - position > 0 && !isSelectionBarFromRight || offset - position <= 0 && isSelectionBarFromRight;\n      /** @type {?} */\n\n      const direction = this.viewOptions.vertical ? reversed ? 'bottom' : 'top' : reversed ? 'left' : 'right';\n      this.barStyle = {\n        backgroundImage: 'linear-gradient(to ' + direction + ', ' + this.viewOptions.selectionBarGradient.from + ' 0%,' + this.viewOptions.selectionBarGradient.to + ' 100%)'\n      };\n\n      if (this.viewOptions.vertical) {\n        this.barStyle.backgroundPosition = 'center ' + (offset + dimension + position + (reversed ? -this.handleHalfDimension : 0)) + 'px';\n        this.barStyle.backgroundSize = '100% ' + (this.fullBarElement.dimension - this.handleHalfDimension) + 'px';\n      } else {\n        this.barStyle.backgroundPosition = offset - position + (reversed ? this.handleHalfDimension : 0) + 'px center';\n        this.barStyle.backgroundSize = this.fullBarElement.dimension - this.handleHalfDimension + 'px 100%';\n      }\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getSelectionBarColor() {\n    if (this.range) {\n      return this.viewOptions.getSelectionBarColor(this.value, this.highValue);\n    }\n\n    return this.viewOptions.getSelectionBarColor(this.value);\n  }\n  /**\n   * @param {?} pointerType\n   * @return {?}\n   */\n\n\n  getPointerColor(pointerType) {\n    if (pointerType === PointerType.Max) {\n      return this.viewOptions.getPointerColor(this.highValue, pointerType);\n    }\n\n    return this.viewOptions.getPointerColor(this.value, pointerType);\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  getTickColor(value) {\n    return this.viewOptions.getTickColor(value);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  updateCombinedLabel() {\n    /** @type {?} */\n    let isLabelOverlap = null;\n\n    if (this.viewOptions.rightToLeft) {\n      isLabelOverlap = this.minHandleLabelElement.position - this.minHandleLabelElement.dimension - 10 <= this.maxHandleLabelElement.position;\n    } else {\n      isLabelOverlap = this.minHandleLabelElement.position + this.minHandleLabelElement.dimension + 10 >= this.maxHandleLabelElement.position;\n    }\n\n    if (isLabelOverlap) {\n      /** @type {?} */\n      const lowDisplayValue = this.getDisplayValue(this.viewLowValue, LabelType.Low);\n      /** @type {?} */\n\n      const highDisplayValue = this.getDisplayValue(this.viewHighValue, LabelType.High);\n      /** @type {?} */\n\n      const combinedLabelValue = this.viewOptions.rightToLeft ? this.viewOptions.combineLabels(highDisplayValue, lowDisplayValue) : this.viewOptions.combineLabels(lowDisplayValue, highDisplayValue);\n      this.combinedLabelElement.setValue(combinedLabelValue);\n      /** @type {?} */\n\n      const pos = this.viewOptions.boundPointerLabels ? Math.min(Math.max(this.selectionBarElement.position + this.selectionBarElement.dimension / 2 - this.combinedLabelElement.dimension / 2, 0), this.fullBarElement.dimension - this.combinedLabelElement.dimension) : this.selectionBarElement.position + this.selectionBarElement.dimension / 2 - this.combinedLabelElement.dimension / 2;\n      this.combinedLabelElement.setPosition(pos);\n      this.minHandleLabelElement.hide();\n      this.maxHandleLabelElement.hide();\n      this.combinedLabelElement.show();\n    } else {\n      this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n      this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n      this.maxHandleLabelElement.show();\n      this.minHandleLabelElement.show();\n      this.combinedLabelElement.hide();\n    }\n\n    if (this.viewOptions.autoHideLimitLabels) {\n      this.updateFloorAndCeilLabelsVisibility();\n    }\n  }\n  /**\n   * @param {?} value\n   * @param {?} which\n   * @return {?}\n   */\n\n\n  getDisplayValue(value, which) {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n      value = this.getStepValue(value);\n    }\n\n    return this.viewOptions.translate(value, which);\n  }\n  /**\n   * @param {?} value\n   * @param {?=} customStep\n   * @return {?}\n   */\n\n\n  roundStep(value, customStep) {\n    /** @type {?} */\n    const step = !ValueHelper.isNullOrUndefined(customStep) ? customStep : this.viewOptions.step;\n    /** @type {?} */\n\n    let steppedDifference = MathHelper.roundToPrecisionLimit((value - this.viewOptions.floor) / step, this.viewOptions.precisionLimit);\n    steppedDifference = Math.round(steppedDifference) * step;\n    return MathHelper.roundToPrecisionLimit(this.viewOptions.floor + steppedDifference, this.viewOptions.precisionLimit);\n  }\n  /**\n   * @param {?} val\n   * @return {?}\n   */\n\n\n  valueToPosition(val) {\n    /** @type {?} */\n    let fn = ValueHelper.linearValueToPosition;\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.customValueToPosition)) {\n      fn = this.viewOptions.customValueToPosition;\n    } else if (this.viewOptions.logScale) {\n      fn = ValueHelper.logValueToPosition;\n    }\n\n    val = MathHelper.clampToRange(val, this.viewOptions.floor, this.viewOptions.ceil);\n    /** @type {?} */\n\n    let percent = fn(val, this.viewOptions.floor, this.viewOptions.ceil);\n\n    if (ValueHelper.isNullOrUndefined(percent)) {\n      percent = 0;\n    }\n\n    if (this.viewOptions.rightToLeft) {\n      percent = 1 - percent;\n    }\n\n    return percent * this.maxHandlePosition;\n  }\n  /**\n   * @param {?} position\n   * @return {?}\n   */\n\n\n  positionToValue(position) {\n    /** @type {?} */\n    let percent = position / this.maxHandlePosition;\n\n    if (this.viewOptions.rightToLeft) {\n      percent = 1 - percent;\n    }\n    /** @type {?} */\n\n\n    let fn = ValueHelper.linearPositionToValue;\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.customPositionToValue)) {\n      fn = this.viewOptions.customPositionToValue;\n    } else if (this.viewOptions.logScale) {\n      fn = ValueHelper.logPositionToValue;\n    }\n    /** @type {?} */\n\n\n    const value = fn(percent, this.viewOptions.floor, this.viewOptions.ceil);\n    return !ValueHelper.isNullOrUndefined(value) ? value : 0;\n  }\n  /**\n   * @param {?} event\n   * @param {?=} targetTouchId\n   * @return {?}\n   */\n\n\n  getEventXY(event, targetTouchId) {\n    if (event instanceof MouseEvent) {\n      return this.viewOptions.vertical || this.viewOptions.rotate !== 0 ? event.clientY : event.clientX;\n    }\n    /** @type {?} */\n\n\n    let touchIndex = 0;\n    /** @type {?} */\n\n    const touches = event.touches;\n\n    if (!ValueHelper.isNullOrUndefined(targetTouchId)) {\n      for (let i = 0; i < touches.length; i++) {\n        if (touches[i].identifier === targetTouchId) {\n          touchIndex = i;\n          break;\n        }\n      }\n    } // Return the target touch or if the target touch was not found in the event\n    // returns the coordinates of the first touch\n\n\n    return this.viewOptions.vertical || this.viewOptions.rotate !== 0 ? touches[touchIndex].clientY : touches[touchIndex].clientX;\n  }\n  /**\n   * @param {?} event\n   * @param {?=} targetTouchId\n   * @return {?}\n   */\n\n\n  getEventPosition(event, targetTouchId) {\n    /** @type {?} */\n    const sliderElementBoundingRect = this.elementRef.nativeElement.getBoundingClientRect();\n    /** @type {?} */\n\n    const sliderPos = this.viewOptions.vertical || this.viewOptions.rotate !== 0 ? sliderElementBoundingRect.bottom : sliderElementBoundingRect.left;\n    /** @type {?} */\n\n    let eventPos = 0;\n\n    if (this.viewOptions.vertical || this.viewOptions.rotate !== 0) {\n      eventPos = -this.getEventXY(event, targetTouchId) + sliderPos;\n    } else {\n      eventPos = this.getEventXY(event, targetTouchId) - sliderPos;\n    }\n\n    return eventPos * this.viewOptions.scale - this.handleHalfDimension;\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  getNearestHandle(event) {\n    if (!this.range) {\n      return PointerType.Min;\n    }\n    /** @type {?} */\n\n\n    const position = this.getEventPosition(event);\n    /** @type {?} */\n\n    const distanceMin = Math.abs(position - this.minHandleElement.position);\n    /** @type {?} */\n\n    const distanceMax = Math.abs(position - this.maxHandleElement.position);\n\n    if (distanceMin < distanceMax) {\n      return PointerType.Min;\n    } else if (distanceMin > distanceMax) {\n      return PointerType.Max;\n    } else if (!this.viewOptions.rightToLeft) {\n      // if event is at the same distance from min/max then if it's at left of minH, we return minH else maxH\n      return position < this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n    } // reverse in rtl\n\n\n    return position > this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  bindEvents() {\n    /** @type {?} */\n    const draggableRange = this.viewOptions.draggableRange;\n\n    if (!this.viewOptions.onlyBindHandles) {\n      this.selectionBarElement.on('mousedown', event => this.onBarStart(null, draggableRange, event, true, true, true));\n    }\n\n    if (this.viewOptions.draggableRangeOnly) {\n      this.minHandleElement.on('mousedown', event => this.onBarStart(PointerType.Min, draggableRange, event, true, true));\n      this.maxHandleElement.on('mousedown', event => this.onBarStart(PointerType.Max, draggableRange, event, true, true));\n    } else {\n      this.minHandleElement.on('mousedown', event => this.onStart(PointerType.Min, event, true, true));\n\n      if (this.range) {\n        this.maxHandleElement.on('mousedown', event => this.onStart(PointerType.Max, event, true, true));\n      }\n\n      if (!this.viewOptions.onlyBindHandles) {\n        this.fullBarElement.on('mousedown', event => this.onStart(null, event, true, true, true));\n        this.ticksElement.on('mousedown', event => this.onStart(null, event, true, true, true, true));\n      }\n    }\n\n    if (!this.viewOptions.onlyBindHandles) {\n      this.selectionBarElement.onPassive('touchstart', event => this.onBarStart(null, draggableRange, event, true, true, true));\n    }\n\n    if (this.viewOptions.draggableRangeOnly) {\n      this.minHandleElement.onPassive('touchstart', event => this.onBarStart(PointerType.Min, draggableRange, event, true, true));\n      this.maxHandleElement.onPassive('touchstart', event => this.onBarStart(PointerType.Max, draggableRange, event, true, true));\n    } else {\n      this.minHandleElement.onPassive('touchstart', event => this.onStart(PointerType.Min, event, true, true));\n\n      if (this.range) {\n        this.maxHandleElement.onPassive('touchstart', event => this.onStart(PointerType.Max, event, true, true));\n      }\n\n      if (!this.viewOptions.onlyBindHandles) {\n        this.fullBarElement.onPassive('touchstart', event => this.onStart(null, event, true, true, true));\n        this.ticksElement.onPassive('touchstart', event => this.onStart(null, event, false, false, true, true));\n      }\n    }\n\n    if (this.viewOptions.keyboardSupport) {\n      this.minHandleElement.on('focus', () => this.onPointerFocus(PointerType.Min));\n\n      if (this.range) {\n        this.maxHandleElement.on('focus', () => this.onPointerFocus(PointerType.Max));\n      }\n    }\n  }\n  /**\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  getOptionsInfluencingEventBindings(options) {\n    return [options.disabled, options.readOnly, options.draggableRange, options.draggableRangeOnly, options.onlyBindHandles, options.keyboardSupport];\n  }\n  /**\n   * @return {?}\n   */\n\n\n  unbindEvents() {\n    this.unsubscribeOnMove();\n    this.unsubscribeOnEnd();\n\n    for (const element of this.getAllSliderElements()) {\n      if (!ValueHelper.isNullOrUndefined(element)) {\n        element.off();\n      }\n    }\n  }\n  /**\n   * @param {?} pointerType\n   * @param {?} draggableRange\n   * @param {?} event\n   * @param {?} bindMove\n   * @param {?} bindEnd\n   * @param {?=} simulateImmediateMove\n   * @param {?=} simulateImmediateEnd\n   * @return {?}\n   */\n\n\n  onBarStart(pointerType, draggableRange, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n    if (draggableRange) {\n      this.onDragStart(pointerType, event, bindMove, bindEnd);\n    } else {\n      this.onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);\n    }\n  }\n  /**\n   * @param {?} pointerType\n   * @param {?} event\n   * @param {?} bindMove\n   * @param {?} bindEnd\n   * @param {?=} simulateImmediateMove\n   * @param {?=} simulateImmediateEnd\n   * @return {?}\n   */\n\n\n  onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n    event.stopPropagation(); // Only call preventDefault() when handling non-passive events (passive events don't need it)\n\n    if (!CompatibilityHelper.isTouchEvent(event) && !supportsPassiveEvents) {\n      event.preventDefault();\n    }\n\n    this.moving = false; // We have to do this in case the HTML where the sliders are on\n    // have been animated into view.\n\n    this.calculateViewDimensions();\n\n    if (ValueHelper.isNullOrUndefined(pointerType)) {\n      pointerType = this.getNearestHandle(event);\n    }\n\n    this.currentTrackingPointer = pointerType;\n    /** @type {?} */\n\n    const pointerElement = this.getPointerElement(pointerType);\n    pointerElement.active = true;\n\n    if (this.viewOptions.keyboardSupport) {\n      pointerElement.focus();\n    }\n\n    if (bindMove) {\n      this.unsubscribeOnMove();\n      /** @type {?} */\n\n      const onMoveCallback = e => this.dragging.active ? this.onDragMove(e) : this.onMove(e);\n\n      if (CompatibilityHelper.isTouchEvent(event)) {\n        this.onMoveEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchmove', onMoveCallback);\n      } else {\n        this.onMoveEventListener = this.eventListenerHelper.attachEventListener(document, 'mousemove', onMoveCallback);\n      }\n    }\n\n    if (bindEnd) {\n      this.unsubscribeOnEnd();\n      /** @type {?} */\n\n      const onEndCallback = e => this.onEnd(e);\n\n      if (CompatibilityHelper.isTouchEvent(event)) {\n        this.onEndEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchend', onEndCallback);\n      } else {\n        this.onEndEventListener = this.eventListenerHelper.attachEventListener(document, 'mouseup', onEndCallback);\n      }\n    }\n\n    this.userChangeStart.emit(this.getChangeContext());\n\n    if (CompatibilityHelper.isTouchEvent(event) && !ValueHelper.isNullOrUndefined(\n    /** @type {?} */\n    event.changedTouches)) {\n      // Store the touch identifier\n      if (ValueHelper.isNullOrUndefined(this.touchId)) {\n        this.touchId =\n        /** @type {?} */\n        event.changedTouches[0].identifier;\n      }\n    } // Click events, either with mouse or touch gesture are weird. Sometimes they result in full\n    // start, move, end sequence, and sometimes, they don't - they only invoke mousedown\n    // As a workaround, we simulate the first move event and the end event if it's necessary\n\n\n    if (simulateImmediateMove) {\n      this.onMove(event, true);\n    }\n\n    if (simulateImmediateEnd) {\n      this.onEnd(event);\n    }\n  }\n  /**\n   * @param {?} event\n   * @param {?=} fromTick\n   * @return {?}\n   */\n\n\n  onMove(event, fromTick) {\n    /** @type {?} */\n    let touchForThisSlider = null;\n\n    if (CompatibilityHelper.isTouchEvent(event)) {\n      /** @type {?} */\n      const changedTouches =\n      /** @type {?} */\n      event.changedTouches;\n\n      for (let i = 0; i < changedTouches.length; i++) {\n        if (changedTouches[i].identifier === this.touchId) {\n          touchForThisSlider = changedTouches[i];\n          break;\n        }\n      }\n\n      if (ValueHelper.isNullOrUndefined(touchForThisSlider)) {\n        return;\n      }\n    }\n\n    if (this.viewOptions.animate && !this.viewOptions.animateOnMove) {\n      if (this.moving) {\n        this.sliderElementAnimateClass = false;\n      }\n    }\n\n    this.moving = true;\n    /** @type {?} */\n\n    const newPos = !ValueHelper.isNullOrUndefined(touchForThisSlider) ? this.getEventPosition(event, touchForThisSlider.identifier) : this.getEventPosition(event);\n    /** @type {?} */\n\n    let newValue;\n    /** @type {?} */\n\n    const ceilValue = this.viewOptions.rightToLeft ? this.viewOptions.floor : this.viewOptions.ceil;\n    /** @type {?} */\n\n    const floorValue = this.viewOptions.rightToLeft ? this.viewOptions.ceil : this.viewOptions.floor;\n\n    if (newPos <= 0) {\n      newValue = floorValue;\n    } else if (newPos >= this.maxHandlePosition) {\n      newValue = ceilValue;\n    } else {\n      newValue = this.positionToValue(newPos);\n\n      if (fromTick && !ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) {\n        newValue = this.roundStep(newValue, this.viewOptions.tickStep);\n      } else {\n        newValue = this.roundStep(newValue);\n      }\n    }\n\n    this.positionTrackingHandle(newValue);\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  onEnd(event) {\n    if (CompatibilityHelper.isTouchEvent(event)) {\n      /** @type {?} */\n      const changedTouches =\n      /** @type {?} */\n      event.changedTouches;\n\n      if (changedTouches[0].identifier !== this.touchId) {\n        return;\n      }\n    }\n\n    this.moving = false;\n\n    if (this.viewOptions.animate) {\n      this.sliderElementAnimateClass = true;\n    }\n\n    this.touchId = null;\n\n    if (!this.viewOptions.keyboardSupport) {\n      this.minHandleElement.active = false;\n      this.maxHandleElement.active = false;\n      this.currentTrackingPointer = null;\n    }\n\n    this.dragging.active = false;\n    this.unsubscribeOnMove();\n    this.unsubscribeOnEnd();\n    this.userChangeEnd.emit(this.getChangeContext());\n  }\n  /**\n   * @param {?} pointerType\n   * @return {?}\n   */\n\n\n  onPointerFocus(pointerType) {\n    /** @type {?} */\n    const pointerElement = this.getPointerElement(pointerType);\n    pointerElement.on('blur', () => this.onPointerBlur(pointerElement));\n    pointerElement.on('keydown', event => this.onKeyboardEvent(event));\n    pointerElement.on('keyup', () => this.onKeyUp());\n    pointerElement.active = true;\n    this.currentTrackingPointer = pointerType;\n    this.currentFocusPointer = pointerType;\n    this.firstKeyDown = true;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  onKeyUp() {\n    this.firstKeyDown = true;\n    this.userChangeEnd.emit(this.getChangeContext());\n  }\n  /**\n   * @param {?} pointer\n   * @return {?}\n   */\n\n\n  onPointerBlur(pointer) {\n    pointer.off('blur');\n    pointer.off('keydown');\n    pointer.off('keyup');\n    pointer.active = false;\n\n    if (ValueHelper.isNullOrUndefined(this.touchId)) {\n      this.currentTrackingPointer = null;\n      this.currentFocusPointer = null;\n    }\n  }\n  /**\n   * @param {?} currentValue\n   * @return {?}\n   */\n\n\n  getKeyActions(currentValue) {\n    /** @type {?} */\n    const valueRange = this.viewOptions.ceil - this.viewOptions.floor;\n    /** @type {?} */\n\n    let increaseStep = currentValue + this.viewOptions.step;\n    /** @type {?} */\n\n    let decreaseStep = currentValue - this.viewOptions.step;\n    /** @type {?} */\n\n    let increasePage = currentValue + valueRange / 10;\n    /** @type {?} */\n\n    let decreasePage = currentValue - valueRange / 10;\n\n    if (this.viewOptions.reversedControls) {\n      increaseStep = currentValue - this.viewOptions.step;\n      decreaseStep = currentValue + this.viewOptions.step;\n      increasePage = currentValue - valueRange / 10;\n      decreasePage = currentValue + valueRange / 10;\n    }\n    /** @type {?} */\n\n\n    const actions = {\n      UP: increaseStep,\n      DOWN: decreaseStep,\n      LEFT: decreaseStep,\n      RIGHT: increaseStep,\n      PAGEUP: increasePage,\n      PAGEDOWN: decreasePage,\n      HOME: this.viewOptions.reversedControls ? this.viewOptions.ceil : this.viewOptions.floor,\n      END: this.viewOptions.reversedControls ? this.viewOptions.floor : this.viewOptions.ceil\n    }; // right to left means swapping right and left arrows\n\n    if (this.viewOptions.rightToLeft) {\n      actions[\"LEFT\"] = increaseStep;\n      actions[\"RIGHT\"] = decreaseStep; // right to left and vertical means we also swap up and down\n\n      if (this.viewOptions.vertical || this.viewOptions.rotate !== 0) {\n        actions[\"UP\"] = decreaseStep;\n        actions[\"DOWN\"] = increaseStep;\n      }\n    }\n\n    return actions;\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  onKeyboardEvent(event) {\n    /** @type {?} */\n    const currentValue = this.getCurrentTrackingValue();\n    /** @type {?} */\n\n    const keyCode = !ValueHelper.isNullOrUndefined(event.keyCode) ? event.keyCode : event.which;\n    /** @type {?} */\n\n    const keys = {\n      38: 'UP',\n      40: 'DOWN',\n      37: 'LEFT',\n      39: 'RIGHT',\n      33: 'PAGEUP',\n      34: 'PAGEDOWN',\n      36: 'HOME',\n      35: 'END'\n    };\n    /** @type {?} */\n\n    const actions = this.getKeyActions(currentValue);\n    /** @type {?} */\n\n    const key = keys[keyCode];\n    /** @type {?} */\n\n    const action = actions[key];\n\n    if (ValueHelper.isNullOrUndefined(action) || ValueHelper.isNullOrUndefined(this.currentTrackingPointer)) {\n      return;\n    }\n\n    event.preventDefault();\n\n    if (this.firstKeyDown) {\n      this.firstKeyDown = false;\n      this.userChangeStart.emit(this.getChangeContext());\n    }\n    /** @type {?} */\n\n\n    const actionValue = MathHelper.clampToRange(action, this.viewOptions.floor, this.viewOptions.ceil);\n    /** @type {?} */\n\n    const newValue = this.roundStep(actionValue);\n\n    if (!this.viewOptions.draggableRangeOnly) {\n      this.positionTrackingHandle(newValue);\n    } else {\n      /** @type {?} */\n      const difference = this.viewHighValue - this.viewLowValue;\n      /** @type {?} */\n\n      let newMinValue;\n      /** @type {?} */\n\n      let newMaxValue;\n\n      if (this.currentTrackingPointer === PointerType.Min) {\n        newMinValue = newValue;\n        newMaxValue = newValue + difference;\n\n        if (newMaxValue > this.viewOptions.ceil) {\n          newMaxValue = this.viewOptions.ceil;\n          newMinValue = newMaxValue - difference;\n        }\n      } else if (this.currentTrackingPointer === PointerType.Max) {\n        newMaxValue = newValue;\n        newMinValue = newValue - difference;\n\n        if (newMinValue < this.viewOptions.floor) {\n          newMinValue = this.viewOptions.floor;\n          newMaxValue = newMinValue + difference;\n        }\n      }\n\n      this.positionTrackingBar(newMinValue, newMaxValue);\n    }\n  }\n  /**\n   * @param {?} pointerType\n   * @param {?} event\n   * @param {?} bindMove\n   * @param {?} bindEnd\n   * @return {?}\n   */\n\n\n  onDragStart(pointerType, event, bindMove, bindEnd) {\n    /** @type {?} */\n    const position = this.getEventPosition(event);\n    this.dragging = new Dragging();\n    this.dragging.active = true;\n    this.dragging.value = this.positionToValue(position);\n    this.dragging.difference = this.viewHighValue - this.viewLowValue;\n    this.dragging.lowLimit = this.viewOptions.rightToLeft ? this.minHandleElement.position - position : position - this.minHandleElement.position;\n    this.dragging.highLimit = this.viewOptions.rightToLeft ? position - this.maxHandleElement.position : this.maxHandleElement.position - position;\n    this.onStart(pointerType, event, bindMove, bindEnd);\n  }\n  /**\n   * Get min value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft\n   * @param {?} newPos\n   * @param {?} outOfBounds\n   * @param {?} isAbove\n   * @return {?}\n   */\n\n\n  getMinValue(newPos, outOfBounds, isAbove) {\n    /** @type {?} */\n    const isRTL = this.viewOptions.rightToLeft;\n    /** @type {?} */\n\n    let value = null;\n\n    if (outOfBounds) {\n      if (isAbove) {\n        value = isRTL ? this.viewOptions.floor : this.viewOptions.ceil - this.dragging.difference;\n      } else {\n        value = isRTL ? this.viewOptions.ceil - this.dragging.difference : this.viewOptions.floor;\n      }\n    } else {\n      value = isRTL ? this.positionToValue(newPos + this.dragging.lowLimit) : this.positionToValue(newPos - this.dragging.lowLimit);\n    }\n\n    return this.roundStep(value);\n  }\n  /**\n   * Get max value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft\n   * @param {?} newPos\n   * @param {?} outOfBounds\n   * @param {?} isAbove\n   * @return {?}\n   */\n\n\n  getMaxValue(newPos, outOfBounds, isAbove) {\n    /** @type {?} */\n    const isRTL = this.viewOptions.rightToLeft;\n    /** @type {?} */\n\n    let value = null;\n\n    if (outOfBounds) {\n      if (isAbove) {\n        value = isRTL ? this.viewOptions.floor + this.dragging.difference : this.viewOptions.ceil;\n      } else {\n        value = isRTL ? this.viewOptions.ceil : this.viewOptions.floor + this.dragging.difference;\n      }\n    } else {\n      if (isRTL) {\n        value = this.positionToValue(newPos + this.dragging.lowLimit) + this.dragging.difference;\n      } else {\n        value = this.positionToValue(newPos - this.dragging.lowLimit) + this.dragging.difference;\n      }\n    }\n\n    return this.roundStep(value);\n  }\n  /**\n   * @param {?=} event\n   * @return {?}\n   */\n\n\n  onDragMove(event) {\n    /** @type {?} */\n    const newPos = this.getEventPosition(event);\n\n    if (this.viewOptions.animate && !this.viewOptions.animateOnMove) {\n      if (this.moving) {\n        this.sliderElementAnimateClass = false;\n      }\n    }\n\n    this.moving = true;\n    /** @type {?} */\n\n    let ceilLimit;\n    /** @type {?} */\n\n    let floorLimit;\n    /** @type {?} */\n\n    let floorHandleElement;\n    /** @type {?} */\n\n    let ceilHandleElement;\n\n    if (this.viewOptions.rightToLeft) {\n      ceilLimit = this.dragging.lowLimit;\n      floorLimit = this.dragging.highLimit;\n      floorHandleElement = this.maxHandleElement;\n      ceilHandleElement = this.minHandleElement;\n    } else {\n      ceilLimit = this.dragging.highLimit;\n      floorLimit = this.dragging.lowLimit;\n      floorHandleElement = this.minHandleElement;\n      ceilHandleElement = this.maxHandleElement;\n    }\n    /** @type {?} */\n\n\n    const isUnderFloorLimit = newPos <= floorLimit;\n    /** @type {?} */\n\n    const isOverCeilLimit = newPos >= this.maxHandlePosition - ceilLimit;\n    /** @type {?} */\n\n    let newMinValue;\n    /** @type {?} */\n\n    let newMaxValue;\n\n    if (isUnderFloorLimit) {\n      if (floorHandleElement.position === 0) {\n        return;\n      }\n\n      newMinValue = this.getMinValue(newPos, true, false);\n      newMaxValue = this.getMaxValue(newPos, true, false);\n    } else if (isOverCeilLimit) {\n      if (ceilHandleElement.position === this.maxHandlePosition) {\n        return;\n      }\n\n      newMaxValue = this.getMaxValue(newPos, true, true);\n      newMinValue = this.getMinValue(newPos, true, true);\n    } else {\n      newMinValue = this.getMinValue(newPos, false, false);\n      newMaxValue = this.getMaxValue(newPos, false, false);\n    }\n\n    this.positionTrackingBar(newMinValue, newMaxValue);\n  }\n  /**\n   * @param {?} newMinValue\n   * @param {?} newMaxValue\n   * @return {?}\n   */\n\n\n  positionTrackingBar(newMinValue, newMaxValue) {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) && newMinValue < this.viewOptions.minLimit) {\n      newMinValue = this.viewOptions.minLimit;\n      newMaxValue = MathHelper.roundToPrecisionLimit(newMinValue + this.dragging.difference, this.viewOptions.precisionLimit);\n    }\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) && newMaxValue > this.viewOptions.maxLimit) {\n      newMaxValue = this.viewOptions.maxLimit;\n      newMinValue = MathHelper.roundToPrecisionLimit(newMaxValue - this.dragging.difference, this.viewOptions.precisionLimit);\n    }\n\n    this.viewLowValue = newMinValue;\n    this.viewHighValue = newMaxValue;\n    this.applyViewChange();\n    this.updateHandles(PointerType.Min, this.valueToPosition(newMinValue));\n    this.updateHandles(PointerType.Max, this.valueToPosition(newMaxValue));\n  }\n  /**\n   * @param {?} newValue\n   * @return {?}\n   */\n\n\n  positionTrackingHandle(newValue) {\n    newValue = this.applyMinMaxLimit(newValue);\n\n    if (this.range) {\n      if (this.viewOptions.pushRange) {\n        newValue = this.applyPushRange(newValue);\n      } else {\n        if (this.viewOptions.noSwitching) {\n          if (this.currentTrackingPointer === PointerType.Min && newValue > this.viewHighValue) {\n            newValue = this.applyMinMaxRange(this.viewHighValue);\n          } else if (this.currentTrackingPointer === PointerType.Max && newValue < this.viewLowValue) {\n            newValue = this.applyMinMaxRange(this.viewLowValue);\n          }\n        }\n\n        newValue = this.applyMinMaxRange(newValue);\n        /* This is to check if we need to switch the min and max handles */\n\n        if (this.currentTrackingPointer === PointerType.Min && newValue > this.viewHighValue) {\n          this.viewLowValue = this.viewHighValue;\n          this.applyViewChange();\n          this.updateHandles(PointerType.Min, this.maxHandleElement.position);\n          this.updateAriaAttributes();\n          this.currentTrackingPointer = PointerType.Max;\n          this.minHandleElement.active = false;\n          this.maxHandleElement.active = true;\n\n          if (this.viewOptions.keyboardSupport) {\n            this.maxHandleElement.focus();\n          }\n        } else if (this.currentTrackingPointer === PointerType.Max && newValue < this.viewLowValue) {\n          this.viewHighValue = this.viewLowValue;\n          this.applyViewChange();\n          this.updateHandles(PointerType.Max, this.minHandleElement.position);\n          this.updateAriaAttributes();\n          this.currentTrackingPointer = PointerType.Min;\n          this.maxHandleElement.active = false;\n          this.minHandleElement.active = true;\n\n          if (this.viewOptions.keyboardSupport) {\n            this.minHandleElement.focus();\n          }\n        }\n      }\n    }\n\n    if (this.getCurrentTrackingValue() !== newValue) {\n      if (this.currentTrackingPointer === PointerType.Min) {\n        this.viewLowValue = newValue;\n        this.applyViewChange();\n      } else if (this.currentTrackingPointer === PointerType.Max) {\n        this.viewHighValue = newValue;\n        this.applyViewChange();\n      }\n\n      this.updateHandles(this.currentTrackingPointer, this.valueToPosition(newValue));\n      this.updateAriaAttributes();\n    }\n  }\n  /**\n   * @param {?} newValue\n   * @return {?}\n   */\n\n\n  applyMinMaxLimit(newValue) {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) && newValue < this.viewOptions.minLimit) {\n      return this.viewOptions.minLimit;\n    }\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) && newValue > this.viewOptions.maxLimit) {\n      return this.viewOptions.maxLimit;\n    }\n\n    return newValue;\n  }\n  /**\n   * @param {?} newValue\n   * @return {?}\n   */\n\n\n  applyMinMaxRange(newValue) {\n    /** @type {?} */\n    const oppositeValue = this.currentTrackingPointer === PointerType.Min ? this.viewHighValue : this.viewLowValue;\n    /** @type {?} */\n\n    const difference = Math.abs(newValue - oppositeValue);\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.minRange)) {\n      if (difference < this.viewOptions.minRange) {\n        if (this.currentTrackingPointer === PointerType.Min) {\n          return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.minRange, this.viewOptions.precisionLimit);\n        } else if (this.currentTrackingPointer === PointerType.Max) {\n          return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.minRange, this.viewOptions.precisionLimit);\n        }\n      }\n    }\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxRange)) {\n      if (difference > this.viewOptions.maxRange) {\n        if (this.currentTrackingPointer === PointerType.Min) {\n          return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n        } else if (this.currentTrackingPointer === PointerType.Max) {\n          return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n        }\n      }\n    }\n\n    return newValue;\n  }\n  /**\n   * @param {?} newValue\n   * @return {?}\n   */\n\n\n  applyPushRange(newValue) {\n    /** @type {?} */\n    const difference = this.currentTrackingPointer === PointerType.Min ? this.viewHighValue - newValue : newValue - this.viewLowValue;\n    /** @type {?} */\n\n    const minRange = !ValueHelper.isNullOrUndefined(this.viewOptions.minRange) ? this.viewOptions.minRange : this.viewOptions.step;\n    /** @type {?} */\n\n    const maxRange = this.viewOptions.maxRange; // if smaller than minRange\n\n    if (difference < minRange) {\n      if (this.currentTrackingPointer === PointerType.Min) {\n        this.viewHighValue = MathHelper.roundToPrecisionLimit(Math.min(newValue + minRange, this.viewOptions.ceil), this.viewOptions.precisionLimit);\n        newValue = MathHelper.roundToPrecisionLimit(this.viewHighValue - minRange, this.viewOptions.precisionLimit);\n        this.applyViewChange();\n        this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n      } else if (this.currentTrackingPointer === PointerType.Max) {\n        this.viewLowValue = MathHelper.roundToPrecisionLimit(Math.max(newValue - minRange, this.viewOptions.floor), this.viewOptions.precisionLimit);\n        newValue = MathHelper.roundToPrecisionLimit(this.viewLowValue + minRange, this.viewOptions.precisionLimit);\n        this.applyViewChange();\n        this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n      }\n\n      this.updateAriaAttributes();\n    } else if (!ValueHelper.isNullOrUndefined(maxRange) && difference > maxRange) {\n      // if greater than maxRange\n      if (this.currentTrackingPointer === PointerType.Min) {\n        this.viewHighValue = MathHelper.roundToPrecisionLimit(newValue + maxRange, this.viewOptions.precisionLimit);\n        this.applyViewChange();\n        this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n      } else if (this.currentTrackingPointer === PointerType.Max) {\n        this.viewLowValue = MathHelper.roundToPrecisionLimit(newValue - maxRange, this.viewOptions.precisionLimit);\n        this.applyViewChange();\n        this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n      }\n\n      this.updateAriaAttributes();\n    }\n\n    return newValue;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getChangeContext() {\n    /** @type {?} */\n    const changeContext = new ChangeContext();\n    changeContext.pointerType = this.currentTrackingPointer;\n    changeContext.value = +this.value;\n\n    if (this.range) {\n      changeContext.highValue = +this.highValue;\n    }\n\n    return changeContext;\n  }\n\n}\n\nSliderComponent.ɵfac = function SliderComponent_Factory(t) {\n  return new (t || SliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n};\n\nSliderComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: SliderComponent,\n  selectors: [[\"ngx-slider\"]],\n  contentQueries: function SliderComponent_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, _c0, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);\n    }\n  },\n  viewQuery: function SliderComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c1, 5, SliderElementDirective);\n      ɵngcc0.ɵɵviewQuery(_c2, 5, SliderElementDirective);\n      ɵngcc0.ɵɵviewQuery(_c3, 5, SliderElementDirective);\n      ɵngcc0.ɵɵviewQuery(_c4, 5, SliderElementDirective);\n      ɵngcc0.ɵɵviewQuery(_c5, 5, SliderHandleDirective);\n      ɵngcc0.ɵɵviewQuery(_c6, 5, SliderHandleDirective);\n      ɵngcc0.ɵɵviewQuery(_c7, 5, SliderLabelDirective);\n      ɵngcc0.ɵɵviewQuery(_c8, 5, SliderLabelDirective);\n      ɵngcc0.ɵɵviewQuery(_c9, 5, SliderLabelDirective);\n      ɵngcc0.ɵɵviewQuery(_c10, 5, SliderLabelDirective);\n      ɵngcc0.ɵɵviewQuery(_c11, 5, SliderLabelDirective);\n      ɵngcc0.ɵɵviewQuery(_c12, 5, SliderElementDirective);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.leftOuterSelectionBarElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rightOuterSelectionBarElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fullBarElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.selectionBarElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.minHandleElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.maxHandleElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.floorLabelElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ceilLabelElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.minHandleLabelElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.maxHandleLabelElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.combinedLabelElement = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);\n    }\n  },\n  hostAttrs: [1, \"ngx-slider\"],\n  hostVars: 8,\n  hostBindings: function SliderComponent_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"resize\", function SliderComponent_resize_HostBindingHandler($event) {\n        return ctx.onResize($event);\n      }, false, ɵngcc0.ɵɵresolveWindow);\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"disabled\", ctx.sliderElementDisabledAttr)(\"aria-label\", ctx.sliderElementAriaLabel);\n      ɵngcc0.ɵɵclassProp(\"vertical\", ctx.sliderElementVerticalClass)(\"animate\", ctx.sliderElementAnimateClass)(\"with-legend\", ctx.sliderElementWithLegendClass);\n    }\n  },\n  inputs: {\n    value: \"value\",\n    highValue: \"highValue\",\n    options: \"options\",\n    manualRefresh: \"manualRefresh\",\n    triggerFocus: \"triggerFocus\"\n  },\n  outputs: {\n    valueChange: \"valueChange\",\n    highValueChange: \"highValueChange\",\n    userChangeStart: \"userChangeStart\",\n    userChange: \"userChange\",\n    userChangeEnd: \"userChangeEnd\"\n  },\n  features: [ɵngcc0.ɵɵProvidersFeature([NGX_SLIDER_CONTROL_VALUE_ACCESSOR]), ɵngcc0.ɵɵNgOnChangesFeature],\n  decls: 29,\n  vars: 13,\n  consts: [[\"ngxSliderElement\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bar-wrapper\", \"ngx-slider-left-out-selection\"], [\"leftOuterSelectionBar\", \"\"], [1, \"ngx-slider-span\", \"ngx-slider-bar\"], [\"ngxSliderElement\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bar-wrapper\", \"ngx-slider-right-out-selection\"], [\"rightOuterSelectionBar\", \"\"], [\"ngxSliderElement\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bar-wrapper\", \"ngx-slider-full-bar\"], [\"fullBar\", \"\"], [\"ngxSliderElement\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bar-wrapper\", \"ngx-slider-selection-bar\"], [\"selectionBar\", \"\"], [1, \"ngx-slider-span\", \"ngx-slider-bar\", \"ngx-slider-selection\", 3, \"ngStyle\"], [\"ngxSliderHandle\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-pointer\", \"ngx-slider-pointer-min\", 3, \"ngStyle\"], [\"minHandle\", \"\"], [\"ngxSliderHandle\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-pointer\", \"ngx-slider-pointer-max\", 3, \"ngStyle\"], [\"maxHandle\", \"\"], [\"ngxSliderLabel\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bubble\", \"ngx-slider-limit\", \"ngx-slider-floor\"], [\"floorLabel\", \"\"], [\"ngxSliderLabel\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bubble\", \"ngx-slider-limit\", \"ngx-slider-ceil\"], [\"ceilLabel\", \"\"], [\"ngxSliderLabel\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bubble\", \"ngx-slider-model-value\"], [\"minHandleLabel\", \"\"], [\"ngxSliderLabel\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bubble\", \"ngx-slider-model-high\"], [\"maxHandleLabel\", \"\"], [\"ngxSliderLabel\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bubble\", \"ngx-slider-combined\"], [\"combinedLabel\", \"\"], [\"ngxSliderElement\", \"\", 1, \"ngx-slider-ticks\", 3, \"hidden\"], [\"ticksElement\", \"\"], [\"class\", \"ngx-slider-tick\", 3, \"ngClass\", \"ngStyle\", 4, \"ngFor\", \"ngForOf\"], [1, \"ngx-slider-tick\", 3, \"ngClass\", \"ngStyle\"], [3, \"template\", \"tooltip\", \"placement\"], [\"class\", \"ngx-slider-span ngx-slider-tick-value\", 3, \"template\", \"tooltip\", \"placement\", \"content\", 4, \"ngIf\"], [\"class\", \"ngx-slider-span ngx-slider-tick-legend\", 3, \"innerHTML\", 4, \"ngIf\"], [1, \"ngx-slider-span\", \"ngx-slider-tick-value\", 3, \"template\", \"tooltip\", \"placement\", \"content\"], [1, \"ngx-slider-span\", \"ngx-slider-tick-legend\", 3, \"innerHTML\"]],\n  template: function SliderComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelementStart(0, \"span\", 0, 1);\n      ɵngcc0.ɵɵelement(2, \"span\", 2);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementStart(3, \"span\", 3, 4);\n      ɵngcc0.ɵɵelement(5, \"span\", 2);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementStart(6, \"span\", 5, 6);\n      ɵngcc0.ɵɵelement(8, \"span\", 2);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementStart(9, \"span\", 7, 8);\n      ɵngcc0.ɵɵelement(11, \"span\", 9);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelement(12, \"span\", 10, 11)(14, \"span\", 12, 13)(16, \"span\", 14, 15)(18, \"span\", 16, 17)(20, \"span\", 18, 19)(22, \"span\", 20, 21)(24, \"span\", 22, 23);\n      ɵngcc0.ɵɵelementStart(26, \"span\", 24, 25);\n      ɵngcc0.ɵɵtemplate(28, SliderComponent_span_28_Template, 4, 9, \"span\", 26);\n      ɵngcc0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(6);\n      ɵngcc0.ɵɵclassProp(\"ngx-slider-transparent\", ctx.fullBarTransparentClass);\n      ɵngcc0.ɵɵadvance(3);\n      ɵngcc0.ɵɵclassProp(\"ngx-slider-draggable\", ctx.selectionBarDraggableClass);\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.barStyle);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.minPointerStyle);\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵstyleProp(\"display\", ctx.range ? \"inherit\" : \"none\");\n      ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.maxPointerStyle);\n      ɵngcc0.ɵɵadvance(12);\n      ɵngcc0.ɵɵclassProp(\"ngx-slider-ticks-values-under\", ctx.ticksUnderValuesClass);\n      ɵngcc0.ɵɵproperty(\"hidden\", !ctx.showTicks);\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.ticks);\n    }\n  },\n  dependencies: function () {\n    return [ɵngcc1.NgClass, ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgStyle, SliderElementDirective, SliderHandleDirective, SliderLabelDirective, TooltipWrapperComponent];\n  },\n  styles: [\".ngx-slider{display:inline-block;position:relative;height:4px;width:100%;margin:35px 0 15px;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;touch-action:pan-y}  .ngx-slider.with-legend{margin-bottom:40px}  .ngx-slider[disabled]{cursor:not-allowed}  .ngx-slider[disabled] .ngx-slider-pointer{cursor:not-allowed;background-color:#d8e0f3}  .ngx-slider[disabled] .ngx-slider-draggable{cursor:not-allowed}  .ngx-slider[disabled] .ngx-slider-selection{background:#8b91a2}  .ngx-slider[disabled] .ngx-slider-tick{cursor:not-allowed}  .ngx-slider[disabled] .ngx-slider-tick.ngx-slider-selected{background:#8b91a2}  .ngx-slider .ngx-slider-span{white-space:nowrap;position:absolute;display:inline-block}  .ngx-slider .ngx-slider-base{width:100%;height:100%;padding:0}  .ngx-slider .ngx-slider-bar-wrapper{left:0;box-sizing:border-box;margin-top:-16px;padding-top:16px;width:100%;height:32px;z-index:1}  .ngx-slider .ngx-slider-draggable{cursor:move}  .ngx-slider .ngx-slider-bar{left:0;width:100%;height:4px;z-index:1;background:#d8e0f3;border-radius:2px}  .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-transparent .ngx-slider-bar{background:0 0}  .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-left-out-selection .ngx-slider-bar{background:#df002d}  .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-right-out-selection .ngx-slider-bar{background:#03a688}  .ngx-slider .ngx-slider-selection{z-index:2;background:#0db9f0;border-radius:2px}  .ngx-slider .ngx-slider-pointer{cursor:pointer;width:32px;height:32px;top:-14px;background-color:#0db9f0;z-index:3;border-radius:16px}  .ngx-slider .ngx-slider-pointer:after{content:'';width:8px;height:8px;position:absolute;top:12px;left:12px;border-radius:4px;background:#fff}  .ngx-slider .ngx-slider-pointer:hover:after{background-color:#fff}  .ngx-slider .ngx-slider-pointer.ngx-slider-active{z-index:4}  .ngx-slider .ngx-slider-pointer.ngx-slider-active:after{background-color:#451aff}  .ngx-slider .ngx-slider-bubble{cursor:default;bottom:16px;padding:1px 3px;color:#55637d;font-size:16px}  .ngx-slider .ngx-slider-bubble.ngx-slider-limit{color:#55637d}  .ngx-slider .ngx-slider-ticks{box-sizing:border-box;width:100%;height:0;position:absolute;left:0;top:-3px;margin:0;z-index:1;list-style:none}  .ngx-slider .ngx-slider-ticks-values-under .ngx-slider-tick-value{top:auto;bottom:-36px}  .ngx-slider .ngx-slider-tick{text-align:center;cursor:pointer;width:10px;height:10px;background:#d8e0f3;border-radius:50%;position:absolute;top:0;left:0;margin-left:11px}  .ngx-slider .ngx-slider-tick.ngx-slider-selected{background:#0db9f0}  .ngx-slider .ngx-slider-tick-value{position:absolute;top:-34px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0)}  .ngx-slider .ngx-slider-tick-legend{position:absolute;top:24px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);max-width:50px;white-space:normal}  .ngx-slider.vertical{position:relative;width:4px;height:100%;margin:0 20px;padding:0;vertical-align:baseline;touch-action:pan-x}  .ngx-slider.vertical .ngx-slider-base{width:100%;height:100%;padding:0}  .ngx-slider.vertical .ngx-slider-bar-wrapper{top:auto;left:0;margin:0 0 0 -16px;padding:0 0 0 16px;height:100%;width:32px}  .ngx-slider.vertical .ngx-slider-bar{bottom:0;left:auto;width:4px;height:100%}  .ngx-slider.vertical .ngx-slider-pointer{left:-14px!important;top:auto;bottom:0}  .ngx-slider.vertical .ngx-slider-bubble{left:16px!important;bottom:0}  .ngx-slider.vertical .ngx-slider-ticks{height:100%;width:0;left:-3px;top:0;z-index:1}  .ngx-slider.vertical .ngx-slider-tick{vertical-align:middle;margin-left:auto;margin-top:11px}  .ngx-slider.vertical .ngx-slider-tick-value{left:24px;top:auto;-webkit-transform:translate(0,-28%);transform:translate(0,-28%)}  .ngx-slider.vertical .ngx-slider-tick-legend{top:auto;right:24px;-webkit-transform:translate(0,-28%);transform:translate(0,-28%);max-width:none;white-space:nowrap}  .ngx-slider.vertical .ngx-slider-ticks-values-under .ngx-slider-tick-value{bottom:auto;left:auto;right:24px}  .ngx-slider *{transition:none}  .ngx-slider.animate .ngx-slider-bar-wrapper{transition:.3s linear}  .ngx-slider.animate .ngx-slider-selection{transition:background-color .3s linear}  .ngx-slider.animate .ngx-slider-pointer{transition:.3s linear}  .ngx-slider.animate .ngx-slider-pointer:after{transition:.3s linear}  .ngx-slider.animate .ngx-slider-bubble{transition:.3s linear}  .ngx-slider.animate .ngx-slider-bubble.ngx-slider-limit{transition:opacity .3s linear}  .ngx-slider.animate .ngx-slider-bubble.ngx-slider-combined{transition:opacity .3s linear}  .ngx-slider.animate .ngx-slider-tick{transition:background-color .3s linear}\"]\n});\n/** @nocollapse */\n\nSliderComponent.ctorParameters = () => [{\n  type: Renderer2\n}, {\n  type: ElementRef\n}, {\n  type: ChangeDetectorRef\n}, {\n  type: NgZone\n}];\n\nSliderComponent.propDecorators = {\n  value: [{\n    type: Input\n  }],\n  valueChange: [{\n    type: Output\n  }],\n  highValue: [{\n    type: Input\n  }],\n  highValueChange: [{\n    type: Output\n  }],\n  options: [{\n    type: Input\n  }],\n  userChangeStart: [{\n    type: Output\n  }],\n  userChange: [{\n    type: Output\n  }],\n  userChangeEnd: [{\n    type: Output\n  }],\n  manualRefresh: [{\n    type: Input\n  }],\n  triggerFocus: [{\n    type: Input\n  }],\n  leftOuterSelectionBarElement: [{\n    type: ViewChild,\n    args: ['leftOuterSelectionBar', {\n      read: SliderElementDirective\n    }]\n  }],\n  rightOuterSelectionBarElement: [{\n    type: ViewChild,\n    args: ['rightOuterSelectionBar', {\n      read: SliderElementDirective\n    }]\n  }],\n  fullBarElement: [{\n    type: ViewChild,\n    args: ['fullBar', {\n      read: SliderElementDirective\n    }]\n  }],\n  selectionBarElement: [{\n    type: ViewChild,\n    args: ['selectionBar', {\n      read: SliderElementDirective\n    }]\n  }],\n  minHandleElement: [{\n    type: ViewChild,\n    args: ['minHandle', {\n      read: SliderHandleDirective\n    }]\n  }],\n  maxHandleElement: [{\n    type: ViewChild,\n    args: ['maxHandle', {\n      read: SliderHandleDirective\n    }]\n  }],\n  floorLabelElement: [{\n    type: ViewChild,\n    args: ['floorLabel', {\n      read: SliderLabelDirective\n    }]\n  }],\n  ceilLabelElement: [{\n    type: ViewChild,\n    args: ['ceilLabel', {\n      read: SliderLabelDirective\n    }]\n  }],\n  minHandleLabelElement: [{\n    type: ViewChild,\n    args: ['minHandleLabel', {\n      read: SliderLabelDirective\n    }]\n  }],\n  maxHandleLabelElement: [{\n    type: ViewChild,\n    args: ['maxHandleLabel', {\n      read: SliderLabelDirective\n    }]\n  }],\n  combinedLabelElement: [{\n    type: ViewChild,\n    args: ['combinedLabel', {\n      read: SliderLabelDirective\n    }]\n  }],\n  ticksElement: [{\n    type: ViewChild,\n    args: ['ticksElement', {\n      read: SliderElementDirective\n    }]\n  }],\n  tooltipTemplate: [{\n    type: ContentChild,\n    args: ['tooltipTemplate']\n  }],\n  sliderElementVerticalClass: [{\n    type: HostBinding,\n    args: ['class.vertical']\n  }],\n  sliderElementAnimateClass: [{\n    type: HostBinding,\n    args: ['class.animate']\n  }],\n  sliderElementWithLegendClass: [{\n    type: HostBinding,\n    args: ['class.with-legend']\n  }],\n  sliderElementDisabledAttr: [{\n    type: HostBinding,\n    args: ['attr.disabled']\n  }],\n  sliderElementAriaLabel: [{\n    type: HostBinding,\n    args: ['attr.aria-label']\n  }],\n  onResize: [{\n    type: HostListener,\n    args: ['window:resize', ['$event']]\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-slider',\n      template: `<!-- // 0 Left selection bar outside two handles -->\n<span ngxSliderElement #leftOuterSelectionBar class=\"ngx-slider-span ngx-slider-bar-wrapper ngx-slider-left-out-selection\">\n  <span class=\"ngx-slider-span ngx-slider-bar\"></span>\n</span>\n<!-- // 1 Right selection bar outside two handles -->\n<span ngxSliderElement #rightOuterSelectionBar class=\"ngx-slider-span ngx-slider-bar-wrapper ngx-slider-right-out-selection\">\n  <span class=\"ngx-slider-span ngx-slider-bar\"></span>\n</span>\n<!-- // 2 The whole slider bar -->\n<span ngxSliderElement #fullBar [class.ngx-slider-transparent]=\"fullBarTransparentClass\" class=\"ngx-slider-span ngx-slider-bar-wrapper ngx-slider-full-bar\">\n  <span class=\"ngx-slider-span ngx-slider-bar\"></span>\n</span>\n<!-- // 3 Selection bar between two handles -->\n<span ngxSliderElement #selectionBar [class.ngx-slider-draggable]=\"selectionBarDraggableClass\" class=\"ngx-slider-span ngx-slider-bar-wrapper ngx-slider-selection-bar\">\n  <span class=\"ngx-slider-span ngx-slider-bar ngx-slider-selection\" [ngStyle]=\"barStyle\"></span>\n</span>\n<!-- // 4 Low slider handle -->\n<span ngxSliderHandle #minHandle class=\"ngx-slider-span ngx-slider-pointer ngx-slider-pointer-min\" [ngStyle]=minPointerStyle></span>\n<!-- // 5 High slider handle -->\n<span ngxSliderHandle #maxHandle [style.display]=\"range ? 'inherit' : 'none'\" class=\"ngx-slider-span ngx-slider-pointer ngx-slider-pointer-max\" [ngStyle]=maxPointerStyle></span>\n<!-- // 6 Floor label -->\n<span ngxSliderLabel #floorLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-limit ngx-slider-floor\"></span>\n<!-- // 7 Ceiling label -->\n<span ngxSliderLabel #ceilLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-limit ngx-slider-ceil\"></span>\n<!-- // 8 Label above the low slider handle -->\n<span ngxSliderLabel #minHandleLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-model-value\"></span>\n<!-- // 9 Label above the high slider handle -->\n<span ngxSliderLabel #maxHandleLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-model-high\"></span>\n<!-- // 10 Combined range label when the slider handles are close ex. 15 - 17 -->\n<span ngxSliderLabel #combinedLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-combined\"></span>\n<!-- // 11 The ticks -->\n<span ngxSliderElement #ticksElement [hidden]=\"!showTicks\" [class.ngx-slider-ticks-values-under]=\"ticksUnderValuesClass\" class=\"ngx-slider-ticks\">\n  <span *ngFor=\"let t of ticks\" class=\"ngx-slider-tick\" [ngClass]=\"{'ngx-slider-selected': t.selected}\" [ngStyle]=\"t.style\">\n    <ngx-slider-tooltip-wrapper [template]=\"tooltipTemplate\" [tooltip]=\"t.tooltip\" [placement]=\"t.tooltipPlacement\"></ngx-slider-tooltip-wrapper>\n    <ngx-slider-tooltip-wrapper *ngIf=\"t.value != null\" class=\"ngx-slider-span ngx-slider-tick-value\"\n        [template]=\"tooltipTemplate\" [tooltip]=\"t.valueTooltip\" [placement]=\"t.valueTooltipPlacement\" [content]=\"t.value\"></ngx-slider-tooltip-wrapper>\n    <span *ngIf=\"t.legend != null\" class=\"ngx-slider-span ngx-slider-tick-legend\" [innerHTML]=\"t.legend\"></span>\n  </span>\n</span>`,\n      host: {\n        class: 'ngx-slider'\n      },\n      providers: [NGX_SLIDER_CONTROL_VALUE_ACCESSOR],\n      styles: [\"::ng-deep .ngx-slider{display:inline-block;position:relative;height:4px;width:100%;margin:35px 0 15px;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;touch-action:pan-y}::ng-deep .ngx-slider.with-legend{margin-bottom:40px}::ng-deep .ngx-slider[disabled]{cursor:not-allowed}::ng-deep .ngx-slider[disabled] .ngx-slider-pointer{cursor:not-allowed;background-color:#d8e0f3}::ng-deep .ngx-slider[disabled] .ngx-slider-draggable{cursor:not-allowed}::ng-deep .ngx-slider[disabled] .ngx-slider-selection{background:#8b91a2}::ng-deep .ngx-slider[disabled] .ngx-slider-tick{cursor:not-allowed}::ng-deep .ngx-slider[disabled] .ngx-slider-tick.ngx-slider-selected{background:#8b91a2}::ng-deep .ngx-slider .ngx-slider-span{white-space:nowrap;position:absolute;display:inline-block}::ng-deep .ngx-slider .ngx-slider-base{width:100%;height:100%;padding:0}::ng-deep .ngx-slider .ngx-slider-bar-wrapper{left:0;box-sizing:border-box;margin-top:-16px;padding-top:16px;width:100%;height:32px;z-index:1}::ng-deep .ngx-slider .ngx-slider-draggable{cursor:move}::ng-deep .ngx-slider .ngx-slider-bar{left:0;width:100%;height:4px;z-index:1;background:#d8e0f3;border-radius:2px}::ng-deep .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-transparent .ngx-slider-bar{background:0 0}::ng-deep .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-left-out-selection .ngx-slider-bar{background:#df002d}::ng-deep .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-right-out-selection .ngx-slider-bar{background:#03a688}::ng-deep .ngx-slider .ngx-slider-selection{z-index:2;background:#0db9f0;border-radius:2px}::ng-deep .ngx-slider .ngx-slider-pointer{cursor:pointer;width:32px;height:32px;top:-14px;background-color:#0db9f0;z-index:3;border-radius:16px}::ng-deep .ngx-slider .ngx-slider-pointer:after{content:'';width:8px;height:8px;position:absolute;top:12px;left:12px;border-radius:4px;background:#fff}::ng-deep .ngx-slider .ngx-slider-pointer:hover:after{background-color:#fff}::ng-deep .ngx-slider .ngx-slider-pointer.ngx-slider-active{z-index:4}::ng-deep .ngx-slider .ngx-slider-pointer.ngx-slider-active:after{background-color:#451aff}::ng-deep .ngx-slider .ngx-slider-bubble{cursor:default;bottom:16px;padding:1px 3px;color:#55637d;font-size:16px}::ng-deep .ngx-slider .ngx-slider-bubble.ngx-slider-limit{color:#55637d}::ng-deep .ngx-slider .ngx-slider-ticks{box-sizing:border-box;width:100%;height:0;position:absolute;left:0;top:-3px;margin:0;z-index:1;list-style:none}::ng-deep .ngx-slider .ngx-slider-ticks-values-under .ngx-slider-tick-value{top:auto;bottom:-36px}::ng-deep .ngx-slider .ngx-slider-tick{text-align:center;cursor:pointer;width:10px;height:10px;background:#d8e0f3;border-radius:50%;position:absolute;top:0;left:0;margin-left:11px}::ng-deep .ngx-slider .ngx-slider-tick.ngx-slider-selected{background:#0db9f0}::ng-deep .ngx-slider .ngx-slider-tick-value{position:absolute;top:-34px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0)}::ng-deep .ngx-slider .ngx-slider-tick-legend{position:absolute;top:24px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);max-width:50px;white-space:normal}::ng-deep .ngx-slider.vertical{position:relative;width:4px;height:100%;margin:0 20px;padding:0;vertical-align:baseline;touch-action:pan-x}::ng-deep .ngx-slider.vertical .ngx-slider-base{width:100%;height:100%;padding:0}::ng-deep .ngx-slider.vertical .ngx-slider-bar-wrapper{top:auto;left:0;margin:0 0 0 -16px;padding:0 0 0 16px;height:100%;width:32px}::ng-deep .ngx-slider.vertical .ngx-slider-bar{bottom:0;left:auto;width:4px;height:100%}::ng-deep .ngx-slider.vertical .ngx-slider-pointer{left:-14px!important;top:auto;bottom:0}::ng-deep .ngx-slider.vertical .ngx-slider-bubble{left:16px!important;bottom:0}::ng-deep .ngx-slider.vertical .ngx-slider-ticks{height:100%;width:0;left:-3px;top:0;z-index:1}::ng-deep .ngx-slider.vertical .ngx-slider-tick{vertical-align:middle;margin-left:auto;margin-top:11px}::ng-deep .ngx-slider.vertical .ngx-slider-tick-value{left:24px;top:auto;-webkit-transform:translate(0,-28%);transform:translate(0,-28%)}::ng-deep .ngx-slider.vertical .ngx-slider-tick-legend{top:auto;right:24px;-webkit-transform:translate(0,-28%);transform:translate(0,-28%);max-width:none;white-space:nowrap}::ng-deep .ngx-slider.vertical .ngx-slider-ticks-values-under .ngx-slider-tick-value{bottom:auto;left:auto;right:24px}::ng-deep .ngx-slider *{transition:none}::ng-deep .ngx-slider.animate .ngx-slider-bar-wrapper{transition:.3s linear}::ng-deep .ngx-slider.animate .ngx-slider-selection{transition:background-color .3s linear}::ng-deep .ngx-slider.animate .ngx-slider-pointer{transition:.3s linear}::ng-deep .ngx-slider.animate .ngx-slider-pointer:after{transition:.3s linear}::ng-deep .ngx-slider.animate .ngx-slider-bubble{transition:.3s linear}::ng-deep .ngx-slider.animate .ngx-slider-bubble.ngx-slider-limit{transition:opacity .3s linear}::ng-deep .ngx-slider.animate .ngx-slider-bubble.ngx-slider-combined{transition:opacity .3s linear}::ng-deep .ngx-slider.animate .ngx-slider-tick{transition:background-color .3s linear}\"]\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.Renderer2\n    }, {\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.ChangeDetectorRef\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, {\n    value: [{\n      type: Input\n    }],\n    valueChange: [{\n      type: Output\n    }],\n    highValue: [{\n      type: Input\n    }],\n    highValueChange: [{\n      type: Output\n    }],\n    options: [{\n      type: Input\n    }],\n    userChangeStart: [{\n      type: Output\n    }],\n    userChange: [{\n      type: Output\n    }],\n    userChangeEnd: [{\n      type: Output\n    }],\n    sliderElementVerticalClass: [{\n      type: HostBinding,\n      args: ['class.vertical']\n    }],\n    sliderElementAnimateClass: [{\n      type: HostBinding,\n      args: ['class.animate']\n    }],\n    sliderElementWithLegendClass: [{\n      type: HostBinding,\n      args: ['class.with-legend']\n    }],\n    sliderElementDisabledAttr: [{\n      type: HostBinding,\n      args: ['attr.disabled']\n    }],\n    sliderElementAriaLabel: [{\n      type: HostBinding,\n      args: ['attr.aria-label']\n    }],\n    manualRefresh: [{\n      type: Input\n    }],\n    triggerFocus: [{\n      type: Input\n    }],\n\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    onResize: [{\n      type: HostListener,\n      args: ['window:resize', ['$event']]\n    }],\n    leftOuterSelectionBarElement: [{\n      type: ViewChild,\n      args: ['leftOuterSelectionBar', {\n        read: SliderElementDirective\n      }]\n    }],\n    rightOuterSelectionBarElement: [{\n      type: ViewChild,\n      args: ['rightOuterSelectionBar', {\n        read: SliderElementDirective\n      }]\n    }],\n    fullBarElement: [{\n      type: ViewChild,\n      args: ['fullBar', {\n        read: SliderElementDirective\n      }]\n    }],\n    selectionBarElement: [{\n      type: ViewChild,\n      args: ['selectionBar', {\n        read: SliderElementDirective\n      }]\n    }],\n    minHandleElement: [{\n      type: ViewChild,\n      args: ['minHandle', {\n        read: SliderHandleDirective\n      }]\n    }],\n    maxHandleElement: [{\n      type: ViewChild,\n      args: ['maxHandle', {\n        read: SliderHandleDirective\n      }]\n    }],\n    floorLabelElement: [{\n      type: ViewChild,\n      args: ['floorLabel', {\n        read: SliderLabelDirective\n      }]\n    }],\n    ceilLabelElement: [{\n      type: ViewChild,\n      args: ['ceilLabel', {\n        read: SliderLabelDirective\n      }]\n    }],\n    minHandleLabelElement: [{\n      type: ViewChild,\n      args: ['minHandleLabel', {\n        read: SliderLabelDirective\n      }]\n    }],\n    maxHandleLabelElement: [{\n      type: ViewChild,\n      args: ['maxHandleLabel', {\n        read: SliderLabelDirective\n      }]\n    }],\n    combinedLabelElement: [{\n      type: ViewChild,\n      args: ['combinedLabel', {\n        read: SliderLabelDirective\n      }]\n    }],\n    ticksElement: [{\n      type: ViewChild,\n      args: ['ticksElement', {\n        read: SliderElementDirective\n      }]\n    }],\n    tooltipTemplate: [{\n      type: ContentChild,\n      args: ['tooltipTemplate']\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nclass TooltipWrapperComponent {}\n\nTooltipWrapperComponent.ɵfac = function TooltipWrapperComponent_Factory(t) {\n  return new (t || TooltipWrapperComponent)();\n};\n\nTooltipWrapperComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: TooltipWrapperComponent,\n  selectors: [[\"ngx-slider-tooltip-wrapper\"]],\n  inputs: {\n    template: \"template\",\n    tooltip: \"tooltip\",\n    placement: \"placement\",\n    content: \"content\"\n  },\n  decls: 2,\n  vars: 2,\n  consts: [[4, \"ngIf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"ngx-slider-inner-tooltip\"]],\n  template: function TooltipWrapperComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵtemplate(0, TooltipWrapperComponent_ng_container_0_Template, 2, 6, \"ng-container\", 0);\n      ɵngcc0.ɵɵtemplate(1, TooltipWrapperComponent_ng_container_1_Template, 3, 3, \"ng-container\", 0);\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.template);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.template);\n    }\n  },\n  dependencies: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet],\n  styles: [\".ngx-slider-inner-tooltip[_ngcontent-%COMP%]{height:100%}\"]\n});\nTooltipWrapperComponent.propDecorators = {\n  template: [{\n    type: Input\n  }],\n  tooltip: [{\n    type: Input\n  }],\n  placement: [{\n    type: Input\n  }],\n  content: [{\n    type: Input\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipWrapperComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-slider-tooltip-wrapper',\n      template: `<ng-container *ngIf=\"template\">\n  <ng-template *ngTemplateOutlet=\"template; context: {tooltip: tooltip, placement: placement, content: content}\"></ng-template>\n</ng-container>\n\n<ng-container *ngIf=\"!template\">\n  <div class=\"ngx-slider-inner-tooltip\" [attr.title]=\"tooltip\" [attr.data-tooltip-placement]=\"placement\">\n    {{content}}\n  </div>\n</ng-container>`,\n      styles: [\".ngx-slider-inner-tooltip{height:100%}\"]\n    }]\n  }], null, {\n    template: [{\n      type: Input\n    }],\n    tooltip: [{\n      type: Input\n    }],\n    placement: [{\n      type: Input\n    }],\n    content: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * NgxSlider module\n *\n * The module exports the slider component\n */\n\n\nclass NgxSliderModule {}\n\nNgxSliderModule.ɵfac = function NgxSliderModule_Factory(t) {\n  return new (t || NgxSliderModule)();\n};\n\nNgxSliderModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: NgxSliderModule\n});\nNgxSliderModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n  imports: [CommonModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxSliderModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [SliderComponent, SliderElementDirective, SliderHandleDirective, SliderLabelDirective, TooltipWrapperComponent],\n      exports: [SliderComponent]\n    }]\n  }], null, null);\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxSliderModule, {\n    declarations: function () {\n      return [SliderComponent, SliderElementDirective, SliderHandleDirective, SliderLabelDirective, TooltipWrapperComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [SliderComponent];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nexport { NgxSliderModule, ChangeContext, PointerType, LabelType, Options, SliderElementDirective as ɵb, SliderHandleDirective as ɵc, SliderLabelDirective as ɵd, SliderComponent as ɵa, TooltipWrapperComponent as ɵe };","map":{"version":3,"names":["Subject","throttleTime","tap","distinctUntilChanged","filter","supportsPassiveEvents","Directive","ElementRef","Renderer2","HostBinding","ChangeDetectorRef","Component","ViewChild","HostListener","Input","EventEmitter","Output","ContentChild","forwardRef","NgZone","NgModule","NG_VALUE_ACCESSOR","CommonModule","ɵngcc0","ɵngcc1","_c0","_c1","_c2","_c3","_c4","_c5","_c6","_c7","_c8","_c9","_c10","_c11","_c12","SliderComponent_span_28_ngx_slider_tooltip_wrapper_2_Template","rf","ctx","ɵɵelement","t_r13","ɵɵnextContext","$implicit","ctx_r14","ɵɵproperty","tooltipTemplate","valueTooltip","valueTooltipPlacement","value","SliderComponent_span_28_span_3_Template","legend","ɵɵsanitizeHtml","_c13","a0","SliderComponent_span_28_Template","ɵɵelementStart","ɵɵtemplate","ɵɵelementEnd","ctx_r12","ɵɵpureFunction1","selected","style","ɵɵadvance","tooltip","tooltipPlacement","TooltipWrapperComponent_ng_container_0_1_ng_template_0_Template","TooltipWrapperComponent_ng_container_0_1_Template","_c14","a1","a2","placement","content","TooltipWrapperComponent_ng_container_0_Template","ɵɵelementContainerStart","ɵɵelementContainerEnd","ctx_r0","template","ɵɵpureFunction3","TooltipWrapperComponent_ng_container_1_Template","ɵɵtext","ctx_r1","ɵɵattribute","ɵɵtextInterpolate1","LabelType","Low","High","Floor","Ceil","TickValue","Options","constructor","floor","ceil","step","minRange","maxRange","pushRange","minLimit","maxLimit","translate","combineLabels","getLegend","getStepLegend","stepsArray","bindIndexForStepsArray","draggableRange","draggableRangeOnly","showSelectionBar","showSelectionBarEnd","showSelectionBarFromValue","showOuterSelectionBars","hidePointerLabels","hideLimitLabels","autoHideLimitLabels","readOnly","disabled","showTicks","showTicksValues","tickStep","tickValueStep","ticksArray","ticksTooltip","ticksValuesTooltip","vertical","getSelectionBarColor","getTickColor","getPointerColor","keyboardSupport","scale","rotate","enforceStep","enforceRange","enforceStepsArray","noSwitching","onlyBindHandles","rightToLeft","reversedControls","boundPointerLabels","logScale","customValueToPosition","customPositionToValue","precisionLimit","selectionBarGradient","ariaLabel","ariaLabelledBy","ariaLabelHigh","ariaLabelledByHigh","handleDimension","barDimension","animate","animateOnMove","PointerType","Min","Max","ChangeContext","ValueHelper","isNullOrUndefined","undefined","areArraysEqual","array1","array2","length","i","linearValueToPosition","val","minVal","maxVal","range","logValueToPosition","Math","log","linearPositionToValue","percent","logPositionToValue","exp","findStepIndex","modelValue","differences","map","abs","minDifferenceIndex","index","CompatibilityHelper","isTouchEvent","event","window","TouchEvent","touches","isResizeObserverAvailable","ResizeObserver","MathHelper","roundToPrecisionLimit","toPrecision","isModuloWithinPrecisionLimit","modulo","limit","pow","clampToRange","min","max","EventListener","eventName","events","eventsSubscription","teardownCallback","EventListenerHelper","renderer","attachPassiveEventListener","nativeElement","callback","throttleInterval","attachEventListener","listener","observerCallback","next","addEventListener","passive","capture","removeEventListener","pipe","leading","trailing","subscribe","detachEventListener","eventListener","unsubscribe","complete","listen","SliderElementDirective","elemRef","changeDetectionRef","_position","_dimension","_alwaysHide","_vertical","_scale","_rotate","opacity","visibility","left","bottom","height","width","transform","eventListeners","eventListenerHelper","position","dimension","alwaysHide","setAlwaysHide","hide","show","isVisible","setVertical","setScale","setRotate","getRotate","setPosition","pos","isRefDestroyed","markForCheck","round","calculateDimension","getBoundingClientRect","top","right","setDimension","dim","on","debounceInterval","push","onPassive","off","listenersToKeep","listenersToRemove","ɵfac","SliderElementDirective_Factory","t","ɵɵdirectiveInject","ɵdir","ɵɵdefineDirective","type","selectors","hostVars","hostBindings","SliderElementDirective_HostBindings","ɵɵstyleProp","ctorParameters","propDecorators","args","ngDevMode","ɵsetClassMetadata","selector","SliderHandleDirective","active","role","tabindex","ariaOrientation","ariaValueNow","ariaValueText","ariaValueMin","ariaValueMax","focus","SliderHandleDirective_Factory","SliderHandleDirective_HostBindings","ɵɵclassProp","features","ɵɵInheritDefinitionFeature","SliderLabelDirective","_value","setValue","recalculateDimension","innerHTML","SliderLabelDirective_Factory","Tick","Dragging","difference","lowLimit","highLimit","ModelValues","compare","x","y","highValue","ModelChange","forceChange","NGX_SLIDER_CONTROL_VALUE_ACCESSOR","provide","useExisting","SliderComponent","multi","elementRef","zone","valueChange","highValueChange","options","userChangeStart","userChange","userChangeEnd","initHasRun","inputModelChangeSubject","inputModelChangeSubscription","outputModelChangeSubject","outputModelChangeSubscription","viewLowValue","viewHighValue","viewOptions","handleHalfDimension","maxHandlePosition","currentTrackingPointer","currentFocusPointer","firstKeyDown","touchId","dragging","sliderElementVerticalClass","sliderElementAnimateClass","sliderElementWithLegendClass","sliderElementDisabledAttr","sliderElementAriaLabel","barStyle","minPointerStyle","maxPointerStyle","fullBarTransparentClass","selectionBarDraggableClass","ticksUnderValuesClass","intermediateTicks","ticks","onMoveEventListener","onEndEventListener","moving","resizeObserver","onTouchedCallback","onChangeCallback","manualRefresh","unsubscribeManualRefresh","manualRefreshSubscription","setTimeout","calculateViewDimensionsAndDetectChanges","triggerFocus","unsubscribeTriggerFocus","triggerFocusSubscription","pointerType","focusPointer","ngOnInit","Object","assign","updateDisabledState","updateVerticalState","updateAriaLabel","ngAfterViewInit","applyOptions","subscribeInputModelChangeSubject","subscribeOutputModelChangeSubject","renormaliseModelValues","modelValueToViewValue","manageElementsStyle","calculateViewDimensions","addAccessibility","updateCeilLabel","updateFloorLabel","initHandles","manageEventsBindings","subscribeResizeObserver","detectChanges","ngOnChanges","changes","JSON","stringify","previousValue","currentValue","onChangeOptions","internalChange","ngOnDestroy","unbindEvents","unsubscribeResizeObserver","unsubscribeInputModelChangeSubject","unsubscribeOutputModelChangeSubject","writeValue","obj","Array","registerOnChange","registerOnTouched","setDisabledState","isDisabled","setAriaLabel","onResize","modelChange","applyInputModelChange","publishOutputModelChange","observe","disconnect","unsubscribeOnMove","unsubscribeOnEnd","getPointerElement","minHandleElement","maxHandleElement","getCurrentTrackingValue","NaN","viewValueToModelValue","viewValue","getStepValue","sliderValue","applyViewChange","userEventInitiated","normalisedModelChange","normaliseModelValues","normalisationChange","updateLowHandle","valueToPosition","updateHighHandle","updateSelectionBar","updateTicksScale","updateAriaAttributes","updateCombinedLabel","emitOutputs","emit","getChangeContext","input","normalisedInput","valueIndex","highValueIndex","roundStep","tempValue","previousModelValues","normalisedModelValues","previousOptionsInfluencingEventBindings","getOptionsInfluencingEventBindings","newOptionsInfluencingEventBindings","rebindEvents","resetSlider","applyStepsArrayOptions","applyFloorCeilOptions","minValue","maxValue","Error","String","refocusPointerIfNeeded","onPointerFocus","element","updateScale","floorLabelElement","ceilLabelElement","hideLabelsForTicks","minHandleLabelElement","maxHandleLabelElement","combinedLabelElement","selectionBarElement","leftOuterSelectionBarElement","rightOuterSelectionBarElement","updateRotate","bindEvents","getAllSliderElements","fullBarElement","ticksElement","toString","handleWidth","getTicksArray","reverse","hasAtLeastOneLegend","newTicks","translation","tick","isTickSelected","getDisplayValue","numberOfValues","center","updateHandles","which","newPos","getHandleLabelPos","labelType","labelDimension","nearHandlePos","endOfBarPos","backgroundColor","updateFloorAndCeilLabelsVisibility","floorLabelHidden","ceilLabelHidden","isMinLabelAtFloor","isLabelBelowFloorLabel","isMinLabelAtCeil","isLabelAboveCeilLabel","isMaxLabelAtCeil","isCombinedLabelAtFloor","isCombinedLabelAtCeil","hideCeil","hideFloor","label","floorPos","floorDim","ceilPos","ceilDim","isSelectionBarFromRight","positionForRange","centerPosition","isModelGreaterThanCenter","color","offset","reversed","direction","backgroundImage","from","to","backgroundPosition","backgroundSize","isLabelOverlap","lowDisplayValue","highDisplayValue","combinedLabelValue","customStep","steppedDifference","fn","positionToValue","getEventXY","targetTouchId","MouseEvent","clientY","clientX","touchIndex","identifier","getEventPosition","sliderElementBoundingRect","sliderPos","eventPos","getNearestHandle","distanceMin","distanceMax","onBarStart","onStart","bindMove","bindEnd","simulateImmediateMove","simulateImmediateEnd","onDragStart","stopPropagation","preventDefault","pointerElement","onMoveCallback","e","onDragMove","onMove","document","onEndCallback","onEnd","changedTouches","fromTick","touchForThisSlider","newValue","ceilValue","floorValue","positionTrackingHandle","onPointerBlur","onKeyboardEvent","onKeyUp","pointer","getKeyActions","valueRange","increaseStep","decreaseStep","increasePage","decreasePage","actions","UP","DOWN","LEFT","RIGHT","PAGEUP","PAGEDOWN","HOME","END","keyCode","keys","key","action","actionValue","newMinValue","newMaxValue","positionTrackingBar","getMinValue","outOfBounds","isAbove","isRTL","getMaxValue","ceilLimit","floorLimit","floorHandleElement","ceilHandleElement","isUnderFloorLimit","isOverCeilLimit","applyMinMaxLimit","applyPushRange","applyMinMaxRange","oppositeValue","changeContext","SliderComponent_Factory","ɵcmp","ɵɵdefineComponent","contentQueries","SliderComponent_ContentQueries","dirIndex","ɵɵcontentQuery","_t","ɵɵqueryRefresh","ɵɵloadQuery","first","viewQuery","SliderComponent_Query","ɵɵviewQuery","hostAttrs","SliderComponent_HostBindings","ɵɵlistener","SliderComponent_resize_HostBindingHandler","$event","ɵɵresolveWindow","inputs","outputs","ɵɵProvidersFeature","ɵɵNgOnChangesFeature","decls","vars","consts","SliderComponent_Template","dependencies","NgClass","NgForOf","NgIf","NgStyle","TooltipWrapperComponent","styles","read","host","class","providers","TooltipWrapperComponent_Factory","TooltipWrapperComponent_Template","NgTemplateOutlet","NgxSliderModule","NgxSliderModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","declarations","exports","ngJitMode","ɵɵsetNgModuleScope","ɵb","ɵc","ɵd","ɵa","ɵe"],"sources":["C:/Users/Marc/source/repos/QuoteCalc/UI/angular14-quoteCalc-API/node_modules/@angular-slider/ngx-slider/__ivy_ngcc__/fesm2015/angular-slider-ngx-slider.js"],"sourcesContent":["import { Subject } from 'rxjs';\nimport { throttleTime, tap, distinctUntilChanged, filter } from 'rxjs/operators';\nimport { supportsPassiveEvents } from 'detect-passive-events';\nimport { Directive, ElementRef, Renderer2, HostBinding, ChangeDetectorRef, Component, ViewChild, HostListener, Input, EventEmitter, Output, ContentChild, forwardRef, NgZone, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @enum {number} */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nconst _c0 = [\"tooltipTemplate\"];\nconst _c1 = [\"leftOuterSelectionBar\"];\nconst _c2 = [\"rightOuterSelectionBar\"];\nconst _c3 = [\"fullBar\"];\nconst _c4 = [\"selectionBar\"];\nconst _c5 = [\"minHandle\"];\nconst _c6 = [\"maxHandle\"];\nconst _c7 = [\"floorLabel\"];\nconst _c8 = [\"ceilLabel\"];\nconst _c9 = [\"minHandleLabel\"];\nconst _c10 = [\"maxHandleLabel\"];\nconst _c11 = [\"combinedLabel\"];\nconst _c12 = [\"ticksElement\"];\nfunction SliderComponent_span_28_ngx_slider_tooltip_wrapper_2_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"ngx-slider-tooltip-wrapper\", 31);\n} if (rf & 2) {\n    const t_r13 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r14 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"template\", ctx_r14.tooltipTemplate)(\"tooltip\", t_r13.valueTooltip)(\"placement\", t_r13.valueTooltipPlacement)(\"content\", t_r13.value);\n} }\nfunction SliderComponent_span_28_span_3_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 32);\n} if (rf & 2) {\n    const t_r13 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵproperty(\"innerHTML\", t_r13.legend, ɵngcc0.ɵɵsanitizeHtml);\n} }\nconst _c13 = function (a0) { return { \"ngx-slider-selected\": a0 }; };\nfunction SliderComponent_span_28_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 27);\n    ɵngcc0.ɵɵelement(1, \"ngx-slider-tooltip-wrapper\", 28);\n    ɵngcc0.ɵɵtemplate(2, SliderComponent_span_28_ngx_slider_tooltip_wrapper_2_Template, 1, 4, \"ngx-slider-tooltip-wrapper\", 29);\n    ɵngcc0.ɵɵtemplate(3, SliderComponent_span_28_span_3_Template, 1, 1, \"span\", 30);\n    ɵngcc0.ɵɵelementEnd();\n} if (rf & 2) {\n    const t_r13 = ctx.$implicit;\n    const ctx_r12 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(7, _c13, t_r13.selected))(\"ngStyle\", t_r13.style);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"template\", ctx_r12.tooltipTemplate)(\"tooltip\", t_r13.tooltip)(\"placement\", t_r13.tooltipPlacement);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", t_r13.value != null);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", t_r13.legend != null);\n} }\nfunction TooltipWrapperComponent_ng_container_0_1_ng_template_0_Template(rf, ctx) { }\nfunction TooltipWrapperComponent_ng_container_0_1_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, TooltipWrapperComponent_ng_container_0_1_ng_template_0_Template, 0, 0, \"ng-template\");\n} }\nconst _c14 = function (a0, a1, a2) { return { tooltip: a0, placement: a1, content: a2 }; };\nfunction TooltipWrapperComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TooltipWrapperComponent_ng_container_0_1_Template, 1, 0, null, 1);\n    ɵngcc0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction3(2, _c14, ctx_r0.tooltip, ctx_r0.placement, ctx_r0.content));\n} }\nfunction TooltipWrapperComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"div\", 2);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"title\", ctx_r1.tooltip)(\"data-tooltip-placement\", ctx_r1.placement);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r1.content, \" \");\n} }\nconst LabelType = {\n    /** Label above low pointer */\n    Low: 0,\n    /** Label above high pointer */\n    High: 1,\n    /** Label for minimum slider value */\n    Floor: 2,\n    /** Label for maximum slider value */\n    Ceil: 3,\n    /** Label below legend tick */\n    TickValue: 4,\n};\nLabelType[LabelType.Low] = 'Low';\nLabelType[LabelType.High] = 'High';\nLabelType[LabelType.Floor] = 'Floor';\nLabelType[LabelType.Ceil] = 'Ceil';\nLabelType[LabelType.TickValue] = 'TickValue';\n/**\n * Slider options\n */\nclass Options {\n    constructor() {\n        /**\n         * Minimum value for a slider.\n         * Not applicable when using stepsArray.\n         */\n        this.floor = 0;\n        /**\n         * Maximum value for a slider.\n         * Not applicable when using stepsArray.\n         */\n        this.ceil = null;\n        /**\n         * Step between each value.\n         * Not applicable when using stepsArray.\n         */\n        this.step = 1;\n        /**\n         * The minimum range authorized on the slider.\n         * Applies to range slider only.\n         * When using stepsArray, expressed as index into stepsArray.\n         */\n        this.minRange = null;\n        /**\n         * The maximum range authorized on the slider.\n         * Applies to range slider only.\n         * When using stepsArray, expressed as index into stepsArray.\n         */\n        this.maxRange = null;\n        /**\n         * Set to true to have a push behavior. When the min handle goes above the max,\n         * the max is moved as well (and vice-versa). The range between min and max is\n         * defined by the step option (defaults to 1) and can also be overriden by\n         * the minRange option. Applies to range slider only.\n         */\n        this.pushRange = false;\n        /**\n         * The minimum value authorized on the slider.\n         * When using stepsArray, expressed as index into stepsArray.\n         */\n        this.minLimit = null;\n        /**\n         * The maximum value authorized on the slider.\n         * When using stepsArray, expressed as index into stepsArray.\n         */\n        this.maxLimit = null;\n        /**\n         * Custom translate function. Use this if you want to translate values displayed\n         * on the slider.\n         */\n        this.translate = null;\n        /**\n         * Custom function for combining overlapping labels in range slider.\n         * It takes the min and max values (already translated with translate fuction)\n         * and should return how these two values should be combined.\n         * If not provided, the default function will join the two values with\n         * ' - ' as separator.\n         */\n        this.combineLabels = null;\n        /**\n         * Use to display legend under ticks (thus, it needs to be used along with\n         * showTicks or showTicksValues). The function will be called with each tick\n         * value and returned content will be displayed under the tick as a legend.\n         * If the returned value is null, then no legend is displayed under\n         * the corresponding tick.You can also directly provide the legend values\n         * in the stepsArray option.\n         */\n        this.getLegend = null;\n        /**\n         * Use to display a custom legend of a stepItem from stepsArray.\n         * It will be the same as getLegend but for stepsArray.\n         */\n        this.getStepLegend = null;\n        /**\n         * If you want to display a slider with non linear/number steps.\n         * Just pass an array with each slider value and that's it; the floor, ceil and step settings\n         * of the slider will be computed automatically.\n         * By default, the value model and valueHigh model values will be the value of the selected item\n         * in the stepsArray.\n         * They can also be bound to the index of the selected item by setting the bindIndexForStepsArray\n         * option to true.\n         */\n        this.stepsArray = null;\n        /**\n         * Set to true to bind the index of the selected item to value model and valueHigh model.\n         */\n        this.bindIndexForStepsArray = false;\n        /**\n         * When set to true and using a range slider, the range can be dragged by the selection bar.\n         * Applies to range slider only.\n         */\n        this.draggableRange = false;\n        /**\n         * Same as draggableRange but the slider range can't be changed.\n         * Applies to range slider only.\n         */\n        this.draggableRangeOnly = false;\n        /**\n         * Set to true to always show the selection bar before the slider handle.\n         */\n        this.showSelectionBar = false;\n        /**\n         * Set to true to always show the selection bar after the slider handle.\n         */\n        this.showSelectionBarEnd = false;\n        /**\n         * Set a number to draw the selection bar between this value and the slider handle.\n         * When using stepsArray, expressed as index into stepsArray.\n         */\n        this.showSelectionBarFromValue = null;\n        /**\n         * Only for range slider. Set to true to visualize in different colour the areas\n         * on the left/right (top/bottom for vertical range slider) of selection bar between the handles.\n         */\n        this.showOuterSelectionBars = false;\n        /**\n         * Set to true to hide pointer labels\n         */\n        this.hidePointerLabels = false;\n        /**\n         * Set to true to hide min / max labels\n         */\n        this.hideLimitLabels = false;\n        /**\n         * Set to false to disable the auto-hiding behavior of the limit labels.\n         */\n        this.autoHideLimitLabels = true;\n        /**\n         * Set to true to make the slider read-only.\n         */\n        this.readOnly = false;\n        /**\n         * Set to true to disable the slider.\n         */\n        this.disabled = false;\n        /**\n         * Set to true to display a tick for each step of the slider.\n         */\n        this.showTicks = false;\n        /**\n         * Set to true to display a tick and the step value for each step of the slider..\n         */\n        this.showTicksValues = false;\n        /* The step between each tick to display. If not set, the step value is used.\n            Not used when ticksArray is specified. */\n        this.tickStep = null;\n        /* The step between displaying each tick step value.\n            If not set, then tickStep or step is used, depending on which one is set. */\n        this.tickValueStep = null;\n        /**\n         * Use to display ticks at specific positions.\n         * The array contains the index of the ticks that should be displayed.\n         * For example, [0, 1, 5] will display a tick for the first, second and sixth values.\n         */\n        this.ticksArray = null;\n        /**\n         * Used to display a tooltip when a tick is hovered.\n         * Set to a function that returns the tooltip content for a given value.\n         */\n        this.ticksTooltip = null;\n        /**\n         * Same as ticksTooltip but for ticks values.\n         */\n        this.ticksValuesTooltip = null;\n        /**\n         * Set to true to display the slider vertically.\n         * The slider will take the full height of its parent.\n         * Changing this value at runtime is not currently supported.\n         */\n        this.vertical = false;\n        /**\n         * Function that returns the current color of the selection bar.\n         * If your color won't change, don't use this option but set it through CSS.\n         * If the returned color depends on a model value (either value or valueHigh),\n         * you should use the argument passed to the function.\n         * Indeed, when the function is called, there is no certainty that the model\n         * has already been updated.\n         */\n        this.getSelectionBarColor = null;\n        /**\n         * Function that returns the color of a tick. showTicks must be enabled.\n         */\n        this.getTickColor = null;\n        /**\n         * Function that returns the current color of a pointer.\n         * If your color won't change, don't use this option but set it through CSS.\n         * If the returned color depends on a model value (either value or valueHigh),\n         * you should use the argument passed to the function.\n         * Indeed, when the function is called, there is no certainty that the model has already been updated.\n         * To handle range slider pointers independently, you should evaluate pointerType within the given\n         * function where \"min\" stands for value model and \"max\" for valueHigh model values.\n         */\n        this.getPointerColor = null;\n        /**\n         * Handles are focusable (on click or with tab) and can be modified using the following keyboard controls:\n         * Left/bottom arrows: -1\n         * Right/top arrows: +1\n         * Page-down: -10%\n         * Page-up: +10%\n         * Home: minimum value\n         * End: maximum value\n         */\n        this.keyboardSupport = true;\n        /**\n         * If you display the slider in an element that uses transform: scale(0.5), set the scale value to 2\n         * so that the slider is rendered properly and the events are handled correctly.\n         */\n        this.scale = 1;\n        /**\n         * If you display the slider in an element that uses transform: rotate(90deg), set the rotate value to 90\n         * so that the slider is rendered properly and the events are handled correctly. Value is in degrees.\n         */\n        this.rotate = 0;\n        /**\n         * Set to true to force the value(s) to be rounded to the step, even when modified from the outside.\n         * When set to false, if the model values are modified from outside the slider, they are not rounded\n         * and can be between two steps.\n         */\n        this.enforceStep = true;\n        /**\n         * Set to true to force the value(s) to be normalised to allowed range (floor to ceil), even when modified from the outside.\n         * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,\n         * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.\n         */\n        this.enforceRange = true;\n        /**\n         * Set to true to force the value(s) to be rounded to the nearest step value, even when modified from the outside.\n         * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,\n         * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.\n         */\n        this.enforceStepsArray = true;\n        /**\n         * Set to true to prevent to user from switching the min and max handles. Applies to range slider only.\n         */\n        this.noSwitching = false;\n        /**\n         * Set to true to only bind events on slider handles.\n         */\n        this.onlyBindHandles = false;\n        /**\n         * Set to true to show graphs right to left.\n         * If vertical is true it will be from top to bottom and left / right arrow functions reversed.\n         */\n        this.rightToLeft = false;\n        /**\n         * Set to true to reverse keyboard navigation:\n         * Right/top arrows: -1\n         * Left/bottom arrows: +1\n         * Page-up: -10%\n         * Page-down: +10%\n         * End: minimum value\n         * Home: maximum value\n         */\n        this.reversedControls = false;\n        /**\n         * Set to true to keep the slider labels inside the slider bounds.\n         */\n        this.boundPointerLabels = true;\n        /**\n         * Set to true to use a logarithmic scale to display the slider.\n         */\n        this.logScale = false;\n        /**\n         * Function that returns the position on the slider for a given value.\n         * The position must be a percentage between 0 and 1.\n         * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.\n         */\n        this.customValueToPosition = null;\n        /**\n         * Function that returns the value for a given position on the slider.\n         * The position is a percentage between 0 and 1.\n         * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.\n         */\n        this.customPositionToValue = null;\n        /**\n         * Precision limit for calculated values.\n         * Values used in calculations will be rounded to this number of significant digits\n         * to prevent accumulating small floating-point errors.\n         */\n        this.precisionLimit = 12;\n        /**\n         * Use to display the selection bar as a gradient.\n         * The given object must contain from and to properties which are colors.\n         */\n        this.selectionBarGradient = null;\n        /**\n         * Use to add a label directly to the slider for accessibility. Adds the aria-label attribute.\n         */\n        this.ariaLabel = 'ngx-slider';\n        /**\n         * Use instead of ariaLabel to reference the id of an element which will be used to label the slider.\n         * Adds the aria-labelledby attribute.\n         */\n        this.ariaLabelledBy = null;\n        /**\n         * Use to add a label directly to the slider range for accessibility. Adds the aria-label attribute.\n         */\n        this.ariaLabelHigh = 'ngx-slider-max';\n        /**\n         * Use instead of ariaLabelHigh to reference the id of an element which will be used to label the slider range.\n         * Adds the aria-labelledby attribute.\n         */\n        this.ariaLabelledByHigh = null;\n        /**\n         * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the handle\n         */\n        this.handleDimension = null;\n        /**\n         * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the bar\n         */\n        this.barDimension = null;\n        /**\n         * Enable/disable CSS animations\n         */\n        this.animate = true;\n        /**\n         * Enable/disable CSS animations while moving the slider\n         */\n        this.animateOnMove = false;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @enum {number} */\nconst PointerType = {\n    /** Low pointer */\n    Min: 0,\n    /** High pointer */\n    Max: 1,\n};\nPointerType[PointerType.Min] = 'Min';\nPointerType[PointerType.Max] = 'Max';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nclass ChangeContext {\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n *  Collection of functions to handle conversions/lookups of values\n */\nclass ValueHelper {\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    static isNullOrUndefined(value) {\n        return value === undefined || value === null;\n    }\n    /**\n     * @param {?} array1\n     * @param {?} array2\n     * @return {?}\n     */\n    static areArraysEqual(array1, array2) {\n        if (array1.length !== array2.length) {\n            return false;\n        }\n        for (let i = 0; i < array1.length; ++i) {\n            if (array1[i] !== array2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * @param {?} val\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n    static linearValueToPosition(val, minVal, maxVal) {\n        /** @type {?} */\n        const range = maxVal - minVal;\n        return (val - minVal) / range;\n    }\n    /**\n     * @param {?} val\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n    static logValueToPosition(val, minVal, maxVal) {\n        val = Math.log(val);\n        minVal = Math.log(minVal);\n        maxVal = Math.log(maxVal);\n        /** @type {?} */\n        const range = maxVal - minVal;\n        return (val - minVal) / range;\n    }\n    /**\n     * @param {?} percent\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n    static linearPositionToValue(percent, minVal, maxVal) {\n        return percent * (maxVal - minVal) + minVal;\n    }\n    /**\n     * @param {?} percent\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n    static logPositionToValue(percent, minVal, maxVal) {\n        minVal = Math.log(minVal);\n        maxVal = Math.log(maxVal);\n        /** @type {?} */\n        const value = percent * (maxVal - minVal) + minVal;\n        return Math.exp(value);\n    }\n    /**\n     * @param {?} modelValue\n     * @param {?} stepsArray\n     * @return {?}\n     */\n    static findStepIndex(modelValue, stepsArray) {\n        /** @type {?} */\n        const differences = stepsArray.map((step) => Math.abs(modelValue - step.value));\n        /** @type {?} */\n        let minDifferenceIndex = 0;\n        for (let index = 0; index < stepsArray.length; index++) {\n            if (differences[index] !== differences[minDifferenceIndex] && differences[index] < differences[minDifferenceIndex]) {\n                minDifferenceIndex = index;\n            }\n        }\n        return minDifferenceIndex;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Helper with compatibility functions to support different browsers\n */\nclass CompatibilityHelper {\n    /**\n     * Workaround for TouchEvent constructor sadly not being available on all browsers (e.g. Firefox, Safari)\n     * @param {?} event\n     * @return {?}\n     */\n    static isTouchEvent(event) {\n        if ((/** @type {?} */ (window)).TouchEvent !== undefined) {\n            return event instanceof TouchEvent;\n        }\n        return event.touches !== undefined;\n    }\n    /**\n     * Detect presence of ResizeObserver API\n     * @return {?}\n     */\n    static isResizeObserverAvailable() {\n        return (/** @type {?} */ (window)).ResizeObserver !== undefined;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Helper with mathematical functions\n */\nclass MathHelper {\n    /**\n     * @param {?} value\n     * @param {?} precisionLimit\n     * @return {?}\n     */\n    static roundToPrecisionLimit(value, precisionLimit) {\n        return +(value.toPrecision(precisionLimit));\n    }\n    /**\n     * @param {?} value\n     * @param {?} modulo\n     * @param {?} precisionLimit\n     * @return {?}\n     */\n    static isModuloWithinPrecisionLimit(value, modulo, precisionLimit) {\n        /** @type {?} */\n        const limit = Math.pow(10, -precisionLimit);\n        return Math.abs(value % modulo) <= limit || Math.abs(Math.abs(value % modulo) - modulo) <= limit;\n    }\n    /**\n     * @param {?} value\n     * @param {?} floor\n     * @param {?} ceil\n     * @return {?}\n     */\n    static clampToRange(value, floor, ceil) {\n        return Math.min(Math.max(value, floor), ceil);\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nclass EventListener {\n    constructor() {\n        this.eventName = null;\n        this.events = null;\n        this.eventsSubscription = null;\n        this.teardownCallback = null;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Helper class to attach event listeners to DOM elements with debounce support using rxjs\n */\nclass EventListenerHelper {\n    /**\n     * @param {?} renderer\n     */\n    constructor(renderer) {\n        this.renderer = renderer;\n    }\n    /**\n     * @param {?} nativeElement\n     * @param {?} eventName\n     * @param {?} callback\n     * @param {?=} throttleInterval\n     * @return {?}\n     */\n    attachPassiveEventListener(nativeElement, eventName, callback, throttleInterval) {\n        // Only use passive event listeners if the browser supports it\n        if (supportsPassiveEvents !== true) {\n            return this.attachEventListener(nativeElement, eventName, callback, throttleInterval);\n        }\n        /** @type {?} */\n        const listener = new EventListener();\n        listener.eventName = eventName;\n        listener.events = new Subject();\n        /** @type {?} */\n        const observerCallback = (event) => {\n            listener.events.next(event);\n        };\n        nativeElement.addEventListener(eventName, observerCallback, { passive: true, capture: false });\n        listener.teardownCallback = () => {\n            nativeElement.removeEventListener(eventName, observerCallback, { passive: true, capture: false });\n        };\n        listener.eventsSubscription = listener.events\n            .pipe((!ValueHelper.isNullOrUndefined(throttleInterval))\n            ? throttleTime(throttleInterval, undefined, { leading: true, trailing: true })\n            : tap(() => { }) // no-op\n        )\n            .subscribe((event) => {\n            callback(event);\n        });\n        return listener;\n    }\n    /**\n     * @param {?} eventListener\n     * @return {?}\n     */\n    detachEventListener(eventListener) {\n        if (!ValueHelper.isNullOrUndefined(eventListener.eventsSubscription)) {\n            eventListener.eventsSubscription.unsubscribe();\n            eventListener.eventsSubscription = null;\n        }\n        if (!ValueHelper.isNullOrUndefined(eventListener.events)) {\n            eventListener.events.complete();\n            eventListener.events = null;\n        }\n        if (!ValueHelper.isNullOrUndefined(eventListener.teardownCallback)) {\n            eventListener.teardownCallback();\n            eventListener.teardownCallback = null;\n        }\n    }\n    /**\n     * @param {?} nativeElement\n     * @param {?} eventName\n     * @param {?} callback\n     * @param {?=} throttleInterval\n     * @return {?}\n     */\n    attachEventListener(nativeElement, eventName, callback, throttleInterval) {\n        /** @type {?} */\n        const listener = new EventListener();\n        listener.eventName = eventName;\n        listener.events = new Subject();\n        /** @type {?} */\n        const observerCallback = (event) => {\n            listener.events.next(event);\n        };\n        listener.teardownCallback = this.renderer.listen(nativeElement, eventName, observerCallback);\n        listener.eventsSubscription = listener.events\n            .pipe((!ValueHelper.isNullOrUndefined(throttleInterval))\n            ? throttleTime(throttleInterval, undefined, { leading: true, trailing: true })\n            : tap(() => { }) // no-op\n        )\n            .subscribe((event) => { callback(event); });\n        return listener;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nclass SliderElementDirective {\n    /**\n     * @param {?} elemRef\n     * @param {?} renderer\n     * @param {?} changeDetectionRef\n     */\n    constructor(elemRef, renderer, changeDetectionRef) {\n        this.elemRef = elemRef;\n        this.renderer = renderer;\n        this.changeDetectionRef = changeDetectionRef;\n        this._position = 0;\n        this._dimension = 0;\n        this._alwaysHide = false;\n        this._vertical = false;\n        this._scale = 1;\n        this._rotate = 0;\n        this.opacity = 1;\n        this.visibility = 'visible';\n        this.left = '';\n        this.bottom = '';\n        this.height = '';\n        this.width = '';\n        this.transform = '';\n        this.eventListeners = [];\n        this.eventListenerHelper = new EventListenerHelper(this.renderer);\n    }\n    /**\n     * @return {?}\n     */\n    get position() {\n        return this._position;\n    }\n    /**\n     * @return {?}\n     */\n    get dimension() {\n        return this._dimension;\n    }\n    /**\n     * @return {?}\n     */\n    get alwaysHide() {\n        return this._alwaysHide;\n    }\n    /**\n     * @return {?}\n     */\n    get vertical() {\n        return this._vertical;\n    }\n    /**\n     * @return {?}\n     */\n    get scale() {\n        return this._scale;\n    }\n    /**\n     * @return {?}\n     */\n    get rotate() {\n        return this._rotate;\n    }\n    /**\n     * @param {?} hide\n     * @return {?}\n     */\n    setAlwaysHide(hide) {\n        this._alwaysHide = hide;\n        if (hide) {\n            this.visibility = 'hidden';\n        }\n        else {\n            this.visibility = 'visible';\n        }\n    }\n    /**\n     * @return {?}\n     */\n    hide() {\n        this.opacity = 0;\n    }\n    /**\n     * @return {?}\n     */\n    show() {\n        if (this.alwaysHide) {\n            return;\n        }\n        this.opacity = 1;\n    }\n    /**\n     * @return {?}\n     */\n    isVisible() {\n        if (this.alwaysHide) {\n            return false;\n        }\n        return this.opacity !== 0;\n    }\n    /**\n     * @param {?} vertical\n     * @return {?}\n     */\n    setVertical(vertical) {\n        this._vertical = vertical;\n        if (this._vertical) {\n            this.left = '';\n            this.width = '';\n        }\n        else {\n            this.bottom = '';\n            this.height = '';\n        }\n    }\n    /**\n     * @param {?} scale\n     * @return {?}\n     */\n    setScale(scale) {\n        this._scale = scale;\n    }\n    /**\n     * @param {?} rotate\n     * @return {?}\n     */\n    setRotate(rotate) {\n        this._rotate = rotate;\n        this.transform = 'rotate(' + rotate + 'deg)';\n    }\n    /**\n     * @return {?}\n     */\n    getRotate() {\n        return this._rotate;\n    }\n    /**\n     * @param {?} pos\n     * @return {?}\n     */\n    setPosition(pos) {\n        if (this._position !== pos && !this.isRefDestroyed()) {\n            this.changeDetectionRef.markForCheck();\n        }\n        this._position = pos;\n        if (this._vertical) {\n            this.bottom = Math.round(pos) + 'px';\n        }\n        else {\n            this.left = Math.round(pos) + 'px';\n        }\n    }\n    /**\n     * @return {?}\n     */\n    calculateDimension() {\n        /** @type {?} */\n        const val = this.getBoundingClientRect();\n        if (this.vertical) {\n            this._dimension = (val.bottom - val.top) * this.scale;\n        }\n        else {\n            this._dimension = (val.right - val.left) * this.scale;\n        }\n    }\n    /**\n     * @param {?} dim\n     * @return {?}\n     */\n    setDimension(dim) {\n        if (this._dimension !== dim && !this.isRefDestroyed()) {\n            this.changeDetectionRef.markForCheck();\n        }\n        this._dimension = dim;\n        if (this._vertical) {\n            this.height = Math.round(dim) + 'px';\n        }\n        else {\n            this.width = Math.round(dim) + 'px';\n        }\n    }\n    /**\n     * @return {?}\n     */\n    getBoundingClientRect() {\n        return this.elemRef.nativeElement.getBoundingClientRect();\n    }\n    /**\n     * @param {?} eventName\n     * @param {?} callback\n     * @param {?=} debounceInterval\n     * @return {?}\n     */\n    on(eventName, callback, debounceInterval) {\n        /** @type {?} */\n        const listener = this.eventListenerHelper.attachEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);\n        this.eventListeners.push(listener);\n    }\n    /**\n     * @param {?} eventName\n     * @param {?} callback\n     * @param {?=} debounceInterval\n     * @return {?}\n     */\n    onPassive(eventName, callback, debounceInterval) {\n        /** @type {?} */\n        const listener = this.eventListenerHelper.attachPassiveEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);\n        this.eventListeners.push(listener);\n    }\n    /**\n     * @param {?=} eventName\n     * @return {?}\n     */\n    off(eventName) {\n        /** @type {?} */\n        let listenersToKeep;\n        /** @type {?} */\n        let listenersToRemove;\n        if (!ValueHelper.isNullOrUndefined(eventName)) {\n            listenersToKeep = this.eventListeners.filter((event) => event.eventName !== eventName);\n            listenersToRemove = this.eventListeners.filter((event) => event.eventName === eventName);\n        }\n        else {\n            listenersToKeep = [];\n            listenersToRemove = this.eventListeners;\n        }\n        for (const listener of listenersToRemove) {\n            this.eventListenerHelper.detachEventListener(listener);\n        }\n        this.eventListeners = listenersToKeep;\n    }\n    /**\n     * @return {?}\n     */\n    isRefDestroyed() {\n        return ValueHelper.isNullOrUndefined(this.changeDetectionRef) || this.changeDetectionRef['destroyed'];\n    }\n}\nSliderElementDirective.ɵfac = function SliderElementDirective_Factory(t) { return new (t || SliderElementDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };\nSliderElementDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: SliderElementDirective, selectors: [[\"\", \"ngxSliderElement\", \"\"]], hostVars: 14, hostBindings: function SliderElementDirective_HostBindings(rf, ctx) { if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"opacity\", ctx.opacity)(\"visibility\", ctx.visibility)(\"left\", ctx.left)(\"bottom\", ctx.bottom)(\"height\", ctx.height)(\"width\", ctx.width)(\"transform\", ctx.transform);\n    } } });\n/** @nocollapse */\nSliderElementDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: ChangeDetectorRef }\n];\nSliderElementDirective.propDecorators = {\n    opacity: [{ type: HostBinding, args: ['style.opacity',] }],\n    visibility: [{ type: HostBinding, args: ['style.visibility',] }],\n    left: [{ type: HostBinding, args: ['style.left',] }],\n    bottom: [{ type: HostBinding, args: ['style.bottom',] }],\n    height: [{ type: HostBinding, args: ['style.height',] }],\n    width: [{ type: HostBinding, args: ['style.width',] }],\n    transform: [{ type: HostBinding, args: ['style.transform',] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderElementDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxSliderElement]'\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { opacity: [{\n            type: HostBinding,\n            args: ['style.opacity']\n        }], visibility: [{\n            type: HostBinding,\n            args: ['style.visibility']\n        }], left: [{\n            type: HostBinding,\n            args: ['style.left']\n        }], bottom: [{\n            type: HostBinding,\n            args: ['style.bottom']\n        }], height: [{\n            type: HostBinding,\n            args: ['style.height']\n        }], width: [{\n            type: HostBinding,\n            args: ['style.width']\n        }], transform: [{\n            type: HostBinding,\n            args: ['style.transform']\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nclass SliderHandleDirective extends SliderElementDirective {\n    /**\n     * @param {?} elemRef\n     * @param {?} renderer\n     * @param {?} changeDetectionRef\n     */\n    constructor(elemRef, renderer, changeDetectionRef) {\n        super(elemRef, renderer, changeDetectionRef);\n        this.active = false;\n        this.role = '';\n        this.tabindex = '';\n        this.ariaOrientation = '';\n        this.ariaLabel = '';\n        this.ariaLabelledBy = '';\n        this.ariaValueNow = '';\n        this.ariaValueText = '';\n        this.ariaValueMin = '';\n        this.ariaValueMax = '';\n    }\n    /**\n     * @return {?}\n     */\n    focus() {\n        this.elemRef.nativeElement.focus();\n    }\n}\nSliderHandleDirective.ɵfac = function SliderHandleDirective_Factory(t) { return new (t || SliderHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };\nSliderHandleDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: SliderHandleDirective, selectors: [[\"\", \"ngxSliderHandle\", \"\"]], hostVars: 11, hostBindings: function SliderHandleDirective_HostBindings(rf, ctx) { if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"role\", ctx.role)(\"tabindex\", ctx.tabindex)(\"aria-orientation\", ctx.ariaOrientation)(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledBy)(\"aria-valuenow\", ctx.ariaValueNow)(\"aria-valuetext\", ctx.ariaValueText)(\"aria-valuemin\", ctx.ariaValueMin)(\"aria-valuemax\", ctx.ariaValueMax);\n        ɵngcc0.ɵɵclassProp(\"ngx-slider-active\", ctx.active);\n    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nSliderHandleDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: ChangeDetectorRef }\n];\nSliderHandleDirective.propDecorators = {\n    active: [{ type: HostBinding, args: ['class.ngx-slider-active',] }],\n    role: [{ type: HostBinding, args: ['attr.role',] }],\n    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],\n    ariaOrientation: [{ type: HostBinding, args: ['attr.aria-orientation',] }],\n    ariaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],\n    ariaLabelledBy: [{ type: HostBinding, args: ['attr.aria-labelledby',] }],\n    ariaValueNow: [{ type: HostBinding, args: ['attr.aria-valuenow',] }],\n    ariaValueText: [{ type: HostBinding, args: ['attr.aria-valuetext',] }],\n    ariaValueMin: [{ type: HostBinding, args: ['attr.aria-valuemin',] }],\n    ariaValueMax: [{ type: HostBinding, args: ['attr.aria-valuemax',] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderHandleDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxSliderHandle]'\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { active: [{\n            type: HostBinding,\n            args: ['class.ngx-slider-active']\n        }], role: [{\n            type: HostBinding,\n            args: ['attr.role']\n        }], tabindex: [{\n            type: HostBinding,\n            args: ['attr.tabindex']\n        }], ariaOrientation: [{\n            type: HostBinding,\n            args: ['attr.aria-orientation']\n        }], ariaLabel: [{\n            type: HostBinding,\n            args: ['attr.aria-label']\n        }], ariaLabelledBy: [{\n            type: HostBinding,\n            args: ['attr.aria-labelledby']\n        }], ariaValueNow: [{\n            type: HostBinding,\n            args: ['attr.aria-valuenow']\n        }], ariaValueText: [{\n            type: HostBinding,\n            args: ['attr.aria-valuetext']\n        }], ariaValueMin: [{\n            type: HostBinding,\n            args: ['attr.aria-valuemin']\n        }], ariaValueMax: [{\n            type: HostBinding,\n            args: ['attr.aria-valuemax']\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nclass SliderLabelDirective extends SliderElementDirective {\n    /**\n     * @param {?} elemRef\n     * @param {?} renderer\n     * @param {?} changeDetectionRef\n     */\n    constructor(elemRef, renderer, changeDetectionRef) {\n        super(elemRef, renderer, changeDetectionRef);\n        this._value = null;\n    }\n    /**\n     * @return {?}\n     */\n    get value() {\n        return this._value;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    setValue(value) {\n        /** @type {?} */\n        let recalculateDimension = false;\n        if (!this.alwaysHide &&\n            (ValueHelper.isNullOrUndefined(this.value) ||\n                this.value.length !== value.length ||\n                (this.value.length > 0 && this.dimension === 0))) {\n            recalculateDimension = true;\n        }\n        this._value = value;\n        this.elemRef.nativeElement.innerHTML = value;\n        // Update dimension only when length of the label have changed\n        if (recalculateDimension) {\n            this.calculateDimension();\n        }\n    }\n}\nSliderLabelDirective.ɵfac = function SliderLabelDirective_Factory(t) { return new (t || SliderLabelDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };\nSliderLabelDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: SliderLabelDirective, selectors: [[\"\", \"ngxSliderLabel\", \"\"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nSliderLabelDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: ChangeDetectorRef }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderLabelDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxSliderLabel]'\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nclass Tick {\n    constructor() {\n        this.selected = false;\n        this.style = {};\n        this.tooltip = null;\n        this.tooltipPlacement = null;\n        this.value = null;\n        this.valueTooltip = null;\n        this.valueTooltipPlacement = null;\n        this.legend = null;\n    }\n}\nclass Dragging {\n    constructor() {\n        this.active = false;\n        this.value = 0;\n        this.difference = 0;\n        this.position = 0;\n        this.lowLimit = 0;\n        this.highLimit = 0;\n    }\n}\nclass ModelValues {\n    /**\n     * @param {?=} x\n     * @param {?=} y\n     * @return {?}\n     */\n    static compare(x, y) {\n        if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n            return false;\n        }\n        if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n            return false;\n        }\n        return x.value === y.value && x.highValue === y.highValue;\n    }\n}\nclass ModelChange extends ModelValues {\n    /**\n     * @param {?=} x\n     * @param {?=} y\n     * @return {?}\n     */\n    static compare(x, y) {\n        if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n            return false;\n        }\n        if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n            return false;\n        }\n        return x.value === y.value &&\n            x.highValue === y.highValue &&\n            x.forceChange === y.forceChange;\n    }\n}\n/** @type {?} */\nconst NGX_SLIDER_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    /* tslint:disable-next-line: no-use-before-declare */\n    useExisting: forwardRef(() => SliderComponent),\n    multi: true,\n};\nclass SliderComponent {\n    /**\n     * @param {?} renderer\n     * @param {?} elementRef\n     * @param {?} changeDetectionRef\n     * @param {?} zone\n     */\n    constructor(renderer, elementRef, changeDetectionRef, zone) {\n        this.renderer = renderer;\n        this.elementRef = elementRef;\n        this.changeDetectionRef = changeDetectionRef;\n        this.zone = zone;\n        // Model for low value of slider. For simple slider, this is the only input. For range slider, this is the low value.\n        this.value = null;\n        // Output for low value slider to support two-way bindings\n        this.valueChange = new EventEmitter();\n        // Model for high value of slider. Not used in simple slider. For range slider, this is the high value.\n        this.highValue = null;\n        // Output for high value slider to support two-way bindings\n        this.highValueChange = new EventEmitter();\n        // An object with all the other options of the slider.\n        // Each option can be updated at runtime and the slider will automatically be re-rendered.\n        this.options = new Options();\n        // Event emitted when user starts interaction with the slider\n        this.userChangeStart = new EventEmitter();\n        // Event emitted on each change coming from user interaction\n        this.userChange = new EventEmitter();\n        // Event emitted when user finishes interaction with the slider\n        this.userChangeEnd = new EventEmitter();\n        this.initHasRun = false;\n        this.inputModelChangeSubject = new Subject();\n        this.inputModelChangeSubscription = null;\n        this.outputModelChangeSubject = new Subject();\n        this.outputModelChangeSubscription = null;\n        this.viewLowValue = null;\n        this.viewHighValue = null;\n        this.viewOptions = new Options();\n        this.handleHalfDimension = 0;\n        this.maxHandlePosition = 0;\n        this.currentTrackingPointer = null;\n        this.currentFocusPointer = null;\n        this.firstKeyDown = false;\n        this.touchId = null;\n        this.dragging = new Dragging();\n        // Host element class bindings\n        this.sliderElementVerticalClass = false;\n        this.sliderElementAnimateClass = false;\n        this.sliderElementWithLegendClass = false;\n        this.sliderElementDisabledAttr = null;\n        this.sliderElementAriaLabel = 'ngx-slider';\n        this.barStyle = {};\n        this.minPointerStyle = {};\n        this.maxPointerStyle = {};\n        this.fullBarTransparentClass = false;\n        this.selectionBarDraggableClass = false;\n        this.ticksUnderValuesClass = false;\n        this.intermediateTicks = false;\n        this.ticks = [];\n        this.eventListenerHelper = null;\n        this.onMoveEventListener = null;\n        this.onEndEventListener = null;\n        this.moving = false;\n        this.resizeObserver = null;\n        this.onTouchedCallback = null;\n        this.onChangeCallback = null;\n        this.eventListenerHelper = new EventListenerHelper(this.renderer);\n    }\n    /**\n     * @param {?} manualRefresh\n     * @return {?}\n     */\n    set manualRefresh(manualRefresh) {\n        this.unsubscribeManualRefresh();\n        this.manualRefreshSubscription = manualRefresh.subscribe(() => {\n            setTimeout(() => this.calculateViewDimensionsAndDetectChanges());\n        });\n    }\n    /**\n     * @param {?} triggerFocus\n     * @return {?}\n     */\n    set triggerFocus(triggerFocus) {\n        this.unsubscribeTriggerFocus();\n        this.triggerFocusSubscription = triggerFocus.subscribe((pointerType) => {\n            this.focusPointer(pointerType);\n        });\n    }\n    /**\n     * @return {?}\n     */\n    get range() {\n        return !ValueHelper.isNullOrUndefined(this.value) && !ValueHelper.isNullOrUndefined(this.highValue);\n    }\n    /**\n     * @return {?}\n     */\n    get showTicks() {\n        return this.viewOptions.showTicks;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this.viewOptions = new Options();\n        Object.assign(this.viewOptions, this.options);\n        // We need to run these two things first, before the rest of the init in ngAfterViewInit(),\n        // because these two settings are set through @HostBinding and Angular change detection\n        // mechanism doesn't like them changing in ngAfterViewInit()\n        this.updateDisabledState();\n        this.updateVerticalState();\n        this.updateAriaLabel();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        this.applyOptions();\n        this.subscribeInputModelChangeSubject();\n        this.subscribeOutputModelChangeSubject();\n        // Once we apply options, we need to normalise model values for the first time\n        this.renormaliseModelValues();\n        this.viewLowValue = this.modelValueToViewValue(this.value);\n        if (this.range) {\n            this.viewHighValue = this.modelValueToViewValue(this.highValue);\n        }\n        else {\n            this.viewHighValue = null;\n        }\n        this.updateVerticalState(); // need to run this again to cover changes to slider elements\n        this.manageElementsStyle();\n        this.updateDisabledState();\n        this.calculateViewDimensions();\n        this.addAccessibility();\n        this.updateCeilLabel();\n        this.updateFloorLabel();\n        this.initHandles();\n        this.manageEventsBindings();\n        this.updateAriaLabel();\n        this.subscribeResizeObserver();\n        this.initHasRun = true;\n        // Run change detection manually to resolve some issues when init procedure changes values used in the view\n        if (!this.isRefDestroyed()) {\n            this.changeDetectionRef.detectChanges();\n        }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        // Always apply options first\n        if (!ValueHelper.isNullOrUndefined(changes[\"options\"]) &&\n            JSON.stringify(changes[\"options\"].previousValue) !== JSON.stringify(changes[\"options\"].currentValue)) {\n            this.onChangeOptions();\n        }\n        // Then value changes\n        if (!ValueHelper.isNullOrUndefined(changes[\"value\"]) ||\n            !ValueHelper.isNullOrUndefined(changes[\"highValue\"])) {\n            this.inputModelChangeSubject.next({\n                value: this.value,\n                highValue: this.highValue,\n                forceChange: false,\n                internalChange: false\n            });\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.unbindEvents();\n        this.unsubscribeResizeObserver();\n        this.unsubscribeInputModelChangeSubject();\n        this.unsubscribeOutputModelChangeSubject();\n        this.unsubscribeManualRefresh();\n        this.unsubscribeTriggerFocus();\n    }\n    /**\n     * @param {?} obj\n     * @return {?}\n     */\n    writeValue(obj) {\n        if (obj instanceof Array) {\n            this.value = obj[0];\n            this.highValue = obj[1];\n        }\n        else {\n            this.value = obj;\n        }\n        // ngOnChanges() is not called in this instance, so we need to communicate the change manually\n        this.inputModelChangeSubject.next({\n            value: this.value,\n            highValue: this.highValue,\n            forceChange: false,\n            internalChange: false\n        });\n    }\n    /**\n     * @param {?} onChangeCallback\n     * @return {?}\n     */\n    registerOnChange(onChangeCallback) {\n        this.onChangeCallback = onChangeCallback;\n    }\n    /**\n     * @param {?} onTouchedCallback\n     * @return {?}\n     */\n    registerOnTouched(onTouchedCallback) {\n        this.onTouchedCallback = onTouchedCallback;\n    }\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    setDisabledState(isDisabled) {\n        this.viewOptions.disabled = isDisabled;\n        this.updateDisabledState();\n    }\n    /**\n     * @param {?} ariaLabel\n     * @return {?}\n     */\n    setAriaLabel(ariaLabel) {\n        this.viewOptions.ariaLabel = ariaLabel;\n        this.updateAriaLabel();\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    onResize(event) {\n        this.calculateViewDimensionsAndDetectChanges();\n    }\n    /**\n     * @return {?}\n     */\n    subscribeInputModelChangeSubject() {\n        this.inputModelChangeSubscription = this.inputModelChangeSubject\n            .pipe(distinctUntilChanged(ModelChange.compare), \n        // Hack to reset the status of the distinctUntilChanged() - if a \"fake\" event comes through with forceChange=true,\n        // we forcefully by-pass distinctUntilChanged(), but otherwise drop the event\n        filter((modelChange) => !modelChange.forceChange && !modelChange.internalChange))\n            .subscribe((modelChange) => this.applyInputModelChange(modelChange));\n    }\n    /**\n     * @return {?}\n     */\n    subscribeOutputModelChangeSubject() {\n        this.outputModelChangeSubscription = this.outputModelChangeSubject\n            .pipe(distinctUntilChanged(ModelChange.compare))\n            .subscribe((modelChange) => this.publishOutputModelChange(modelChange));\n    }\n    /**\n     * @return {?}\n     */\n    subscribeResizeObserver() {\n        if (CompatibilityHelper.isResizeObserverAvailable()) {\n            this.resizeObserver = new ResizeObserver(() => this.calculateViewDimensionsAndDetectChanges());\n            this.resizeObserver.observe(this.elementRef.nativeElement);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    unsubscribeResizeObserver() {\n        if (CompatibilityHelper.isResizeObserverAvailable() && this.resizeObserver !== null) {\n            this.resizeObserver.disconnect();\n            this.resizeObserver = null;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    unsubscribeOnMove() {\n        if (!ValueHelper.isNullOrUndefined(this.onMoveEventListener)) {\n            this.eventListenerHelper.detachEventListener(this.onMoveEventListener);\n            this.onMoveEventListener = null;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    unsubscribeOnEnd() {\n        if (!ValueHelper.isNullOrUndefined(this.onEndEventListener)) {\n            this.eventListenerHelper.detachEventListener(this.onEndEventListener);\n            this.onEndEventListener = null;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    unsubscribeInputModelChangeSubject() {\n        if (!ValueHelper.isNullOrUndefined(this.inputModelChangeSubscription)) {\n            this.inputModelChangeSubscription.unsubscribe();\n            this.inputModelChangeSubscription = null;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    unsubscribeOutputModelChangeSubject() {\n        if (!ValueHelper.isNullOrUndefined(this.outputModelChangeSubscription)) {\n            this.outputModelChangeSubscription.unsubscribe();\n            this.outputModelChangeSubscription = null;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    unsubscribeManualRefresh() {\n        if (!ValueHelper.isNullOrUndefined(this.manualRefreshSubscription)) {\n            this.manualRefreshSubscription.unsubscribe();\n            this.manualRefreshSubscription = null;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    unsubscribeTriggerFocus() {\n        if (!ValueHelper.isNullOrUndefined(this.triggerFocusSubscription)) {\n            this.triggerFocusSubscription.unsubscribe();\n            this.triggerFocusSubscription = null;\n        }\n    }\n    /**\n     * @param {?} pointerType\n     * @return {?}\n     */\n    getPointerElement(pointerType) {\n        if (pointerType === PointerType.Min) {\n            return this.minHandleElement;\n        }\n        else if (pointerType === PointerType.Max) {\n            return this.maxHandleElement;\n        }\n        return null;\n    }\n    /**\n     * @return {?}\n     */\n    getCurrentTrackingValue() {\n        if (this.currentTrackingPointer === PointerType.Min) {\n            return this.viewLowValue;\n        }\n        else if (this.currentTrackingPointer === PointerType.Max) {\n            return this.viewHighValue;\n        }\n        return null;\n    }\n    /**\n     * @param {?} modelValue\n     * @return {?}\n     */\n    modelValueToViewValue(modelValue) {\n        if (ValueHelper.isNullOrUndefined(modelValue)) {\n            return NaN;\n        }\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n            return ValueHelper.findStepIndex(+modelValue, this.viewOptions.stepsArray);\n        }\n        return +modelValue;\n    }\n    /**\n     * @param {?} viewValue\n     * @return {?}\n     */\n    viewValueToModelValue(viewValue) {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n            return this.getStepValue(viewValue);\n        }\n        return viewValue;\n    }\n    /**\n     * @param {?} sliderValue\n     * @return {?}\n     */\n    getStepValue(sliderValue) {\n        /** @type {?} */\n        const step = this.viewOptions.stepsArray[sliderValue];\n        return (!ValueHelper.isNullOrUndefined(step)) ? step.value : NaN;\n    }\n    /**\n     * @return {?}\n     */\n    applyViewChange() {\n        this.value = this.viewValueToModelValue(this.viewLowValue);\n        if (this.range) {\n            this.highValue = this.viewValueToModelValue(this.viewHighValue);\n        }\n        this.outputModelChangeSubject.next({\n            value: this.value,\n            highValue: this.highValue,\n            userEventInitiated: true,\n            forceChange: false\n        });\n        // At this point all changes are applied and outputs are emitted, so we should be done.\n        // However, input changes are communicated in different stream and we need to be ready to\n        // act on the next input change even if it is exactly the same as last input change.\n        // Therefore, we send a special event to reset the stream.\n        this.inputModelChangeSubject.next({\n            value: this.value,\n            highValue: this.highValue,\n            forceChange: false,\n            internalChange: true\n        });\n    }\n    /**\n     * @param {?} modelChange\n     * @return {?}\n     */\n    applyInputModelChange(modelChange) {\n        /** @type {?} */\n        const normalisedModelChange = this.normaliseModelValues(modelChange);\n        /** @type {?} */\n        const normalisationChange = !ModelValues.compare(modelChange, normalisedModelChange);\n        if (normalisationChange) {\n            this.value = normalisedModelChange.value;\n            this.highValue = normalisedModelChange.highValue;\n        }\n        this.viewLowValue = this.modelValueToViewValue(normalisedModelChange.value);\n        if (this.range) {\n            this.viewHighValue = this.modelValueToViewValue(normalisedModelChange.highValue);\n        }\n        else {\n            this.viewHighValue = null;\n        }\n        this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n        if (this.range) {\n            this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n        }\n        this.updateSelectionBar();\n        this.updateTicksScale();\n        this.updateAriaAttributes();\n        if (this.range) {\n            this.updateCombinedLabel();\n        }\n        // At the end, we need to communicate the model change to the outputs as well\n        // Normalisation changes are also always forced out to ensure that subscribers always end up in correct state\n        this.outputModelChangeSubject.next({\n            value: normalisedModelChange.value,\n            highValue: normalisedModelChange.highValue,\n            forceChange: normalisationChange,\n            userEventInitiated: false\n        });\n    }\n    /**\n     * @param {?} modelChange\n     * @return {?}\n     */\n    publishOutputModelChange(modelChange) {\n        /** @type {?} */\n        const emitOutputs = () => {\n            this.valueChange.emit(modelChange.value);\n            if (this.range) {\n                this.highValueChange.emit(modelChange.highValue);\n            }\n            if (!ValueHelper.isNullOrUndefined(this.onChangeCallback)) {\n                if (this.range) {\n                    this.onChangeCallback([modelChange.value, modelChange.highValue]);\n                }\n                else {\n                    this.onChangeCallback(modelChange.value);\n                }\n            }\n            if (!ValueHelper.isNullOrUndefined(this.onTouchedCallback)) {\n                if (this.range) {\n                    this.onTouchedCallback([modelChange.value, modelChange.highValue]);\n                }\n                else {\n                    this.onTouchedCallback(modelChange.value);\n                }\n            }\n        };\n        if (modelChange.userEventInitiated) {\n            // If this change was initiated by a user event, we can emit outputs in the same tick\n            emitOutputs();\n            this.userChange.emit(this.getChangeContext());\n        }\n        else {\n            // But, if the change was initated by something else like a change in input bindings,\n            // we need to wait until next tick to emit the outputs to keep Angular change detection happy\n            setTimeout(() => { emitOutputs(); });\n        }\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    normaliseModelValues(input) {\n        /** @type {?} */\n        const normalisedInput = new ModelValues();\n        normalisedInput.value = input.value;\n        normalisedInput.highValue = input.highValue;\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {\n            // When using steps array, only round to nearest step in the array\n            // No other enforcement can be done, as the step array may be out of order, and that is perfectly fine\n            if (this.viewOptions.enforceStepsArray) {\n                /** @type {?} */\n                const valueIndex = ValueHelper.findStepIndex(normalisedInput.value, this.viewOptions.stepsArray);\n                normalisedInput.value = this.viewOptions.stepsArray[valueIndex].value;\n                if (this.range) {\n                    /** @type {?} */\n                    const highValueIndex = ValueHelper.findStepIndex(normalisedInput.highValue, this.viewOptions.stepsArray);\n                    normalisedInput.highValue = this.viewOptions.stepsArray[highValueIndex].value;\n                }\n            }\n            return normalisedInput;\n        }\n        if (this.viewOptions.enforceStep) {\n            normalisedInput.value = this.roundStep(normalisedInput.value);\n            if (this.range) {\n                normalisedInput.highValue = this.roundStep(normalisedInput.highValue);\n            }\n        }\n        if (this.viewOptions.enforceRange) {\n            normalisedInput.value = MathHelper.clampToRange(normalisedInput.value, this.viewOptions.floor, this.viewOptions.ceil);\n            if (this.range) {\n                normalisedInput.highValue = MathHelper.clampToRange(normalisedInput.highValue, this.viewOptions.floor, this.viewOptions.ceil);\n            }\n            // Make sure that range slider invariant (value <= highValue) is always satisfied\n            if (this.range && input.value > input.highValue) {\n                // We know that both values are now clamped correctly, they may just be in the wrong order\n                // So the easy solution is to swap them... except swapping is sometimes disabled in options, so we make the two values the same\n                if (this.viewOptions.noSwitching) {\n                    normalisedInput.value = normalisedInput.highValue;\n                }\n                else {\n                    /** @type {?} */\n                    const tempValue = input.value;\n                    normalisedInput.value = input.highValue;\n                    normalisedInput.highValue = tempValue;\n                }\n            }\n        }\n        return normalisedInput;\n    }\n    /**\n     * @return {?}\n     */\n    renormaliseModelValues() {\n        /** @type {?} */\n        const previousModelValues = {\n            value: this.value,\n            highValue: this.highValue\n        };\n        /** @type {?} */\n        const normalisedModelValues = this.normaliseModelValues(previousModelValues);\n        if (!ModelValues.compare(normalisedModelValues, previousModelValues)) {\n            this.value = normalisedModelValues.value;\n            this.highValue = normalisedModelValues.highValue;\n            this.outputModelChangeSubject.next({\n                value: this.value,\n                highValue: this.highValue,\n                forceChange: true,\n                userEventInitiated: false\n            });\n        }\n    }\n    /**\n     * @return {?}\n     */\n    onChangeOptions() {\n        if (!this.initHasRun) {\n            return;\n        }\n        /** @type {?} */\n        const previousOptionsInfluencingEventBindings = this.getOptionsInfluencingEventBindings(this.viewOptions);\n        this.applyOptions();\n        /** @type {?} */\n        const newOptionsInfluencingEventBindings = this.getOptionsInfluencingEventBindings(this.viewOptions);\n        /** @type {?} */\n        const rebindEvents = !ValueHelper.areArraysEqual(previousOptionsInfluencingEventBindings, newOptionsInfluencingEventBindings);\n        // With new options, we need to re-normalise model values if necessary\n        this.renormaliseModelValues();\n        this.viewLowValue = this.modelValueToViewValue(this.value);\n        if (this.range) {\n            this.viewHighValue = this.modelValueToViewValue(this.highValue);\n        }\n        else {\n            this.viewHighValue = null;\n        }\n        this.resetSlider(rebindEvents);\n    }\n    /**\n     * @return {?}\n     */\n    applyOptions() {\n        this.viewOptions = new Options();\n        Object.assign(this.viewOptions, this.options);\n        this.viewOptions.draggableRange = this.range && this.viewOptions.draggableRange;\n        this.viewOptions.draggableRangeOnly = this.range && this.viewOptions.draggableRangeOnly;\n        if (this.viewOptions.draggableRangeOnly) {\n            this.viewOptions.draggableRange = true;\n        }\n        this.viewOptions.showTicks = this.viewOptions.showTicks ||\n            this.viewOptions.showTicksValues ||\n            !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray);\n        if (this.viewOptions.showTicks &&\n            (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) || !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray))) {\n            this.intermediateTicks = true;\n        }\n        this.viewOptions.showSelectionBar = this.viewOptions.showSelectionBar ||\n            this.viewOptions.showSelectionBarEnd ||\n            !ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue);\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {\n            this.applyStepsArrayOptions();\n        }\n        else {\n            this.applyFloorCeilOptions();\n        }\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.combineLabels)) {\n            this.viewOptions.combineLabels = (minValue, maxValue) => {\n                return minValue + ' - ' + maxValue;\n            };\n        }\n        if (this.viewOptions.logScale && this.viewOptions.floor === 0) {\n            throw Error('Can\\'t use floor=0 with logarithmic scale');\n        }\n    }\n    /**\n     * @return {?}\n     */\n    applyStepsArrayOptions() {\n        this.viewOptions.floor = 0;\n        this.viewOptions.ceil = this.viewOptions.stepsArray.length - 1;\n        this.viewOptions.step = 1;\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n            this.viewOptions.translate = (modelValue) => {\n                if (this.viewOptions.bindIndexForStepsArray) {\n                    return String(this.getStepValue(modelValue));\n                }\n                return String(modelValue);\n            };\n        }\n    }\n    /**\n     * @return {?}\n     */\n    applyFloorCeilOptions() {\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.step)) {\n            this.viewOptions.step = 1;\n        }\n        else {\n            this.viewOptions.step = +this.viewOptions.step;\n            if (this.viewOptions.step <= 0) {\n                this.viewOptions.step = 1;\n            }\n        }\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.ceil) ||\n            ValueHelper.isNullOrUndefined(this.viewOptions.floor)) {\n            throw Error('floor and ceil options must be supplied');\n        }\n        this.viewOptions.ceil = +this.viewOptions.ceil;\n        this.viewOptions.floor = +this.viewOptions.floor;\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n            this.viewOptions.translate = (value) => String(value);\n        }\n    }\n    /**\n     * @param {?=} rebindEvents\n     * @return {?}\n     */\n    resetSlider(rebindEvents = true) {\n        this.manageElementsStyle();\n        this.addAccessibility();\n        this.updateCeilLabel();\n        this.updateFloorLabel();\n        if (rebindEvents) {\n            this.unbindEvents();\n            this.manageEventsBindings();\n        }\n        this.updateDisabledState();\n        this.updateAriaLabel();\n        this.calculateViewDimensions();\n        this.refocusPointerIfNeeded();\n    }\n    /**\n     * @param {?} pointerType\n     * @return {?}\n     */\n    focusPointer(pointerType) {\n        // If not supplied, use min pointer as default\n        if (pointerType !== PointerType.Min && pointerType !== PointerType.Max) {\n            pointerType = PointerType.Min;\n        }\n        if (pointerType === PointerType.Min) {\n            this.minHandleElement.focus();\n        }\n        else if (this.range && pointerType === PointerType.Max) {\n            this.maxHandleElement.focus();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    refocusPointerIfNeeded() {\n        if (!ValueHelper.isNullOrUndefined(this.currentFocusPointer)) {\n            this.onPointerFocus(this.currentFocusPointer);\n            /** @type {?} */\n            const element = this.getPointerElement(this.currentFocusPointer);\n            element.focus();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    manageElementsStyle() {\n        this.updateScale();\n        this.floorLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n        this.ceilLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n        /** @type {?} */\n        const hideLabelsForTicks = this.viewOptions.showTicksValues && !this.intermediateTicks;\n        this.minHandleLabelElement.setAlwaysHide(hideLabelsForTicks || this.viewOptions.hidePointerLabels);\n        this.maxHandleLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n        this.combinedLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n        this.selectionBarElement.setAlwaysHide(!this.range && !this.viewOptions.showSelectionBar);\n        this.leftOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n        this.rightOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n        this.fullBarTransparentClass = this.range && this.viewOptions.showOuterSelectionBars;\n        this.selectionBarDraggableClass = this.viewOptions.draggableRange && !this.viewOptions.onlyBindHandles;\n        this.ticksUnderValuesClass = this.intermediateTicks && this.options.showTicksValues;\n        if (this.sliderElementVerticalClass !== this.viewOptions.vertical) {\n            this.updateVerticalState();\n            // The above change in host component class will not be applied until the end of this cycle\n            // However, functions calculating the slider position expect the slider to be already styled as vertical\n            // So as a workaround, we need to reset the slider once again to compute the correct values\n            setTimeout(() => { this.resetSlider(); });\n        }\n        // Changing animate class may interfere with slider reset/initialisation, so we should set it separately,\n        // after all is properly set up\n        if (this.sliderElementAnimateClass !== this.viewOptions.animate) {\n            setTimeout(() => { this.sliderElementAnimateClass = this.viewOptions.animate; });\n        }\n        this.updateRotate();\n    }\n    /**\n     * @return {?}\n     */\n    manageEventsBindings() {\n        if (this.viewOptions.disabled || this.viewOptions.readOnly) {\n            this.unbindEvents();\n        }\n        else {\n            this.bindEvents();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    updateDisabledState() {\n        this.sliderElementDisabledAttr = this.viewOptions.disabled ? 'disabled' : null;\n    }\n    /**\n     * @return {?}\n     */\n    updateAriaLabel() {\n        this.sliderElementAriaLabel = this.viewOptions.ariaLabel || 'nxg-slider';\n    }\n    /**\n     * @return {?}\n     */\n    updateVerticalState() {\n        this.sliderElementVerticalClass = this.viewOptions.vertical;\n        for (const element of this.getAllSliderElements()) {\n            // This is also called before ngAfterInit, so need to check that view child bindings work\n            if (!ValueHelper.isNullOrUndefined(element)) {\n                element.setVertical(this.viewOptions.vertical);\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    updateScale() {\n        for (const element of this.getAllSliderElements()) {\n            element.setScale(this.viewOptions.scale);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    updateRotate() {\n        for (const element of this.getAllSliderElements()) {\n            element.setRotate(this.viewOptions.rotate);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    getAllSliderElements() {\n        return [this.leftOuterSelectionBarElement,\n            this.rightOuterSelectionBarElement,\n            this.fullBarElement,\n            this.selectionBarElement,\n            this.minHandleElement,\n            this.maxHandleElement,\n            this.floorLabelElement,\n            this.ceilLabelElement,\n            this.minHandleLabelElement,\n            this.maxHandleLabelElement,\n            this.combinedLabelElement,\n            this.ticksElement\n        ];\n    }\n    /**\n     * @return {?}\n     */\n    initHandles() {\n        this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n        /*\n           the order here is important since the selection bar should be\n           updated after the high handle but before the combined label\n           */\n        if (this.range) {\n            this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n        }\n        this.updateSelectionBar();\n        if (this.range) {\n            this.updateCombinedLabel();\n        }\n        this.updateTicksScale();\n    }\n    /**\n     * @return {?}\n     */\n    addAccessibility() {\n        this.updateAriaAttributes();\n        this.minHandleElement.role = 'slider';\n        if (this.viewOptions.keyboardSupport &&\n            !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n            this.minHandleElement.tabindex = '0';\n        }\n        else {\n            this.minHandleElement.tabindex = '';\n        }\n        this.minHandleElement.ariaOrientation = (this.viewOptions.vertical || this.viewOptions.rotate !== 0) ? 'vertical' : 'horizontal';\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabel)) {\n            this.minHandleElement.ariaLabel = this.viewOptions.ariaLabel;\n        }\n        else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledBy)) {\n            this.minHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledBy;\n        }\n        if (this.range) {\n            this.maxHandleElement.role = 'slider';\n            if (this.viewOptions.keyboardSupport &&\n                !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n                this.maxHandleElement.tabindex = '0';\n            }\n            else {\n                this.maxHandleElement.tabindex = '';\n            }\n            this.maxHandleElement.ariaOrientation = (this.viewOptions.vertical || this.viewOptions.rotate !== 0) ? 'vertical' : 'horizontal';\n            if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelHigh)) {\n                this.maxHandleElement.ariaLabel = this.viewOptions.ariaLabelHigh;\n            }\n            else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledByHigh)) {\n                this.maxHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledByHigh;\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    updateAriaAttributes() {\n        this.minHandleElement.ariaValueNow = (+this.value).toString();\n        this.minHandleElement.ariaValueText = this.viewOptions.translate(+this.value, LabelType.Low);\n        this.minHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n        this.minHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n        if (this.range) {\n            this.maxHandleElement.ariaValueNow = (+this.highValue).toString();\n            this.maxHandleElement.ariaValueText = this.viewOptions.translate(+this.highValue, LabelType.High);\n            this.maxHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n            this.maxHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    calculateViewDimensions() {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.handleDimension)) {\n            this.minHandleElement.setDimension(this.viewOptions.handleDimension);\n        }\n        else {\n            this.minHandleElement.calculateDimension();\n        }\n        /** @type {?} */\n        const handleWidth = this.minHandleElement.dimension;\n        this.handleHalfDimension = handleWidth / 2;\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.barDimension)) {\n            this.fullBarElement.setDimension(this.viewOptions.barDimension);\n        }\n        else {\n            this.fullBarElement.calculateDimension();\n        }\n        this.maxHandlePosition = this.fullBarElement.dimension - handleWidth;\n        if (this.initHasRun) {\n            this.updateFloorLabel();\n            this.updateCeilLabel();\n            this.initHandles();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    calculateViewDimensionsAndDetectChanges() {\n        this.calculateViewDimensions();\n        if (!this.isRefDestroyed()) {\n            this.changeDetectionRef.detectChanges();\n        }\n    }\n    /**\n     * If the slider reference is already destroyed\n     * @return {?} boolean - true if ref is destroyed\n     */\n    isRefDestroyed() {\n        return this.changeDetectionRef['destroyed'];\n    }\n    /**\n     * @return {?}\n     */\n    updateTicksScale() {\n        if (!this.viewOptions.showTicks) {\n            setTimeout(() => { this.sliderElementWithLegendClass = false; });\n            return;\n        }\n        /** @type {?} */\n        const ticksArray = !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray)\n            ? this.viewOptions.ticksArray\n            : this.getTicksArray();\n        /** @type {?} */\n        const translate = this.viewOptions.vertical ? 'translateY' : 'translateX';\n        if (this.viewOptions.rightToLeft) {\n            ticksArray.reverse();\n        }\n        /** @type {?} */\n        const tickValueStep = !ValueHelper.isNullOrUndefined(this.viewOptions.tickValueStep) ? this.viewOptions.tickValueStep :\n            (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) ? this.viewOptions.tickStep : this.viewOptions.step);\n        /** @type {?} */\n        let hasAtLeastOneLegend = false;\n        /** @type {?} */\n        const newTicks = ticksArray.map((value) => {\n            /** @type {?} */\n            let position = this.valueToPosition(value);\n            if (this.viewOptions.vertical) {\n                position = this.maxHandlePosition - position;\n            }\n            /** @type {?} */\n            const translation = translate + '(' + Math.round(position) + 'px)';\n            /** @type {?} */\n            const tick = new Tick();\n            tick.selected = this.isTickSelected(value);\n            tick.style = {\n                '-webkit-transform': translation,\n                '-moz-transform': translation,\n                '-o-transform': translation,\n                '-ms-transform': translation,\n                transform: translation,\n            };\n            if (tick.selected && !ValueHelper.isNullOrUndefined(this.viewOptions.getSelectionBarColor)) {\n                tick.style['background-color'] = this.getSelectionBarColor();\n            }\n            if (!tick.selected && !ValueHelper.isNullOrUndefined(this.viewOptions.getTickColor)) {\n                tick.style['background-color'] = this.getTickColor(value);\n            }\n            if (!ValueHelper.isNullOrUndefined(this.viewOptions.ticksTooltip)) {\n                tick.tooltip = this.viewOptions.ticksTooltip(value);\n                tick.tooltipPlacement = this.viewOptions.vertical ? 'right' : 'top';\n            }\n            if (this.viewOptions.showTicksValues && !ValueHelper.isNullOrUndefined(tickValueStep) &&\n                MathHelper.isModuloWithinPrecisionLimit(value, tickValueStep, this.viewOptions.precisionLimit)) {\n                tick.value = this.getDisplayValue(value, LabelType.TickValue);\n                if (!ValueHelper.isNullOrUndefined(this.viewOptions.ticksValuesTooltip)) {\n                    tick.valueTooltip = this.viewOptions.ticksValuesTooltip(value);\n                    tick.valueTooltipPlacement = this.viewOptions.vertical\n                        ? 'right'\n                        : 'top';\n                }\n            }\n            /** @type {?} */\n            let legend = null;\n            if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {\n                /** @type {?} */\n                const step = this.viewOptions.stepsArray[value];\n                if (!ValueHelper.isNullOrUndefined(this.viewOptions.getStepLegend)) {\n                    legend = this.viewOptions.getStepLegend(step);\n                }\n                else if (!ValueHelper.isNullOrUndefined(step)) {\n                    legend = step.legend;\n                }\n            }\n            else if (!ValueHelper.isNullOrUndefined(this.viewOptions.getLegend)) {\n                legend = this.viewOptions.getLegend(value);\n            }\n            if (!ValueHelper.isNullOrUndefined(legend)) {\n                tick.legend = legend;\n                hasAtLeastOneLegend = true;\n            }\n            return tick;\n        });\n        setTimeout(() => { this.sliderElementWithLegendClass = hasAtLeastOneLegend; });\n        // We should avoid re-creating the ticks array if possible\n        // This both improves performance and makes CSS animations work correctly\n        if (!ValueHelper.isNullOrUndefined(this.ticks) && this.ticks.length === newTicks.length) {\n            for (let i = 0; i < newTicks.length; ++i) {\n                Object.assign(this.ticks[i], newTicks[i]);\n            }\n        }\n        else {\n            this.ticks = newTicks;\n        }\n        if (!this.isRefDestroyed()) {\n            this.changeDetectionRef.detectChanges();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    getTicksArray() {\n        /** @type {?} */\n        const step = (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) ? this.viewOptions.tickStep : this.viewOptions.step;\n        /** @type {?} */\n        const ticksArray = [];\n        /** @type {?} */\n        const numberOfValues = 1 + Math.floor(MathHelper.roundToPrecisionLimit(Math.abs(this.viewOptions.ceil - this.viewOptions.floor) / step, this.viewOptions.precisionLimit));\n        for (let index = 0; index < numberOfValues; ++index) {\n            ticksArray.push(MathHelper.roundToPrecisionLimit(this.viewOptions.floor + step * index, this.viewOptions.precisionLimit));\n        }\n        return ticksArray;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    isTickSelected(value) {\n        if (!this.range) {\n            if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n                /** @type {?} */\n                const center = this.viewOptions.showSelectionBarFromValue;\n                if (this.viewLowValue > center &&\n                    value >= center &&\n                    value <= this.viewLowValue) {\n                    return true;\n                }\n                else if (this.viewLowValue < center &&\n                    value <= center &&\n                    value >= this.viewLowValue) {\n                    return true;\n                }\n            }\n            else if (this.viewOptions.showSelectionBarEnd) {\n                if (value >= this.viewLowValue) {\n                    return true;\n                }\n            }\n            else if (this.viewOptions.showSelectionBar && value <= this.viewLowValue) {\n                return true;\n            }\n        }\n        if (this.range && value >= this.viewLowValue && value <= this.viewHighValue) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @return {?}\n     */\n    updateFloorLabel() {\n        if (!this.floorLabelElement.alwaysHide) {\n            this.floorLabelElement.setValue(this.getDisplayValue(this.viewOptions.floor, LabelType.Floor));\n            this.floorLabelElement.calculateDimension();\n            /** @type {?} */\n            const position = this.viewOptions.rightToLeft\n                ? this.fullBarElement.dimension - this.floorLabelElement.dimension\n                : 0;\n            this.floorLabelElement.setPosition(position);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    updateCeilLabel() {\n        if (!this.ceilLabelElement.alwaysHide) {\n            this.ceilLabelElement.setValue(this.getDisplayValue(this.viewOptions.ceil, LabelType.Ceil));\n            this.ceilLabelElement.calculateDimension();\n            /** @type {?} */\n            const position = this.viewOptions.rightToLeft\n                ? 0\n                : this.fullBarElement.dimension - this.ceilLabelElement.dimension;\n            this.ceilLabelElement.setPosition(position);\n        }\n    }\n    /**\n     * @param {?} which\n     * @param {?} newPos\n     * @return {?}\n     */\n    updateHandles(which, newPos) {\n        if (which === PointerType.Min) {\n            this.updateLowHandle(newPos);\n        }\n        else if (which === PointerType.Max) {\n            this.updateHighHandle(newPos);\n        }\n        this.updateSelectionBar();\n        this.updateTicksScale();\n        if (this.range) {\n            this.updateCombinedLabel();\n        }\n    }\n    /**\n     * @param {?} labelType\n     * @param {?} newPos\n     * @return {?}\n     */\n    getHandleLabelPos(labelType, newPos) {\n        /** @type {?} */\n        const labelDimension = (labelType === PointerType.Min)\n            ? this.minHandleLabelElement.dimension\n            : this.maxHandleLabelElement.dimension;\n        /** @type {?} */\n        const nearHandlePos = newPos - labelDimension / 2 + this.handleHalfDimension;\n        /** @type {?} */\n        const endOfBarPos = this.fullBarElement.dimension - labelDimension;\n        if (!this.viewOptions.boundPointerLabels) {\n            return nearHandlePos;\n        }\n        if ((this.viewOptions.rightToLeft && labelType === PointerType.Min) ||\n            (!this.viewOptions.rightToLeft && labelType === PointerType.Max)) {\n            return Math.min(nearHandlePos, endOfBarPos);\n        }\n        else {\n            return Math.min(Math.max(nearHandlePos, 0), endOfBarPos);\n        }\n    }\n    /**\n     * @param {?} newPos\n     * @return {?}\n     */\n    updateLowHandle(newPos) {\n        this.minHandleElement.setPosition(newPos);\n        this.minHandleLabelElement.setValue(this.getDisplayValue(this.viewLowValue, LabelType.Low));\n        this.minHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Min, newPos));\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n            this.minPointerStyle = {\n                backgroundColor: this.getPointerColor(PointerType.Min),\n            };\n        }\n        if (this.viewOptions.autoHideLimitLabels) {\n            this.updateFloorAndCeilLabelsVisibility();\n        }\n    }\n    /**\n     * @param {?} newPos\n     * @return {?}\n     */\n    updateHighHandle(newPos) {\n        this.maxHandleElement.setPosition(newPos);\n        this.maxHandleLabelElement.setValue(this.getDisplayValue(this.viewHighValue, LabelType.High));\n        this.maxHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Max, newPos));\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n            this.maxPointerStyle = {\n                backgroundColor: this.getPointerColor(PointerType.Max),\n            };\n        }\n        if (this.viewOptions.autoHideLimitLabels) {\n            this.updateFloorAndCeilLabelsVisibility();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    updateFloorAndCeilLabelsVisibility() {\n        // Show based only on hideLimitLabels if pointer labels are hidden\n        if (this.viewOptions.hidePointerLabels) {\n            return;\n        }\n        /** @type {?} */\n        let floorLabelHidden = false;\n        /** @type {?} */\n        let ceilLabelHidden = false;\n        /** @type {?} */\n        const isMinLabelAtFloor = this.isLabelBelowFloorLabel(this.minHandleLabelElement);\n        /** @type {?} */\n        const isMinLabelAtCeil = this.isLabelAboveCeilLabel(this.minHandleLabelElement);\n        /** @type {?} */\n        const isMaxLabelAtCeil = this.isLabelAboveCeilLabel(this.maxHandleLabelElement);\n        /** @type {?} */\n        const isCombinedLabelAtFloor = this.isLabelBelowFloorLabel(this.combinedLabelElement);\n        /** @type {?} */\n        const isCombinedLabelAtCeil = this.isLabelAboveCeilLabel(this.combinedLabelElement);\n        if (isMinLabelAtFloor) {\n            floorLabelHidden = true;\n            this.floorLabelElement.hide();\n        }\n        else {\n            floorLabelHidden = false;\n            this.floorLabelElement.show();\n        }\n        if (isMinLabelAtCeil) {\n            ceilLabelHidden = true;\n            this.ceilLabelElement.hide();\n        }\n        else {\n            ceilLabelHidden = false;\n            this.ceilLabelElement.show();\n        }\n        if (this.range) {\n            /** @type {?} */\n            const hideCeil = this.combinedLabelElement.isVisible() ? isCombinedLabelAtCeil : isMaxLabelAtCeil;\n            /** @type {?} */\n            const hideFloor = this.combinedLabelElement.isVisible() ? isCombinedLabelAtFloor : isMinLabelAtFloor;\n            if (hideCeil) {\n                this.ceilLabelElement.hide();\n            }\n            else if (!ceilLabelHidden) {\n                this.ceilLabelElement.show();\n            }\n            // Hide or show floor label\n            if (hideFloor) {\n                this.floorLabelElement.hide();\n            }\n            else if (!floorLabelHidden) {\n                this.floorLabelElement.show();\n            }\n        }\n    }\n    /**\n     * @param {?} label\n     * @return {?}\n     */\n    isLabelBelowFloorLabel(label) {\n        /** @type {?} */\n        const pos = label.position;\n        /** @type {?} */\n        const dim = label.dimension;\n        /** @type {?} */\n        const floorPos = this.floorLabelElement.position;\n        /** @type {?} */\n        const floorDim = this.floorLabelElement.dimension;\n        return this.viewOptions.rightToLeft\n            ? pos + dim >= floorPos - 2\n            : pos <= floorPos + floorDim + 2;\n    }\n    /**\n     * @param {?} label\n     * @return {?}\n     */\n    isLabelAboveCeilLabel(label) {\n        /** @type {?} */\n        const pos = label.position;\n        /** @type {?} */\n        const dim = label.dimension;\n        /** @type {?} */\n        const ceilPos = this.ceilLabelElement.position;\n        /** @type {?} */\n        const ceilDim = this.ceilLabelElement.dimension;\n        return this.viewOptions.rightToLeft\n            ? pos <= ceilPos + ceilDim + 2\n            : pos + dim >= ceilPos - 2;\n    }\n    /**\n     * @return {?}\n     */\n    updateSelectionBar() {\n        /** @type {?} */\n        let position = 0;\n        /** @type {?} */\n        let dimension = 0;\n        /** @type {?} */\n        const isSelectionBarFromRight = this.viewOptions.rightToLeft\n            ? !this.viewOptions.showSelectionBarEnd\n            : this.viewOptions.showSelectionBarEnd;\n        /** @type {?} */\n        const positionForRange = this.viewOptions.rightToLeft\n            ? this.maxHandleElement.position + this.handleHalfDimension\n            : this.minHandleElement.position + this.handleHalfDimension;\n        if (this.range) {\n            dimension = Math.abs(this.maxHandleElement.position - this.minHandleElement.position);\n            position = positionForRange;\n        }\n        else {\n            if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n                /** @type {?} */\n                const center = this.viewOptions.showSelectionBarFromValue;\n                /** @type {?} */\n                const centerPosition = this.valueToPosition(center);\n                /** @type {?} */\n                const isModelGreaterThanCenter = this.viewOptions.rightToLeft\n                    ? this.viewLowValue <= center\n                    : this.viewLowValue > center;\n                if (isModelGreaterThanCenter) {\n                    dimension = this.minHandleElement.position - centerPosition;\n                    position = centerPosition + this.handleHalfDimension;\n                }\n                else {\n                    dimension = centerPosition - this.minHandleElement.position;\n                    position = this.minHandleElement.position + this.handleHalfDimension;\n                }\n            }\n            else if (isSelectionBarFromRight) {\n                dimension = Math.ceil(Math.abs(this.maxHandlePosition - this.minHandleElement.position) + this.handleHalfDimension);\n                position = Math.floor(this.minHandleElement.position + this.handleHalfDimension);\n            }\n            else {\n                dimension = this.minHandleElement.position + this.handleHalfDimension;\n                position = 0;\n            }\n        }\n        this.selectionBarElement.setDimension(dimension);\n        this.selectionBarElement.setPosition(position);\n        if (this.range && this.viewOptions.showOuterSelectionBars) {\n            if (this.viewOptions.rightToLeft) {\n                this.rightOuterSelectionBarElement.setDimension(position);\n                this.rightOuterSelectionBarElement.setPosition(0);\n                this.fullBarElement.calculateDimension();\n                this.leftOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n                this.leftOuterSelectionBarElement.setPosition(position + dimension);\n            }\n            else {\n                this.leftOuterSelectionBarElement.setDimension(position);\n                this.leftOuterSelectionBarElement.setPosition(0);\n                this.fullBarElement.calculateDimension();\n                this.rightOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n                this.rightOuterSelectionBarElement.setPosition(position + dimension);\n            }\n        }\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.getSelectionBarColor)) {\n            /** @type {?} */\n            const color = this.getSelectionBarColor();\n            this.barStyle = {\n                backgroundColor: color,\n            };\n        }\n        else if (!ValueHelper.isNullOrUndefined(this.viewOptions.selectionBarGradient)) {\n            /** @type {?} */\n            const offset = (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue))\n                ? this.valueToPosition(this.viewOptions.showSelectionBarFromValue)\n                : 0;\n            /** @type {?} */\n            const reversed = (offset - position > 0 && !isSelectionBarFromRight) || (offset - position <= 0 && isSelectionBarFromRight);\n            /** @type {?} */\n            const direction = this.viewOptions.vertical\n                ? reversed ? 'bottom' : 'top'\n                : reversed ? 'left' : 'right';\n            this.barStyle = {\n                backgroundImage: 'linear-gradient(to ' +\n                    direction +\n                    ', ' +\n                    this.viewOptions.selectionBarGradient.from +\n                    ' 0%,' +\n                    this.viewOptions.selectionBarGradient.to +\n                    ' 100%)',\n            };\n            if (this.viewOptions.vertical) {\n                this.barStyle.backgroundPosition =\n                    'center ' +\n                        (offset +\n                            dimension +\n                            position +\n                            (reversed ? -this.handleHalfDimension : 0)) +\n                        'px';\n                this.barStyle.backgroundSize =\n                    '100% ' + (this.fullBarElement.dimension - this.handleHalfDimension) + 'px';\n            }\n            else {\n                this.barStyle.backgroundPosition =\n                    offset -\n                        position +\n                        (reversed ? this.handleHalfDimension : 0) +\n                        'px center';\n                this.barStyle.backgroundSize =\n                    this.fullBarElement.dimension - this.handleHalfDimension + 'px 100%';\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    getSelectionBarColor() {\n        if (this.range) {\n            return this.viewOptions.getSelectionBarColor(this.value, this.highValue);\n        }\n        return this.viewOptions.getSelectionBarColor(this.value);\n    }\n    /**\n     * @param {?} pointerType\n     * @return {?}\n     */\n    getPointerColor(pointerType) {\n        if (pointerType === PointerType.Max) {\n            return this.viewOptions.getPointerColor(this.highValue, pointerType);\n        }\n        return this.viewOptions.getPointerColor(this.value, pointerType);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    getTickColor(value) {\n        return this.viewOptions.getTickColor(value);\n    }\n    /**\n     * @return {?}\n     */\n    updateCombinedLabel() {\n        /** @type {?} */\n        let isLabelOverlap = null;\n        if (this.viewOptions.rightToLeft) {\n            isLabelOverlap =\n                this.minHandleLabelElement.position - this.minHandleLabelElement.dimension - 10 <= this.maxHandleLabelElement.position;\n        }\n        else {\n            isLabelOverlap =\n                this.minHandleLabelElement.position + this.minHandleLabelElement.dimension + 10 >= this.maxHandleLabelElement.position;\n        }\n        if (isLabelOverlap) {\n            /** @type {?} */\n            const lowDisplayValue = this.getDisplayValue(this.viewLowValue, LabelType.Low);\n            /** @type {?} */\n            const highDisplayValue = this.getDisplayValue(this.viewHighValue, LabelType.High);\n            /** @type {?} */\n            const combinedLabelValue = this.viewOptions.rightToLeft\n                ? this.viewOptions.combineLabels(highDisplayValue, lowDisplayValue)\n                : this.viewOptions.combineLabels(lowDisplayValue, highDisplayValue);\n            this.combinedLabelElement.setValue(combinedLabelValue);\n            /** @type {?} */\n            const pos = this.viewOptions.boundPointerLabels\n                ? Math.min(Math.max(this.selectionBarElement.position +\n                    this.selectionBarElement.dimension / 2 -\n                    this.combinedLabelElement.dimension / 2, 0), this.fullBarElement.dimension - this.combinedLabelElement.dimension)\n                : this.selectionBarElement.position + this.selectionBarElement.dimension / 2 - this.combinedLabelElement.dimension / 2;\n            this.combinedLabelElement.setPosition(pos);\n            this.minHandleLabelElement.hide();\n            this.maxHandleLabelElement.hide();\n            this.combinedLabelElement.show();\n        }\n        else {\n            this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n            this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n            this.maxHandleLabelElement.show();\n            this.minHandleLabelElement.show();\n            this.combinedLabelElement.hide();\n        }\n        if (this.viewOptions.autoHideLimitLabels) {\n            this.updateFloorAndCeilLabelsVisibility();\n        }\n    }\n    /**\n     * @param {?} value\n     * @param {?} which\n     * @return {?}\n     */\n    getDisplayValue(value, which) {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n            value = this.getStepValue(value);\n        }\n        return this.viewOptions.translate(value, which);\n    }\n    /**\n     * @param {?} value\n     * @param {?=} customStep\n     * @return {?}\n     */\n    roundStep(value, customStep) {\n        /** @type {?} */\n        const step = !ValueHelper.isNullOrUndefined(customStep) ? customStep : this.viewOptions.step;\n        /** @type {?} */\n        let steppedDifference = MathHelper.roundToPrecisionLimit((value - this.viewOptions.floor) / step, this.viewOptions.precisionLimit);\n        steppedDifference = Math.round(steppedDifference) * step;\n        return MathHelper.roundToPrecisionLimit(this.viewOptions.floor + steppedDifference, this.viewOptions.precisionLimit);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    valueToPosition(val) {\n        /** @type {?} */\n        let fn = ValueHelper.linearValueToPosition;\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.customValueToPosition)) {\n            fn = this.viewOptions.customValueToPosition;\n        }\n        else if (this.viewOptions.logScale) {\n            fn = ValueHelper.logValueToPosition;\n        }\n        val = MathHelper.clampToRange(val, this.viewOptions.floor, this.viewOptions.ceil);\n        /** @type {?} */\n        let percent = fn(val, this.viewOptions.floor, this.viewOptions.ceil);\n        if (ValueHelper.isNullOrUndefined(percent)) {\n            percent = 0;\n        }\n        if (this.viewOptions.rightToLeft) {\n            percent = 1 - percent;\n        }\n        return percent * this.maxHandlePosition;\n    }\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    positionToValue(position) {\n        /** @type {?} */\n        let percent = position / this.maxHandlePosition;\n        if (this.viewOptions.rightToLeft) {\n            percent = 1 - percent;\n        }\n        /** @type {?} */\n        let fn = ValueHelper.linearPositionToValue;\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.customPositionToValue)) {\n            fn = this.viewOptions.customPositionToValue;\n        }\n        else if (this.viewOptions.logScale) {\n            fn = ValueHelper.logPositionToValue;\n        }\n        /** @type {?} */\n        const value = fn(percent, this.viewOptions.floor, this.viewOptions.ceil);\n        return !ValueHelper.isNullOrUndefined(value) ? value : 0;\n    }\n    /**\n     * @param {?} event\n     * @param {?=} targetTouchId\n     * @return {?}\n     */\n    getEventXY(event, targetTouchId) {\n        if (event instanceof MouseEvent) {\n            return (this.viewOptions.vertical || this.viewOptions.rotate !== 0) ? event.clientY : event.clientX;\n        }\n        /** @type {?} */\n        let touchIndex = 0;\n        /** @type {?} */\n        const touches = event.touches;\n        if (!ValueHelper.isNullOrUndefined(targetTouchId)) {\n            for (let i = 0; i < touches.length; i++) {\n                if (touches[i].identifier === targetTouchId) {\n                    touchIndex = i;\n                    break;\n                }\n            }\n        }\n        // Return the target touch or if the target touch was not found in the event\n        // returns the coordinates of the first touch\n        return (this.viewOptions.vertical || this.viewOptions.rotate !== 0) ? touches[touchIndex].clientY : touches[touchIndex].clientX;\n    }\n    /**\n     * @param {?} event\n     * @param {?=} targetTouchId\n     * @return {?}\n     */\n    getEventPosition(event, targetTouchId) {\n        /** @type {?} */\n        const sliderElementBoundingRect = this.elementRef.nativeElement.getBoundingClientRect();\n        /** @type {?} */\n        const sliderPos = (this.viewOptions.vertical || this.viewOptions.rotate !== 0) ?\n            sliderElementBoundingRect.bottom : sliderElementBoundingRect.left;\n        /** @type {?} */\n        let eventPos = 0;\n        if (this.viewOptions.vertical || this.viewOptions.rotate !== 0) {\n            eventPos = -this.getEventXY(event, targetTouchId) + sliderPos;\n        }\n        else {\n            eventPos = this.getEventXY(event, targetTouchId) - sliderPos;\n        }\n        return eventPos * this.viewOptions.scale - this.handleHalfDimension;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    getNearestHandle(event) {\n        if (!this.range) {\n            return PointerType.Min;\n        }\n        /** @type {?} */\n        const position = this.getEventPosition(event);\n        /** @type {?} */\n        const distanceMin = Math.abs(position - this.minHandleElement.position);\n        /** @type {?} */\n        const distanceMax = Math.abs(position - this.maxHandleElement.position);\n        if (distanceMin < distanceMax) {\n            return PointerType.Min;\n        }\n        else if (distanceMin > distanceMax) {\n            return PointerType.Max;\n        }\n        else if (!this.viewOptions.rightToLeft) {\n            // if event is at the same distance from min/max then if it's at left of minH, we return minH else maxH\n            return position < this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n        }\n        // reverse in rtl\n        return position > this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n    }\n    /**\n     * @return {?}\n     */\n    bindEvents() {\n        /** @type {?} */\n        const draggableRange = this.viewOptions.draggableRange;\n        if (!this.viewOptions.onlyBindHandles) {\n            this.selectionBarElement.on('mousedown', (event) => this.onBarStart(null, draggableRange, event, true, true, true));\n        }\n        if (this.viewOptions.draggableRangeOnly) {\n            this.minHandleElement.on('mousedown', (event) => this.onBarStart(PointerType.Min, draggableRange, event, true, true));\n            this.maxHandleElement.on('mousedown', (event) => this.onBarStart(PointerType.Max, draggableRange, event, true, true));\n        }\n        else {\n            this.minHandleElement.on('mousedown', (event) => this.onStart(PointerType.Min, event, true, true));\n            if (this.range) {\n                this.maxHandleElement.on('mousedown', (event) => this.onStart(PointerType.Max, event, true, true));\n            }\n            if (!this.viewOptions.onlyBindHandles) {\n                this.fullBarElement.on('mousedown', (event) => this.onStart(null, event, true, true, true));\n                this.ticksElement.on('mousedown', (event) => this.onStart(null, event, true, true, true, true));\n            }\n        }\n        if (!this.viewOptions.onlyBindHandles) {\n            this.selectionBarElement.onPassive('touchstart', (event) => this.onBarStart(null, draggableRange, event, true, true, true));\n        }\n        if (this.viewOptions.draggableRangeOnly) {\n            this.minHandleElement.onPassive('touchstart', (event) => this.onBarStart(PointerType.Min, draggableRange, event, true, true));\n            this.maxHandleElement.onPassive('touchstart', (event) => this.onBarStart(PointerType.Max, draggableRange, event, true, true));\n        }\n        else {\n            this.minHandleElement.onPassive('touchstart', (event) => this.onStart(PointerType.Min, event, true, true));\n            if (this.range) {\n                this.maxHandleElement.onPassive('touchstart', (event) => this.onStart(PointerType.Max, event, true, true));\n            }\n            if (!this.viewOptions.onlyBindHandles) {\n                this.fullBarElement.onPassive('touchstart', (event) => this.onStart(null, event, true, true, true));\n                this.ticksElement.onPassive('touchstart', (event) => this.onStart(null, event, false, false, true, true));\n            }\n        }\n        if (this.viewOptions.keyboardSupport) {\n            this.minHandleElement.on('focus', () => this.onPointerFocus(PointerType.Min));\n            if (this.range) {\n                this.maxHandleElement.on('focus', () => this.onPointerFocus(PointerType.Max));\n            }\n        }\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    getOptionsInfluencingEventBindings(options) {\n        return [\n            options.disabled,\n            options.readOnly,\n            options.draggableRange,\n            options.draggableRangeOnly,\n            options.onlyBindHandles,\n            options.keyboardSupport\n        ];\n    }\n    /**\n     * @return {?}\n     */\n    unbindEvents() {\n        this.unsubscribeOnMove();\n        this.unsubscribeOnEnd();\n        for (const element of this.getAllSliderElements()) {\n            if (!ValueHelper.isNullOrUndefined(element)) {\n                element.off();\n            }\n        }\n    }\n    /**\n     * @param {?} pointerType\n     * @param {?} draggableRange\n     * @param {?} event\n     * @param {?} bindMove\n     * @param {?} bindEnd\n     * @param {?=} simulateImmediateMove\n     * @param {?=} simulateImmediateEnd\n     * @return {?}\n     */\n    onBarStart(pointerType, draggableRange, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n        if (draggableRange) {\n            this.onDragStart(pointerType, event, bindMove, bindEnd);\n        }\n        else {\n            this.onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);\n        }\n    }\n    /**\n     * @param {?} pointerType\n     * @param {?} event\n     * @param {?} bindMove\n     * @param {?} bindEnd\n     * @param {?=} simulateImmediateMove\n     * @param {?=} simulateImmediateEnd\n     * @return {?}\n     */\n    onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n        event.stopPropagation();\n        // Only call preventDefault() when handling non-passive events (passive events don't need it)\n        if (!CompatibilityHelper.isTouchEvent(event) && !supportsPassiveEvents) {\n            event.preventDefault();\n        }\n        this.moving = false;\n        // We have to do this in case the HTML where the sliders are on\n        // have been animated into view.\n        this.calculateViewDimensions();\n        if (ValueHelper.isNullOrUndefined(pointerType)) {\n            pointerType = this.getNearestHandle(event);\n        }\n        this.currentTrackingPointer = pointerType;\n        /** @type {?} */\n        const pointerElement = this.getPointerElement(pointerType);\n        pointerElement.active = true;\n        if (this.viewOptions.keyboardSupport) {\n            pointerElement.focus();\n        }\n        if (bindMove) {\n            this.unsubscribeOnMove();\n            /** @type {?} */\n            const onMoveCallback = (e) => this.dragging.active ? this.onDragMove(e) : this.onMove(e);\n            if (CompatibilityHelper.isTouchEvent(event)) {\n                this.onMoveEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchmove', onMoveCallback);\n            }\n            else {\n                this.onMoveEventListener = this.eventListenerHelper.attachEventListener(document, 'mousemove', onMoveCallback);\n            }\n        }\n        if (bindEnd) {\n            this.unsubscribeOnEnd();\n            /** @type {?} */\n            const onEndCallback = (e) => this.onEnd(e);\n            if (CompatibilityHelper.isTouchEvent(event)) {\n                this.onEndEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchend', onEndCallback);\n            }\n            else {\n                this.onEndEventListener = this.eventListenerHelper.attachEventListener(document, 'mouseup', onEndCallback);\n            }\n        }\n        this.userChangeStart.emit(this.getChangeContext());\n        if (CompatibilityHelper.isTouchEvent(event) && !ValueHelper.isNullOrUndefined((/** @type {?} */ (event)).changedTouches)) {\n            // Store the touch identifier\n            if (ValueHelper.isNullOrUndefined(this.touchId)) {\n                this.touchId = (/** @type {?} */ (event)).changedTouches[0].identifier;\n            }\n        }\n        // Click events, either with mouse or touch gesture are weird. Sometimes they result in full\n        // start, move, end sequence, and sometimes, they don't - they only invoke mousedown\n        // As a workaround, we simulate the first move event and the end event if it's necessary\n        if (simulateImmediateMove) {\n            this.onMove(event, true);\n        }\n        if (simulateImmediateEnd) {\n            this.onEnd(event);\n        }\n    }\n    /**\n     * @param {?} event\n     * @param {?=} fromTick\n     * @return {?}\n     */\n    onMove(event, fromTick) {\n        /** @type {?} */\n        let touchForThisSlider = null;\n        if (CompatibilityHelper.isTouchEvent(event)) {\n            /** @type {?} */\n            const changedTouches = (/** @type {?} */ (event)).changedTouches;\n            for (let i = 0; i < changedTouches.length; i++) {\n                if (changedTouches[i].identifier === this.touchId) {\n                    touchForThisSlider = changedTouches[i];\n                    break;\n                }\n            }\n            if (ValueHelper.isNullOrUndefined(touchForThisSlider)) {\n                return;\n            }\n        }\n        if (this.viewOptions.animate && !this.viewOptions.animateOnMove) {\n            if (this.moving) {\n                this.sliderElementAnimateClass = false;\n            }\n        }\n        this.moving = true;\n        /** @type {?} */\n        const newPos = !ValueHelper.isNullOrUndefined(touchForThisSlider)\n            ? this.getEventPosition(event, touchForThisSlider.identifier)\n            : this.getEventPosition(event);\n        /** @type {?} */\n        let newValue;\n        /** @type {?} */\n        const ceilValue = this.viewOptions.rightToLeft\n            ? this.viewOptions.floor\n            : this.viewOptions.ceil;\n        /** @type {?} */\n        const floorValue = this.viewOptions.rightToLeft ? this.viewOptions.ceil : this.viewOptions.floor;\n        if (newPos <= 0) {\n            newValue = floorValue;\n        }\n        else if (newPos >= this.maxHandlePosition) {\n            newValue = ceilValue;\n        }\n        else {\n            newValue = this.positionToValue(newPos);\n            if (fromTick && !ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) {\n                newValue = this.roundStep(newValue, this.viewOptions.tickStep);\n            }\n            else {\n                newValue = this.roundStep(newValue);\n            }\n        }\n        this.positionTrackingHandle(newValue);\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    onEnd(event) {\n        if (CompatibilityHelper.isTouchEvent(event)) {\n            /** @type {?} */\n            const changedTouches = (/** @type {?} */ (event)).changedTouches;\n            if (changedTouches[0].identifier !== this.touchId) {\n                return;\n            }\n        }\n        this.moving = false;\n        if (this.viewOptions.animate) {\n            this.sliderElementAnimateClass = true;\n        }\n        this.touchId = null;\n        if (!this.viewOptions.keyboardSupport) {\n            this.minHandleElement.active = false;\n            this.maxHandleElement.active = false;\n            this.currentTrackingPointer = null;\n        }\n        this.dragging.active = false;\n        this.unsubscribeOnMove();\n        this.unsubscribeOnEnd();\n        this.userChangeEnd.emit(this.getChangeContext());\n    }\n    /**\n     * @param {?} pointerType\n     * @return {?}\n     */\n    onPointerFocus(pointerType) {\n        /** @type {?} */\n        const pointerElement = this.getPointerElement(pointerType);\n        pointerElement.on('blur', () => this.onPointerBlur(pointerElement));\n        pointerElement.on('keydown', (event) => this.onKeyboardEvent(event));\n        pointerElement.on('keyup', () => this.onKeyUp());\n        pointerElement.active = true;\n        this.currentTrackingPointer = pointerType;\n        this.currentFocusPointer = pointerType;\n        this.firstKeyDown = true;\n    }\n    /**\n     * @return {?}\n     */\n    onKeyUp() {\n        this.firstKeyDown = true;\n        this.userChangeEnd.emit(this.getChangeContext());\n    }\n    /**\n     * @param {?} pointer\n     * @return {?}\n     */\n    onPointerBlur(pointer) {\n        pointer.off('blur');\n        pointer.off('keydown');\n        pointer.off('keyup');\n        pointer.active = false;\n        if (ValueHelper.isNullOrUndefined(this.touchId)) {\n            this.currentTrackingPointer = null;\n            this.currentFocusPointer = null;\n        }\n    }\n    /**\n     * @param {?} currentValue\n     * @return {?}\n     */\n    getKeyActions(currentValue) {\n        /** @type {?} */\n        const valueRange = this.viewOptions.ceil - this.viewOptions.floor;\n        /** @type {?} */\n        let increaseStep = currentValue + this.viewOptions.step;\n        /** @type {?} */\n        let decreaseStep = currentValue - this.viewOptions.step;\n        /** @type {?} */\n        let increasePage = currentValue + valueRange / 10;\n        /** @type {?} */\n        let decreasePage = currentValue - valueRange / 10;\n        if (this.viewOptions.reversedControls) {\n            increaseStep = currentValue - this.viewOptions.step;\n            decreaseStep = currentValue + this.viewOptions.step;\n            increasePage = currentValue - valueRange / 10;\n            decreasePage = currentValue + valueRange / 10;\n        }\n        /** @type {?} */\n        const actions = {\n            UP: increaseStep,\n            DOWN: decreaseStep,\n            LEFT: decreaseStep,\n            RIGHT: increaseStep,\n            PAGEUP: increasePage,\n            PAGEDOWN: decreasePage,\n            HOME: this.viewOptions.reversedControls ? this.viewOptions.ceil : this.viewOptions.floor,\n            END: this.viewOptions.reversedControls ? this.viewOptions.floor : this.viewOptions.ceil,\n        };\n        // right to left means swapping right and left arrows\n        if (this.viewOptions.rightToLeft) {\n            actions[\"LEFT\"] = increaseStep;\n            actions[\"RIGHT\"] = decreaseStep;\n            // right to left and vertical means we also swap up and down\n            if (this.viewOptions.vertical || this.viewOptions.rotate !== 0) {\n                actions[\"UP\"] = decreaseStep;\n                actions[\"DOWN\"] = increaseStep;\n            }\n        }\n        return actions;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    onKeyboardEvent(event) {\n        /** @type {?} */\n        const currentValue = this.getCurrentTrackingValue();\n        /** @type {?} */\n        const keyCode = !ValueHelper.isNullOrUndefined(event.keyCode)\n            ? event.keyCode\n            : event.which;\n        /** @type {?} */\n        const keys = {\n            38: 'UP',\n            40: 'DOWN',\n            37: 'LEFT',\n            39: 'RIGHT',\n            33: 'PAGEUP',\n            34: 'PAGEDOWN',\n            36: 'HOME',\n            35: 'END',\n        };\n        /** @type {?} */\n        const actions = this.getKeyActions(currentValue);\n        /** @type {?} */\n        const key = keys[keyCode];\n        /** @type {?} */\n        const action = actions[key];\n        if (ValueHelper.isNullOrUndefined(action) || ValueHelper.isNullOrUndefined(this.currentTrackingPointer)) {\n            return;\n        }\n        event.preventDefault();\n        if (this.firstKeyDown) {\n            this.firstKeyDown = false;\n            this.userChangeStart.emit(this.getChangeContext());\n        }\n        /** @type {?} */\n        const actionValue = MathHelper.clampToRange(action, this.viewOptions.floor, this.viewOptions.ceil);\n        /** @type {?} */\n        const newValue = this.roundStep(actionValue);\n        if (!this.viewOptions.draggableRangeOnly) {\n            this.positionTrackingHandle(newValue);\n        }\n        else {\n            /** @type {?} */\n            const difference = this.viewHighValue - this.viewLowValue;\n            /** @type {?} */\n            let newMinValue;\n            /** @type {?} */\n            let newMaxValue;\n            if (this.currentTrackingPointer === PointerType.Min) {\n                newMinValue = newValue;\n                newMaxValue = newValue + difference;\n                if (newMaxValue > this.viewOptions.ceil) {\n                    newMaxValue = this.viewOptions.ceil;\n                    newMinValue = newMaxValue - difference;\n                }\n            }\n            else if (this.currentTrackingPointer === PointerType.Max) {\n                newMaxValue = newValue;\n                newMinValue = newValue - difference;\n                if (newMinValue < this.viewOptions.floor) {\n                    newMinValue = this.viewOptions.floor;\n                    newMaxValue = newMinValue + difference;\n                }\n            }\n            this.positionTrackingBar(newMinValue, newMaxValue);\n        }\n    }\n    /**\n     * @param {?} pointerType\n     * @param {?} event\n     * @param {?} bindMove\n     * @param {?} bindEnd\n     * @return {?}\n     */\n    onDragStart(pointerType, event, bindMove, bindEnd) {\n        /** @type {?} */\n        const position = this.getEventPosition(event);\n        this.dragging = new Dragging();\n        this.dragging.active = true;\n        this.dragging.value = this.positionToValue(position);\n        this.dragging.difference = this.viewHighValue - this.viewLowValue;\n        this.dragging.lowLimit = this.viewOptions.rightToLeft\n            ? this.minHandleElement.position - position\n            : position - this.minHandleElement.position;\n        this.dragging.highLimit = this.viewOptions.rightToLeft\n            ? position - this.maxHandleElement.position\n            : this.maxHandleElement.position - position;\n        this.onStart(pointerType, event, bindMove, bindEnd);\n    }\n    /**\n     * Get min value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft\n     * @param {?} newPos\n     * @param {?} outOfBounds\n     * @param {?} isAbove\n     * @return {?}\n     */\n    getMinValue(newPos, outOfBounds, isAbove) {\n        /** @type {?} */\n        const isRTL = this.viewOptions.rightToLeft;\n        /** @type {?} */\n        let value = null;\n        if (outOfBounds) {\n            if (isAbove) {\n                value = isRTL\n                    ? this.viewOptions.floor\n                    : this.viewOptions.ceil - this.dragging.difference;\n            }\n            else {\n                value = isRTL\n                    ? this.viewOptions.ceil - this.dragging.difference\n                    : this.viewOptions.floor;\n            }\n        }\n        else {\n            value = isRTL\n                ? this.positionToValue(newPos + this.dragging.lowLimit)\n                : this.positionToValue(newPos - this.dragging.lowLimit);\n        }\n        return this.roundStep(value);\n    }\n    /**\n     * Get max value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft\n     * @param {?} newPos\n     * @param {?} outOfBounds\n     * @param {?} isAbove\n     * @return {?}\n     */\n    getMaxValue(newPos, outOfBounds, isAbove) {\n        /** @type {?} */\n        const isRTL = this.viewOptions.rightToLeft;\n        /** @type {?} */\n        let value = null;\n        if (outOfBounds) {\n            if (isAbove) {\n                value = isRTL\n                    ? this.viewOptions.floor + this.dragging.difference\n                    : this.viewOptions.ceil;\n            }\n            else {\n                value = isRTL\n                    ? this.viewOptions.ceil\n                    : this.viewOptions.floor + this.dragging.difference;\n            }\n        }\n        else {\n            if (isRTL) {\n                value =\n                    this.positionToValue(newPos + this.dragging.lowLimit) +\n                        this.dragging.difference;\n            }\n            else {\n                value =\n                    this.positionToValue(newPos - this.dragging.lowLimit) +\n                        this.dragging.difference;\n            }\n        }\n        return this.roundStep(value);\n    }\n    /**\n     * @param {?=} event\n     * @return {?}\n     */\n    onDragMove(event) {\n        /** @type {?} */\n        const newPos = this.getEventPosition(event);\n        if (this.viewOptions.animate && !this.viewOptions.animateOnMove) {\n            if (this.moving) {\n                this.sliderElementAnimateClass = false;\n            }\n        }\n        this.moving = true;\n        /** @type {?} */\n        let ceilLimit;\n        /** @type {?} */\n        let floorLimit;\n        /** @type {?} */\n        let floorHandleElement;\n        /** @type {?} */\n        let ceilHandleElement;\n        if (this.viewOptions.rightToLeft) {\n            ceilLimit = this.dragging.lowLimit;\n            floorLimit = this.dragging.highLimit;\n            floorHandleElement = this.maxHandleElement;\n            ceilHandleElement = this.minHandleElement;\n        }\n        else {\n            ceilLimit = this.dragging.highLimit;\n            floorLimit = this.dragging.lowLimit;\n            floorHandleElement = this.minHandleElement;\n            ceilHandleElement = this.maxHandleElement;\n        }\n        /** @type {?} */\n        const isUnderFloorLimit = (newPos <= floorLimit);\n        /** @type {?} */\n        const isOverCeilLimit = (newPos >= this.maxHandlePosition - ceilLimit);\n        /** @type {?} */\n        let newMinValue;\n        /** @type {?} */\n        let newMaxValue;\n        if (isUnderFloorLimit) {\n            if (floorHandleElement.position === 0) {\n                return;\n            }\n            newMinValue = this.getMinValue(newPos, true, false);\n            newMaxValue = this.getMaxValue(newPos, true, false);\n        }\n        else if (isOverCeilLimit) {\n            if (ceilHandleElement.position === this.maxHandlePosition) {\n                return;\n            }\n            newMaxValue = this.getMaxValue(newPos, true, true);\n            newMinValue = this.getMinValue(newPos, true, true);\n        }\n        else {\n            newMinValue = this.getMinValue(newPos, false, false);\n            newMaxValue = this.getMaxValue(newPos, false, false);\n        }\n        this.positionTrackingBar(newMinValue, newMaxValue);\n    }\n    /**\n     * @param {?} newMinValue\n     * @param {?} newMaxValue\n     * @return {?}\n     */\n    positionTrackingBar(newMinValue, newMaxValue) {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) &&\n            newMinValue < this.viewOptions.minLimit) {\n            newMinValue = this.viewOptions.minLimit;\n            newMaxValue = MathHelper.roundToPrecisionLimit(newMinValue + this.dragging.difference, this.viewOptions.precisionLimit);\n        }\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) &&\n            newMaxValue > this.viewOptions.maxLimit) {\n            newMaxValue = this.viewOptions.maxLimit;\n            newMinValue = MathHelper.roundToPrecisionLimit(newMaxValue - this.dragging.difference, this.viewOptions.precisionLimit);\n        }\n        this.viewLowValue = newMinValue;\n        this.viewHighValue = newMaxValue;\n        this.applyViewChange();\n        this.updateHandles(PointerType.Min, this.valueToPosition(newMinValue));\n        this.updateHandles(PointerType.Max, this.valueToPosition(newMaxValue));\n    }\n    /**\n     * @param {?} newValue\n     * @return {?}\n     */\n    positionTrackingHandle(newValue) {\n        newValue = this.applyMinMaxLimit(newValue);\n        if (this.range) {\n            if (this.viewOptions.pushRange) {\n                newValue = this.applyPushRange(newValue);\n            }\n            else {\n                if (this.viewOptions.noSwitching) {\n                    if (this.currentTrackingPointer === PointerType.Min &&\n                        newValue > this.viewHighValue) {\n                        newValue = this.applyMinMaxRange(this.viewHighValue);\n                    }\n                    else if (this.currentTrackingPointer === PointerType.Max &&\n                        newValue < this.viewLowValue) {\n                        newValue = this.applyMinMaxRange(this.viewLowValue);\n                    }\n                }\n                newValue = this.applyMinMaxRange(newValue);\n                /* This is to check if we need to switch the min and max handles */\n                if (this.currentTrackingPointer === PointerType.Min && newValue > this.viewHighValue) {\n                    this.viewLowValue = this.viewHighValue;\n                    this.applyViewChange();\n                    this.updateHandles(PointerType.Min, this.maxHandleElement.position);\n                    this.updateAriaAttributes();\n                    this.currentTrackingPointer = PointerType.Max;\n                    this.minHandleElement.active = false;\n                    this.maxHandleElement.active = true;\n                    if (this.viewOptions.keyboardSupport) {\n                        this.maxHandleElement.focus();\n                    }\n                }\n                else if (this.currentTrackingPointer === PointerType.Max &&\n                    newValue < this.viewLowValue) {\n                    this.viewHighValue = this.viewLowValue;\n                    this.applyViewChange();\n                    this.updateHandles(PointerType.Max, this.minHandleElement.position);\n                    this.updateAriaAttributes();\n                    this.currentTrackingPointer = PointerType.Min;\n                    this.maxHandleElement.active = false;\n                    this.minHandleElement.active = true;\n                    if (this.viewOptions.keyboardSupport) {\n                        this.minHandleElement.focus();\n                    }\n                }\n            }\n        }\n        if (this.getCurrentTrackingValue() !== newValue) {\n            if (this.currentTrackingPointer === PointerType.Min) {\n                this.viewLowValue = newValue;\n                this.applyViewChange();\n            }\n            else if (this.currentTrackingPointer === PointerType.Max) {\n                this.viewHighValue = newValue;\n                this.applyViewChange();\n            }\n            this.updateHandles(this.currentTrackingPointer, this.valueToPosition(newValue));\n            this.updateAriaAttributes();\n        }\n    }\n    /**\n     * @param {?} newValue\n     * @return {?}\n     */\n    applyMinMaxLimit(newValue) {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) && newValue < this.viewOptions.minLimit) {\n            return this.viewOptions.minLimit;\n        }\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) && newValue > this.viewOptions.maxLimit) {\n            return this.viewOptions.maxLimit;\n        }\n        return newValue;\n    }\n    /**\n     * @param {?} newValue\n     * @return {?}\n     */\n    applyMinMaxRange(newValue) {\n        /** @type {?} */\n        const oppositeValue = (this.currentTrackingPointer === PointerType.Min)\n            ? this.viewHighValue\n            : this.viewLowValue;\n        /** @type {?} */\n        const difference = Math.abs(newValue - oppositeValue);\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.minRange)) {\n            if (difference < this.viewOptions.minRange) {\n                if (this.currentTrackingPointer === PointerType.Min) {\n                    return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.minRange, this.viewOptions.precisionLimit);\n                }\n                else if (this.currentTrackingPointer === PointerType.Max) {\n                    return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.minRange, this.viewOptions.precisionLimit);\n                }\n            }\n        }\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxRange)) {\n            if (difference > this.viewOptions.maxRange) {\n                if (this.currentTrackingPointer === PointerType.Min) {\n                    return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n                }\n                else if (this.currentTrackingPointer === PointerType.Max) {\n                    return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n                }\n            }\n        }\n        return newValue;\n    }\n    /**\n     * @param {?} newValue\n     * @return {?}\n     */\n    applyPushRange(newValue) {\n        /** @type {?} */\n        const difference = (this.currentTrackingPointer === PointerType.Min)\n            ? this.viewHighValue - newValue\n            : newValue - this.viewLowValue;\n        /** @type {?} */\n        const minRange = (!ValueHelper.isNullOrUndefined(this.viewOptions.minRange))\n            ? this.viewOptions.minRange\n            : this.viewOptions.step;\n        /** @type {?} */\n        const maxRange = this.viewOptions.maxRange;\n        // if smaller than minRange\n        if (difference < minRange) {\n            if (this.currentTrackingPointer === PointerType.Min) {\n                this.viewHighValue = MathHelper.roundToPrecisionLimit(Math.min(newValue + minRange, this.viewOptions.ceil), this.viewOptions.precisionLimit);\n                newValue = MathHelper.roundToPrecisionLimit(this.viewHighValue - minRange, this.viewOptions.precisionLimit);\n                this.applyViewChange();\n                this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n            }\n            else if (this.currentTrackingPointer === PointerType.Max) {\n                this.viewLowValue = MathHelper.roundToPrecisionLimit(Math.max(newValue - minRange, this.viewOptions.floor), this.viewOptions.precisionLimit);\n                newValue = MathHelper.roundToPrecisionLimit(this.viewLowValue + minRange, this.viewOptions.precisionLimit);\n                this.applyViewChange();\n                this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n            }\n            this.updateAriaAttributes();\n        }\n        else if (!ValueHelper.isNullOrUndefined(maxRange) && difference > maxRange) {\n            // if greater than maxRange\n            if (this.currentTrackingPointer === PointerType.Min) {\n                this.viewHighValue = MathHelper.roundToPrecisionLimit(newValue + maxRange, this.viewOptions.precisionLimit);\n                this.applyViewChange();\n                this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n            }\n            else if (this.currentTrackingPointer === PointerType.Max) {\n                this.viewLowValue = MathHelper.roundToPrecisionLimit(newValue - maxRange, this.viewOptions.precisionLimit);\n                this.applyViewChange();\n                this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n            }\n            this.updateAriaAttributes();\n        }\n        return newValue;\n    }\n    /**\n     * @return {?}\n     */\n    getChangeContext() {\n        /** @type {?} */\n        const changeContext = new ChangeContext();\n        changeContext.pointerType = this.currentTrackingPointer;\n        changeContext.value = +this.value;\n        if (this.range) {\n            changeContext.highValue = +this.highValue;\n        }\n        return changeContext;\n    }\n}\nSliderComponent.ɵfac = function SliderComponent_Factory(t) { return new (t || SliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\nSliderComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SliderComponent, selectors: [[\"ngx-slider\"]], contentQueries: function SliderComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c0, 5);\n    } if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);\n    } }, viewQuery: function SliderComponent_Query(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c1, 5, SliderElementDirective);\n        ɵngcc0.ɵɵviewQuery(_c2, 5, SliderElementDirective);\n        ɵngcc0.ɵɵviewQuery(_c3, 5, SliderElementDirective);\n        ɵngcc0.ɵɵviewQuery(_c4, 5, SliderElementDirective);\n        ɵngcc0.ɵɵviewQuery(_c5, 5, SliderHandleDirective);\n        ɵngcc0.ɵɵviewQuery(_c6, 5, SliderHandleDirective);\n        ɵngcc0.ɵɵviewQuery(_c7, 5, SliderLabelDirective);\n        ɵngcc0.ɵɵviewQuery(_c8, 5, SliderLabelDirective);\n        ɵngcc0.ɵɵviewQuery(_c9, 5, SliderLabelDirective);\n        ɵngcc0.ɵɵviewQuery(_c10, 5, SliderLabelDirective);\n        ɵngcc0.ɵɵviewQuery(_c11, 5, SliderLabelDirective);\n        ɵngcc0.ɵɵviewQuery(_c12, 5, SliderElementDirective);\n    } if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.leftOuterSelectionBarElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rightOuterSelectionBarElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fullBarElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.selectionBarElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.minHandleElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.maxHandleElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.floorLabelElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ceilLabelElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.minHandleLabelElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.maxHandleLabelElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.combinedLabelElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);\n    } }, hostAttrs: [1, \"ngx-slider\"], hostVars: 8, hostBindings: function SliderComponent_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"resize\", function SliderComponent_resize_HostBindingHandler($event) { return ctx.onResize($event); }, false, ɵngcc0.ɵɵresolveWindow);\n    } if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"disabled\", ctx.sliderElementDisabledAttr)(\"aria-label\", ctx.sliderElementAriaLabel);\n        ɵngcc0.ɵɵclassProp(\"vertical\", ctx.sliderElementVerticalClass)(\"animate\", ctx.sliderElementAnimateClass)(\"with-legend\", ctx.sliderElementWithLegendClass);\n    } }, inputs: { value: \"value\", highValue: \"highValue\", options: \"options\", manualRefresh: \"manualRefresh\", triggerFocus: \"triggerFocus\" }, outputs: { valueChange: \"valueChange\", highValueChange: \"highValueChange\", userChangeStart: \"userChangeStart\", userChange: \"userChange\", userChangeEnd: \"userChangeEnd\" }, features: [ɵngcc0.ɵɵProvidersFeature([NGX_SLIDER_CONTROL_VALUE_ACCESSOR]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 29, vars: 13, consts: [[\"ngxSliderElement\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bar-wrapper\", \"ngx-slider-left-out-selection\"], [\"leftOuterSelectionBar\", \"\"], [1, \"ngx-slider-span\", \"ngx-slider-bar\"], [\"ngxSliderElement\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bar-wrapper\", \"ngx-slider-right-out-selection\"], [\"rightOuterSelectionBar\", \"\"], [\"ngxSliderElement\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bar-wrapper\", \"ngx-slider-full-bar\"], [\"fullBar\", \"\"], [\"ngxSliderElement\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bar-wrapper\", \"ngx-slider-selection-bar\"], [\"selectionBar\", \"\"], [1, \"ngx-slider-span\", \"ngx-slider-bar\", \"ngx-slider-selection\", 3, \"ngStyle\"], [\"ngxSliderHandle\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-pointer\", \"ngx-slider-pointer-min\", 3, \"ngStyle\"], [\"minHandle\", \"\"], [\"ngxSliderHandle\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-pointer\", \"ngx-slider-pointer-max\", 3, \"ngStyle\"], [\"maxHandle\", \"\"], [\"ngxSliderLabel\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bubble\", \"ngx-slider-limit\", \"ngx-slider-floor\"], [\"floorLabel\", \"\"], [\"ngxSliderLabel\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bubble\", \"ngx-slider-limit\", \"ngx-slider-ceil\"], [\"ceilLabel\", \"\"], [\"ngxSliderLabel\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bubble\", \"ngx-slider-model-value\"], [\"minHandleLabel\", \"\"], [\"ngxSliderLabel\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bubble\", \"ngx-slider-model-high\"], [\"maxHandleLabel\", \"\"], [\"ngxSliderLabel\", \"\", 1, \"ngx-slider-span\", \"ngx-slider-bubble\", \"ngx-slider-combined\"], [\"combinedLabel\", \"\"], [\"ngxSliderElement\", \"\", 1, \"ngx-slider-ticks\", 3, \"hidden\"], [\"ticksElement\", \"\"], [\"class\", \"ngx-slider-tick\", 3, \"ngClass\", \"ngStyle\", 4, \"ngFor\", \"ngForOf\"], [1, \"ngx-slider-tick\", 3, \"ngClass\", \"ngStyle\"], [3, \"template\", \"tooltip\", \"placement\"], [\"class\", \"ngx-slider-span ngx-slider-tick-value\", 3, \"template\", \"tooltip\", \"placement\", \"content\", 4, \"ngIf\"], [\"class\", \"ngx-slider-span ngx-slider-tick-legend\", 3, \"innerHTML\", 4, \"ngIf\"], [1, \"ngx-slider-span\", \"ngx-slider-tick-value\", 3, \"template\", \"tooltip\", \"placement\", \"content\"], [1, \"ngx-slider-span\", \"ngx-slider-tick-legend\", 3, \"innerHTML\"]], template: function SliderComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"span\", 0, 1);\n        ɵngcc0.ɵɵelement(2, \"span\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(3, \"span\", 3, 4);\n        ɵngcc0.ɵɵelement(5, \"span\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(6, \"span\", 5, 6);\n        ɵngcc0.ɵɵelement(8, \"span\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(9, \"span\", 7, 8);\n        ɵngcc0.ɵɵelement(11, \"span\", 9);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelement(12, \"span\", 10, 11)(14, \"span\", 12, 13)(16, \"span\", 14, 15)(18, \"span\", 16, 17)(20, \"span\", 18, 19)(22, \"span\", 20, 21)(24, \"span\", 22, 23);\n        ɵngcc0.ɵɵelementStart(26, \"span\", 24, 25);\n        ɵngcc0.ɵɵtemplate(28, SliderComponent_span_28_Template, 4, 9, \"span\", 26);\n        ɵngcc0.ɵɵelementEnd();\n    } if (rf & 2) {\n        ɵngcc0.ɵɵadvance(6);\n        ɵngcc0.ɵɵclassProp(\"ngx-slider-transparent\", ctx.fullBarTransparentClass);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵclassProp(\"ngx-slider-draggable\", ctx.selectionBarDraggableClass);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.barStyle);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.minPointerStyle);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵstyleProp(\"display\", ctx.range ? \"inherit\" : \"none\");\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.maxPointerStyle);\n        ɵngcc0.ɵɵadvance(12);\n        ɵngcc0.ɵɵclassProp(\"ngx-slider-ticks-values-under\", ctx.ticksUnderValuesClass);\n        ɵngcc0.ɵɵproperty(\"hidden\", !ctx.showTicks);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.ticks);\n    } }, dependencies: function () { return [ɵngcc1.NgClass, ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgStyle, SliderElementDirective, SliderHandleDirective, SliderLabelDirective, TooltipWrapperComponent]; }, styles: [\".ngx-slider{display:inline-block;position:relative;height:4px;width:100%;margin:35px 0 15px;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;touch-action:pan-y}  .ngx-slider.with-legend{margin-bottom:40px}  .ngx-slider[disabled]{cursor:not-allowed}  .ngx-slider[disabled] .ngx-slider-pointer{cursor:not-allowed;background-color:#d8e0f3}  .ngx-slider[disabled] .ngx-slider-draggable{cursor:not-allowed}  .ngx-slider[disabled] .ngx-slider-selection{background:#8b91a2}  .ngx-slider[disabled] .ngx-slider-tick{cursor:not-allowed}  .ngx-slider[disabled] .ngx-slider-tick.ngx-slider-selected{background:#8b91a2}  .ngx-slider .ngx-slider-span{white-space:nowrap;position:absolute;display:inline-block}  .ngx-slider .ngx-slider-base{width:100%;height:100%;padding:0}  .ngx-slider .ngx-slider-bar-wrapper{left:0;box-sizing:border-box;margin-top:-16px;padding-top:16px;width:100%;height:32px;z-index:1}  .ngx-slider .ngx-slider-draggable{cursor:move}  .ngx-slider .ngx-slider-bar{left:0;width:100%;height:4px;z-index:1;background:#d8e0f3;border-radius:2px}  .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-transparent .ngx-slider-bar{background:0 0}  .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-left-out-selection .ngx-slider-bar{background:#df002d}  .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-right-out-selection .ngx-slider-bar{background:#03a688}  .ngx-slider .ngx-slider-selection{z-index:2;background:#0db9f0;border-radius:2px}  .ngx-slider .ngx-slider-pointer{cursor:pointer;width:32px;height:32px;top:-14px;background-color:#0db9f0;z-index:3;border-radius:16px}  .ngx-slider .ngx-slider-pointer:after{content:'';width:8px;height:8px;position:absolute;top:12px;left:12px;border-radius:4px;background:#fff}  .ngx-slider .ngx-slider-pointer:hover:after{background-color:#fff}  .ngx-slider .ngx-slider-pointer.ngx-slider-active{z-index:4}  .ngx-slider .ngx-slider-pointer.ngx-slider-active:after{background-color:#451aff}  .ngx-slider .ngx-slider-bubble{cursor:default;bottom:16px;padding:1px 3px;color:#55637d;font-size:16px}  .ngx-slider .ngx-slider-bubble.ngx-slider-limit{color:#55637d}  .ngx-slider .ngx-slider-ticks{box-sizing:border-box;width:100%;height:0;position:absolute;left:0;top:-3px;margin:0;z-index:1;list-style:none}  .ngx-slider .ngx-slider-ticks-values-under .ngx-slider-tick-value{top:auto;bottom:-36px}  .ngx-slider .ngx-slider-tick{text-align:center;cursor:pointer;width:10px;height:10px;background:#d8e0f3;border-radius:50%;position:absolute;top:0;left:0;margin-left:11px}  .ngx-slider .ngx-slider-tick.ngx-slider-selected{background:#0db9f0}  .ngx-slider .ngx-slider-tick-value{position:absolute;top:-34px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0)}  .ngx-slider .ngx-slider-tick-legend{position:absolute;top:24px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);max-width:50px;white-space:normal}  .ngx-slider.vertical{position:relative;width:4px;height:100%;margin:0 20px;padding:0;vertical-align:baseline;touch-action:pan-x}  .ngx-slider.vertical .ngx-slider-base{width:100%;height:100%;padding:0}  .ngx-slider.vertical .ngx-slider-bar-wrapper{top:auto;left:0;margin:0 0 0 -16px;padding:0 0 0 16px;height:100%;width:32px}  .ngx-slider.vertical .ngx-slider-bar{bottom:0;left:auto;width:4px;height:100%}  .ngx-slider.vertical .ngx-slider-pointer{left:-14px!important;top:auto;bottom:0}  .ngx-slider.vertical .ngx-slider-bubble{left:16px!important;bottom:0}  .ngx-slider.vertical .ngx-slider-ticks{height:100%;width:0;left:-3px;top:0;z-index:1}  .ngx-slider.vertical .ngx-slider-tick{vertical-align:middle;margin-left:auto;margin-top:11px}  .ngx-slider.vertical .ngx-slider-tick-value{left:24px;top:auto;-webkit-transform:translate(0,-28%);transform:translate(0,-28%)}  .ngx-slider.vertical .ngx-slider-tick-legend{top:auto;right:24px;-webkit-transform:translate(0,-28%);transform:translate(0,-28%);max-width:none;white-space:nowrap}  .ngx-slider.vertical .ngx-slider-ticks-values-under .ngx-slider-tick-value{bottom:auto;left:auto;right:24px}  .ngx-slider *{transition:none}  .ngx-slider.animate .ngx-slider-bar-wrapper{transition:.3s linear}  .ngx-slider.animate .ngx-slider-selection{transition:background-color .3s linear}  .ngx-slider.animate .ngx-slider-pointer{transition:.3s linear}  .ngx-slider.animate .ngx-slider-pointer:after{transition:.3s linear}  .ngx-slider.animate .ngx-slider-bubble{transition:.3s linear}  .ngx-slider.animate .ngx-slider-bubble.ngx-slider-limit{transition:opacity .3s linear}  .ngx-slider.animate .ngx-slider-bubble.ngx-slider-combined{transition:opacity .3s linear}  .ngx-slider.animate .ngx-slider-tick{transition:background-color .3s linear}\"] });\n/** @nocollapse */\nSliderComponent.ctorParameters = () => [\n    { type: Renderer2 },\n    { type: ElementRef },\n    { type: ChangeDetectorRef },\n    { type: NgZone }\n];\nSliderComponent.propDecorators = {\n    value: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    highValue: [{ type: Input }],\n    highValueChange: [{ type: Output }],\n    options: [{ type: Input }],\n    userChangeStart: [{ type: Output }],\n    userChange: [{ type: Output }],\n    userChangeEnd: [{ type: Output }],\n    manualRefresh: [{ type: Input }],\n    triggerFocus: [{ type: Input }],\n    leftOuterSelectionBarElement: [{ type: ViewChild, args: ['leftOuterSelectionBar', { read: SliderElementDirective },] }],\n    rightOuterSelectionBarElement: [{ type: ViewChild, args: ['rightOuterSelectionBar', { read: SliderElementDirective },] }],\n    fullBarElement: [{ type: ViewChild, args: ['fullBar', { read: SliderElementDirective },] }],\n    selectionBarElement: [{ type: ViewChild, args: ['selectionBar', { read: SliderElementDirective },] }],\n    minHandleElement: [{ type: ViewChild, args: ['minHandle', { read: SliderHandleDirective },] }],\n    maxHandleElement: [{ type: ViewChild, args: ['maxHandle', { read: SliderHandleDirective },] }],\n    floorLabelElement: [{ type: ViewChild, args: ['floorLabel', { read: SliderLabelDirective },] }],\n    ceilLabelElement: [{ type: ViewChild, args: ['ceilLabel', { read: SliderLabelDirective },] }],\n    minHandleLabelElement: [{ type: ViewChild, args: ['minHandleLabel', { read: SliderLabelDirective },] }],\n    maxHandleLabelElement: [{ type: ViewChild, args: ['maxHandleLabel', { read: SliderLabelDirective },] }],\n    combinedLabelElement: [{ type: ViewChild, args: ['combinedLabel', { read: SliderLabelDirective },] }],\n    ticksElement: [{ type: ViewChild, args: ['ticksElement', { read: SliderElementDirective },] }],\n    tooltipTemplate: [{ type: ContentChild, args: ['tooltipTemplate',] }],\n    sliderElementVerticalClass: [{ type: HostBinding, args: ['class.vertical',] }],\n    sliderElementAnimateClass: [{ type: HostBinding, args: ['class.animate',] }],\n    sliderElementWithLegendClass: [{ type: HostBinding, args: ['class.with-legend',] }],\n    sliderElementDisabledAttr: [{ type: HostBinding, args: ['attr.disabled',] }],\n    sliderElementAriaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],\n    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SliderComponent, [{\n        type: Component,\n        args: [{ selector: 'ngx-slider', template: `<!-- // 0 Left selection bar outside two handles -->\n<span ngxSliderElement #leftOuterSelectionBar class=\"ngx-slider-span ngx-slider-bar-wrapper ngx-slider-left-out-selection\">\n  <span class=\"ngx-slider-span ngx-slider-bar\"></span>\n</span>\n<!-- // 1 Right selection bar outside two handles -->\n<span ngxSliderElement #rightOuterSelectionBar class=\"ngx-slider-span ngx-slider-bar-wrapper ngx-slider-right-out-selection\">\n  <span class=\"ngx-slider-span ngx-slider-bar\"></span>\n</span>\n<!-- // 2 The whole slider bar -->\n<span ngxSliderElement #fullBar [class.ngx-slider-transparent]=\"fullBarTransparentClass\" class=\"ngx-slider-span ngx-slider-bar-wrapper ngx-slider-full-bar\">\n  <span class=\"ngx-slider-span ngx-slider-bar\"></span>\n</span>\n<!-- // 3 Selection bar between two handles -->\n<span ngxSliderElement #selectionBar [class.ngx-slider-draggable]=\"selectionBarDraggableClass\" class=\"ngx-slider-span ngx-slider-bar-wrapper ngx-slider-selection-bar\">\n  <span class=\"ngx-slider-span ngx-slider-bar ngx-slider-selection\" [ngStyle]=\"barStyle\"></span>\n</span>\n<!-- // 4 Low slider handle -->\n<span ngxSliderHandle #minHandle class=\"ngx-slider-span ngx-slider-pointer ngx-slider-pointer-min\" [ngStyle]=minPointerStyle></span>\n<!-- // 5 High slider handle -->\n<span ngxSliderHandle #maxHandle [style.display]=\"range ? 'inherit' : 'none'\" class=\"ngx-slider-span ngx-slider-pointer ngx-slider-pointer-max\" [ngStyle]=maxPointerStyle></span>\n<!-- // 6 Floor label -->\n<span ngxSliderLabel #floorLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-limit ngx-slider-floor\"></span>\n<!-- // 7 Ceiling label -->\n<span ngxSliderLabel #ceilLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-limit ngx-slider-ceil\"></span>\n<!-- // 8 Label above the low slider handle -->\n<span ngxSliderLabel #minHandleLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-model-value\"></span>\n<!-- // 9 Label above the high slider handle -->\n<span ngxSliderLabel #maxHandleLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-model-high\"></span>\n<!-- // 10 Combined range label when the slider handles are close ex. 15 - 17 -->\n<span ngxSliderLabel #combinedLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-combined\"></span>\n<!-- // 11 The ticks -->\n<span ngxSliderElement #ticksElement [hidden]=\"!showTicks\" [class.ngx-slider-ticks-values-under]=\"ticksUnderValuesClass\" class=\"ngx-slider-ticks\">\n  <span *ngFor=\"let t of ticks\" class=\"ngx-slider-tick\" [ngClass]=\"{'ngx-slider-selected': t.selected}\" [ngStyle]=\"t.style\">\n    <ngx-slider-tooltip-wrapper [template]=\"tooltipTemplate\" [tooltip]=\"t.tooltip\" [placement]=\"t.tooltipPlacement\"></ngx-slider-tooltip-wrapper>\n    <ngx-slider-tooltip-wrapper *ngIf=\"t.value != null\" class=\"ngx-slider-span ngx-slider-tick-value\"\n        [template]=\"tooltipTemplate\" [tooltip]=\"t.valueTooltip\" [placement]=\"t.valueTooltipPlacement\" [content]=\"t.value\"></ngx-slider-tooltip-wrapper>\n    <span *ngIf=\"t.legend != null\" class=\"ngx-slider-span ngx-slider-tick-legend\" [innerHTML]=\"t.legend\"></span>\n  </span>\n</span>`, host: { class: 'ngx-slider' }, providers: [NGX_SLIDER_CONTROL_VALUE_ACCESSOR], styles: [\"::ng-deep .ngx-slider{display:inline-block;position:relative;height:4px;width:100%;margin:35px 0 15px;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;touch-action:pan-y}::ng-deep .ngx-slider.with-legend{margin-bottom:40px}::ng-deep .ngx-slider[disabled]{cursor:not-allowed}::ng-deep .ngx-slider[disabled] .ngx-slider-pointer{cursor:not-allowed;background-color:#d8e0f3}::ng-deep .ngx-slider[disabled] .ngx-slider-draggable{cursor:not-allowed}::ng-deep .ngx-slider[disabled] .ngx-slider-selection{background:#8b91a2}::ng-deep .ngx-slider[disabled] .ngx-slider-tick{cursor:not-allowed}::ng-deep .ngx-slider[disabled] .ngx-slider-tick.ngx-slider-selected{background:#8b91a2}::ng-deep .ngx-slider .ngx-slider-span{white-space:nowrap;position:absolute;display:inline-block}::ng-deep .ngx-slider .ngx-slider-base{width:100%;height:100%;padding:0}::ng-deep .ngx-slider .ngx-slider-bar-wrapper{left:0;box-sizing:border-box;margin-top:-16px;padding-top:16px;width:100%;height:32px;z-index:1}::ng-deep .ngx-slider .ngx-slider-draggable{cursor:move}::ng-deep .ngx-slider .ngx-slider-bar{left:0;width:100%;height:4px;z-index:1;background:#d8e0f3;border-radius:2px}::ng-deep .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-transparent .ngx-slider-bar{background:0 0}::ng-deep .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-left-out-selection .ngx-slider-bar{background:#df002d}::ng-deep .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-right-out-selection .ngx-slider-bar{background:#03a688}::ng-deep .ngx-slider .ngx-slider-selection{z-index:2;background:#0db9f0;border-radius:2px}::ng-deep .ngx-slider .ngx-slider-pointer{cursor:pointer;width:32px;height:32px;top:-14px;background-color:#0db9f0;z-index:3;border-radius:16px}::ng-deep .ngx-slider .ngx-slider-pointer:after{content:'';width:8px;height:8px;position:absolute;top:12px;left:12px;border-radius:4px;background:#fff}::ng-deep .ngx-slider .ngx-slider-pointer:hover:after{background-color:#fff}::ng-deep .ngx-slider .ngx-slider-pointer.ngx-slider-active{z-index:4}::ng-deep .ngx-slider .ngx-slider-pointer.ngx-slider-active:after{background-color:#451aff}::ng-deep .ngx-slider .ngx-slider-bubble{cursor:default;bottom:16px;padding:1px 3px;color:#55637d;font-size:16px}::ng-deep .ngx-slider .ngx-slider-bubble.ngx-slider-limit{color:#55637d}::ng-deep .ngx-slider .ngx-slider-ticks{box-sizing:border-box;width:100%;height:0;position:absolute;left:0;top:-3px;margin:0;z-index:1;list-style:none}::ng-deep .ngx-slider .ngx-slider-ticks-values-under .ngx-slider-tick-value{top:auto;bottom:-36px}::ng-deep .ngx-slider .ngx-slider-tick{text-align:center;cursor:pointer;width:10px;height:10px;background:#d8e0f3;border-radius:50%;position:absolute;top:0;left:0;margin-left:11px}::ng-deep .ngx-slider .ngx-slider-tick.ngx-slider-selected{background:#0db9f0}::ng-deep .ngx-slider .ngx-slider-tick-value{position:absolute;top:-34px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0)}::ng-deep .ngx-slider .ngx-slider-tick-legend{position:absolute;top:24px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);max-width:50px;white-space:normal}::ng-deep .ngx-slider.vertical{position:relative;width:4px;height:100%;margin:0 20px;padding:0;vertical-align:baseline;touch-action:pan-x}::ng-deep .ngx-slider.vertical .ngx-slider-base{width:100%;height:100%;padding:0}::ng-deep .ngx-slider.vertical .ngx-slider-bar-wrapper{top:auto;left:0;margin:0 0 0 -16px;padding:0 0 0 16px;height:100%;width:32px}::ng-deep .ngx-slider.vertical .ngx-slider-bar{bottom:0;left:auto;width:4px;height:100%}::ng-deep .ngx-slider.vertical .ngx-slider-pointer{left:-14px!important;top:auto;bottom:0}::ng-deep .ngx-slider.vertical .ngx-slider-bubble{left:16px!important;bottom:0}::ng-deep .ngx-slider.vertical .ngx-slider-ticks{height:100%;width:0;left:-3px;top:0;z-index:1}::ng-deep .ngx-slider.vertical .ngx-slider-tick{vertical-align:middle;margin-left:auto;margin-top:11px}::ng-deep .ngx-slider.vertical .ngx-slider-tick-value{left:24px;top:auto;-webkit-transform:translate(0,-28%);transform:translate(0,-28%)}::ng-deep .ngx-slider.vertical .ngx-slider-tick-legend{top:auto;right:24px;-webkit-transform:translate(0,-28%);transform:translate(0,-28%);max-width:none;white-space:nowrap}::ng-deep .ngx-slider.vertical .ngx-slider-ticks-values-under .ngx-slider-tick-value{bottom:auto;left:auto;right:24px}::ng-deep .ngx-slider *{transition:none}::ng-deep .ngx-slider.animate .ngx-slider-bar-wrapper{transition:.3s linear}::ng-deep .ngx-slider.animate .ngx-slider-selection{transition:background-color .3s linear}::ng-deep .ngx-slider.animate .ngx-slider-pointer{transition:.3s linear}::ng-deep .ngx-slider.animate .ngx-slider-pointer:after{transition:.3s linear}::ng-deep .ngx-slider.animate .ngx-slider-bubble{transition:.3s linear}::ng-deep .ngx-slider.animate .ngx-slider-bubble.ngx-slider-limit{transition:opacity .3s linear}::ng-deep .ngx-slider.animate .ngx-slider-bubble.ngx-slider-combined{transition:opacity .3s linear}::ng-deep .ngx-slider.animate .ngx-slider-tick{transition:background-color .3s linear}\"] }]\n    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }]; }, { value: [{\n            type: Input\n        }], valueChange: [{\n            type: Output\n        }], highValue: [{\n            type: Input\n        }], highValueChange: [{\n            type: Output\n        }], options: [{\n            type: Input\n        }], userChangeStart: [{\n            type: Output\n        }], userChange: [{\n            type: Output\n        }], userChangeEnd: [{\n            type: Output\n        }], sliderElementVerticalClass: [{\n            type: HostBinding,\n            args: ['class.vertical']\n        }], sliderElementAnimateClass: [{\n            type: HostBinding,\n            args: ['class.animate']\n        }], sliderElementWithLegendClass: [{\n            type: HostBinding,\n            args: ['class.with-legend']\n        }], sliderElementDisabledAttr: [{\n            type: HostBinding,\n            args: ['attr.disabled']\n        }], sliderElementAriaLabel: [{\n            type: HostBinding,\n            args: ['attr.aria-label']\n        }], manualRefresh: [{\n            type: Input\n        }], triggerFocus: [{\n            type: Input\n        }], \n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    onResize: [{\n            type: HostListener,\n            args: ['window:resize', ['$event']]\n        }], leftOuterSelectionBarElement: [{\n            type: ViewChild,\n            args: ['leftOuterSelectionBar', { read: SliderElementDirective }]\n        }], rightOuterSelectionBarElement: [{\n            type: ViewChild,\n            args: ['rightOuterSelectionBar', { read: SliderElementDirective }]\n        }], fullBarElement: [{\n            type: ViewChild,\n            args: ['fullBar', { read: SliderElementDirective }]\n        }], selectionBarElement: [{\n            type: ViewChild,\n            args: ['selectionBar', { read: SliderElementDirective }]\n        }], minHandleElement: [{\n            type: ViewChild,\n            args: ['minHandle', { read: SliderHandleDirective }]\n        }], maxHandleElement: [{\n            type: ViewChild,\n            args: ['maxHandle', { read: SliderHandleDirective }]\n        }], floorLabelElement: [{\n            type: ViewChild,\n            args: ['floorLabel', { read: SliderLabelDirective }]\n        }], ceilLabelElement: [{\n            type: ViewChild,\n            args: ['ceilLabel', { read: SliderLabelDirective }]\n        }], minHandleLabelElement: [{\n            type: ViewChild,\n            args: ['minHandleLabel', { read: SliderLabelDirective }]\n        }], maxHandleLabelElement: [{\n            type: ViewChild,\n            args: ['maxHandleLabel', { read: SliderLabelDirective }]\n        }], combinedLabelElement: [{\n            type: ViewChild,\n            args: ['combinedLabel', { read: SliderLabelDirective }]\n        }], ticksElement: [{\n            type: ViewChild,\n            args: ['ticksElement', { read: SliderElementDirective }]\n        }], tooltipTemplate: [{\n            type: ContentChild,\n            args: ['tooltipTemplate']\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nclass TooltipWrapperComponent {\n}\nTooltipWrapperComponent.ɵfac = function TooltipWrapperComponent_Factory(t) { return new (t || TooltipWrapperComponent)(); };\nTooltipWrapperComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TooltipWrapperComponent, selectors: [[\"ngx-slider-tooltip-wrapper\"]], inputs: { template: \"template\", tooltip: \"tooltip\", placement: \"placement\", content: \"content\" }, decls: 2, vars: 2, consts: [[4, \"ngIf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"ngx-slider-inner-tooltip\"]], template: function TooltipWrapperComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TooltipWrapperComponent_ng_container_0_Template, 2, 6, \"ng-container\", 0);\n        ɵngcc0.ɵɵtemplate(1, TooltipWrapperComponent_ng_container_1_Template, 3, 3, \"ng-container\", 0);\n    } if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.template);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.template);\n    } }, dependencies: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], styles: [\".ngx-slider-inner-tooltip[_ngcontent-%COMP%]{height:100%}\"] });\nTooltipWrapperComponent.propDecorators = {\n    template: [{ type: Input }],\n    tooltip: [{ type: Input }],\n    placement: [{ type: Input }],\n    content: [{ type: Input }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipWrapperComponent, [{\n        type: Component,\n        args: [{ selector: 'ngx-slider-tooltip-wrapper', template: `<ng-container *ngIf=\"template\">\n  <ng-template *ngTemplateOutlet=\"template; context: {tooltip: tooltip, placement: placement, content: content}\"></ng-template>\n</ng-container>\n\n<ng-container *ngIf=\"!template\">\n  <div class=\"ngx-slider-inner-tooltip\" [attr.title]=\"tooltip\" [attr.data-tooltip-placement]=\"placement\">\n    {{content}}\n  </div>\n</ng-container>`, styles: [\".ngx-slider-inner-tooltip{height:100%}\"] }]\n    }], null, { template: [{\n            type: Input\n        }], tooltip: [{\n            type: Input\n        }], placement: [{\n            type: Input\n        }], content: [{\n            type: Input\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * NgxSlider module\n *\n * The module exports the slider component\n */\nclass NgxSliderModule {\n}\nNgxSliderModule.ɵfac = function NgxSliderModule_Factory(t) { return new (t || NgxSliderModule)(); };\nNgxSliderModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgxSliderModule });\nNgxSliderModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [CommonModule] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxSliderModule, [{\n        type: NgModule,\n        args: [{\n                imports: [\n                    CommonModule\n                ],\n                declarations: [\n                    SliderComponent,\n                    SliderElementDirective,\n                    SliderHandleDirective,\n                    SliderLabelDirective,\n                    TooltipWrapperComponent\n                ],\n                exports: [\n                    SliderComponent\n                ]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxSliderModule, { declarations: function () { return [SliderComponent, SliderElementDirective, SliderHandleDirective, SliderLabelDirective, TooltipWrapperComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [SliderComponent]; } }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { NgxSliderModule, ChangeContext, PointerType, LabelType, Options, SliderElementDirective as ɵb, SliderHandleDirective as ɵc, SliderLabelDirective as ɵd, SliderComponent as ɵa, TooltipWrapperComponent as ɵe };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}